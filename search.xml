<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>伯克利下肢外骨骼系统-结构与控制</title>
    <url>/2022/06/01/2-Exoskeleton/BLEEX/</url>
    <content><![CDATA[<p>BLEEX (Berkeley Lower Extremity Exoskeleton) 是世界上首个具有负载搬运能力的自主下肢外骨骼。本文将总结BLEEX的结构设计与控制方法。</p>
<img src="/2022/06/01/2-Exoskeleton/BLEEX/37221533727400.5fb0a22b2d89e.jpg" class>
<span id="more"></span>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在平地上重物通常用轮式交通工具进行运输，而在复杂地形环境下常常会遇到阻碍，因此用腿式运动的方式进行物资运输具有很大的前景。BLEEX是第一个实现这种功能的机器人系统，它为穿戴者提供各种地形下搬运负载的能力。BLEEX由两条拟人化动力腿、一个电源供应器和一个累背包框架组成，其通过跟随穿戴者的运动或运动意图来实现负载的搬运与移动，好像为穿戴者佩戴上假肢一样。BLEEX通过借助机器人的驱动“力量”和人的导航“智慧”来实现非结构化、不确定地形上的重物搬运，作为一个多功能的运输平台，能够为士兵、救灾人员、消防员提供紧急物资的搬运能力。</p>
<p><img src="/2022/06/01/2-Exoskeleton/BLEEX/1580637468954.png" style="zoom:80%;"></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote>
<p>在20世纪60年代早期，美国国防部表示有兴趣开发一种“人体放大器” - 一种增强士兵起重和携带能力的动力装甲。1962年，美国空军让康奈尔航空实验室(Cornell Aeronautical Laboratory)研究使用机器人系统实现人体放大器的可行性。在后来的研究中，康奈尔实验室设计了一种拟人形结构的机器人，并可以完成大多数想要完成的任务(Mizen 1965)，并将其命名为外骨骼。1960年到1971年，通用电气开发并测试了一个人体放大器的原型，称为哈迪曼(Hardiman)。哈迪曼是一套由人类操作员穿戴的外骨骼，外骨骼能够跟随人类操作员的运动。但这些研究发现，使用主从系统<strong>复制</strong>和<strong>放大</strong>人类的全部动作和是不现实的，人类感知的困难和系统的复杂性使它无法行走。</p>
<p>上世纪六七十年代，贝尔格莱德大学(University of Belgrade)开发了几套外骨骼系统，用以帮助截瘫患者。虽然这些早期的设备仅限于预定义的动作，并且取得了有限的成功，但所开发的平衡算法仍在许多双足机器人中使用。<strong>RoboKnee</strong>是一种动力膝关节外骨骼，它与使用者的膝关节平行工作，并将载荷传递到使用者的脚踝(Pratt et al. 2004)。<strong>HAL</strong>是一种连接大腿和小腿的矫形器，它根据佩戴者发出的肌电信号移动病人的下肢(Kawamoto,Sankai 2002)。</p>
<p>在伯克利的研究工作中，我们将增强人类能力相关的技术分为下肢外骨骼和上肢外骨骼。原因有两方面：首先，我们可以预见在不久的将来，无论是单独的下肢外骨骼还是上肢外骨骼都会有大量的应用。其次，我们认为外骨骼还处于早期阶段，在尝试整合它们之前，还需要进一步的研究来确保上肢外骨骼和下肢外骨骼能够独立工作。因此，我们分别进行了下肢和上肢外骨骼的设计，而暂时不考虑整体外骨骼的开发。下面我们将首先对伯克利分校的上肢外骨骼的工作进行总结，然后继续介绍BLEEX项目。</p>
<p>在20世纪80年代中期，我们启动了几个关于上肢外骨骼系统的研究项目，称之为人体扩展器(Kazerooni 1990)。上肢外骨骼的主要功能是增强人的力量来操作一些重的物体。施加在穿戴者绳上的力通常比操纵负载所需的力小得多。当一个工人使用上肢外骨骼来移动一个负载时，该设备自己承担大部分的重量，同时将负载的实际重量作为一个自然的反馈传递给用户。例如，一个物体每40磅的重量，工人自身可能只能支撑4磅，而设备支撑剩下的36磅。在这种情况下，工作人员仍然可以感觉到负载的重量，并据此判断自己的动作。又例如，假设一个工人使用这个设备来操作一个动力扭矩扳手(操作时会有强烈振动)，该装置可以减少从扳手传递到工人手臂上的力，并过滤那些高频的机械振动，这样工人就能更轻松更稳定的操纵扳手。</p>
<p>与上肢外骨骼不同，伯克利下肢外骨骼(BLEEX)不是矫形器或支架，它被设计成将负载重量传递到地面(而不是传递给佩戴者)，从而提高穿戴者承载重物的能力。BLEEX推出了四个新功能。(a) 开发了一种新的<strong>控制结构</strong>，通过测量外骨骼本身来控制外骨骼(Kazerooni et al. 2005)。这消除了由于直接测量交互力而导致的不稳定性(Kazerooni et al. 2005)。(b) 开发了一系列的<strong>高功率、高能量的电源</strong>，这些电源足够小，使BLEEX成为一个真正的现场操作系统(McGee, Raade, and Kazerooni 2004)。(c) 开发了具有特殊通信协议和硬件的<strong>主体局域网</strong>(Local Area Network)，以简化和减少外骨骼控制所需的所有传感器和执行器的布线任务(Kim, Anwar, and Kazerooni 2004)。(d) 设计了<strong>灵活和通用的机械结构</strong>来降低复杂性和功耗(Chu, Kazerooni, and Zoss 2005)。</p>
</blockquote>
<h2 id="结构设计"><a href="#结构设计" class="headerlink" title="结构设计"></a>结构设计</h2><h3 id="伪拟人化外骨骼整体结构"><a href="#伪拟人化外骨骼整体结构" class="headerlink" title="伪拟人化外骨骼整体结构"></a>伪拟人化外骨骼整体结构</h3><p>在外骨骼的结构设计中，通常会采用拟人化的设计思路，即将外骨骼与人体的<strong>自由度</strong>和肢<strong>体长度</strong>相匹配，使外骨骼的腿位置、关节轴线与人体完全一致。这种设计方案想法简单、自然，简化类似机械干涉的问题，但人体的关节运动(包含旋转和平移)无法通过简单技术来实现，且结构尺寸需和人体完全一致，可调节性差。而一些非拟人化的设计取得了很好的成功，例如自行车。非拟人化结构为外骨骼腿的设计带来更多的可能，但比较困难设计出与人腿功能类似的结构，同时安全性和机械干涉等问题也进一步增加了非拟人化结构的难度。</p>
<p>为了最大化安全性同时最小化环境干涉，BLEEX采用一种接近接近拟人化(Pseudo-anthropomorphic)的结构，BLEEX的腿在运动学上与人类的腿相似，但又不包括人类腿的所有自由度。BLEEX的所有关节均为纯旋转关节，同时由于外骨骼与人体的运动学不完全一致，因此人体与外骨骼只有两处刚性接触（足和躯干），其他任何地方的刚性接触都会产生很大的力。伪拟人化使得BLEEX能够轻松适应不同的穿戴者。</p>
<p><img src="/2022/06/01/2-Exoskeleton/BLEEX/1580638847708.png" style="zoom: 67%;"></p>
<h3 id="BLEEX外骨骼的自由度与关节设计"><a href="#BLEEX外骨骼的自由度与关节设计" class="headerlink" title="BLEEX外骨骼的自由度与关节设计"></a>BLEEX外骨骼的自由度与关节设计</h3><p>BLEEX的每条腿具有7个自由度：</p>
<ul>
<li>髋关节3自由度</li>
<li>膝关节1自由度（矢状面上的纯转动）</li>
<li>踝关节3自由度</li>
</ul>
<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img src="/2022/06/01/2-Exoskeleton/BLEEX/1580641561202.png" style="zoom: 67%;"></div><div class="group-picture-column" style="width: 50%;"><img src="/2022/06/01/2-Exoskeleton/BLEEX/1580642587844.png" style="zoom:67%;"></div></div></div></div>
<p>人的髋关节是一个球窝关节，具有三个自由度。因此一个很自然的想法是设计一个三轴轴线通过人体髋关节球窝的外骨骼。但通过一些前期的样机和实验发现，这种结构存在奇异性（欧拉角）和运动角度限制的问题，因此最终BLEEX的髋关节设计成上图所示形式：两条腿的旋转轴合并为后侧一个单轴，并在每条外骨骼的腿上增加一个不通过人体髋关节球窝的附加旋转轴；外骨骼的外展/内收轴（hip abduction/adduction）和伸展/弯曲轴（flexion/extension）的轴线都通过人体髋关节。</p>
<p>人体的膝关节是一个复合旋转和平移的复杂关节，BLEEX膝关节选择一个纯旋转关节使得设计简化并增加鲁棒性，同时方便动态建模。</p>
<p>对于踝关节，为了简化设计，BLEXX的踝关节只有伸展/弯曲轴通过人体的踝关节。同时BLEEX为前脚掌增加了一个自由度（柔性），使得外骨骼与人体的脚掌更加贴合。</p>
<h3 id="关节的运动范围"><a href="#关节的运动范围" class="headerlink" title="关节的运动范围"></a>关节的运动范围</h3><p>BLEEX的运动学接近于人体的运动学，因此BLEEX的关节活动范围由人体关节活动范围所决定。BLEEX的关节运动范围应当大略大于人体正常行走时的关节运动范围，同时安全性又要求BLEEX的关节运动范围应小于人体关节的最大活动角度，如表1所示。</p>
<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img src="/2022/06/01/2-Exoskeleton/BLEEX/1580643507721.png" style="zoom:100%;"></div><div class="group-picture-column" style="width: 50%;"><img src="/2022/06/01/2-Exoskeleton/BLEEX/1580644405911.png" style="zoom:40%;"></div></div></div></div>
<h3 id="辅助关节与驱动方式"><a href="#辅助关节与驱动方式" class="headerlink" title="辅助关节与驱动方式"></a>辅助关节与驱动方式</h3><p>出于控制和效率的考虑，只有部分关节是被驱动的，而其余的关节为顺从（被动）关节。驱动关节的选择是从功率角度进行考虑：踝关节和髋关节的弯曲/伸展运动在步态运动中做比较多的正功；膝关节虽然在步态运动中更多的起到能量吸收的作用，但在上下楼梯时是做最主要的做功关节；除此之外，髋关节的外展/内收运动提供主要的侧向平衡力，因此也作为驱动关节之一。最终BLEEX的每条腿具有四个驱动关节，如上右图所示。</p>
<p>BLEEX采用液压驱动，具有体积小、重量轻、驱动力大等优点，但设计非常复杂。BLEEX的液压系统能够支持在75Kg的负载（包含外骨骼）下以1.3m/s的速度前进，相应的驱动功率为2.27KW。</p>
<h3 id="模块化结构部件设计"><a href="#模块化结构部件设计" class="headerlink" title="模块化结构部件设计"></a>模块化结构部件设计</h3><p>整体模型如图9所示：</p>
<p><img src="/2022/06/01/2-Exoskeleton/BLEEX/1580644937819.png" style="zoom:67%;"></p>
<h4 id="关节设计"><a href="#关节设计" class="headerlink" title="关节设计"></a>关节设计</h4><p>BLEEX所有的关节具有统一的结构，但每个关节的驱动位置不同，类模块化的设计方便加工和装配。</p>
<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img src="/2022/06/01/2-Exoskeleton/BLEEX/1580644875143.png" style="zoom:45%;"></div><div class="group-picture-column" style="width: 50%;"><img src="/2022/06/01/2-Exoskeleton/BLEEX/1580645648736.png" style="zoom:100%;"></div></div></div></div>
<h4 id="足部设计"><a href="#足部设计" class="headerlink" title="足部设计"></a>足部设计</h4><p>BLEEX的足部是一个非常重要的部分（也是出液压驱动外设计最复杂的部分），因其所包含的诸多功能：</p>
<ul>
<li>它将外骨骼和负载的重量传递到地面上，因此要保证结构完整性和长寿命</li>
<li>它是人体和外骨骼的两处刚性接触之一，因此要保证足够的舒适性</li>
<li>它测量足底压力中心的位置，用来识别脚在地面上的状态</li>
<li>它测量人体负载的分布，从而进行控制</li>
</ul>
<p>如图11所示，BLEEX足部的主要结构由刚性的脚跟和柔性的前脚掌组成，具有三层结构。刚性脚跟用来传递力与载荷，柔性脚掌使穿戴者更舒适。顶层结构用来固定穿戴者的鞋子，底层结构含有足底开关用来检测脚与地面接触的状态，中层含有压力传感器用来测量人体与地面之间的压力（不包含外骨骼的作用力）。这些测量数据用于外骨骼的实时控制。</p>
<h4 id="大腿和小腿设计"><a href="#大腿和小腿设计" class="headerlink" title="大腿和小腿设计"></a>大腿和小腿设计</h4><p>BLEEX的大腿和小腿主要用来连接和结构支撑，这两者都被设计为可调节的结构，以方便适应不同的穿戴者。为了使液压回路最小化，设计了在阀门、执行机构、供应和回油管路之间的流体回路。</p>
<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/2022/06/01/2-Exoskeleton/BLEEX/1580647405832.png" style="zoom:67%;"></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/2022/06/01/2-Exoskeleton/BLEEX/1580647416350.png" style="zoom:67%;"></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/2022/06/01/2-Exoskeleton/BLEEX/1580647498568.png" style="zoom: 67%;"></div></div></div></div>
<h4 id="躯干设计"><a href="#躯干设计" class="headerlink" title="躯干设计"></a>躯干设计</h4><p>躯干的前侧装有操作员佩戴的安全带，这是与穿戴者的第二个刚性附着点。一般来说，绑带是由一个弯曲的，刚性的后板连接到躯干。它还包括舒适的背包状背带，可以抓住操作员，并将任何力量分配到操作员的躯干、胸部、肩膀和上背部。与大多数活动的背带不同，外骨骼背带必须在任何方向上分配力和力矩。理论上在完美的控制下在操作员和机器之间只需要转移平衡负载，但是在控制器开发期间绑带需要承受任何可能的负载。</p>
<h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><img src="/2022/06/01/2-Exoskeleton/BLEEX/37221533727400.5fb0a22b2d89e.jpg" class>
<hr>
<h2 id="控制策略"><a href="#控制策略" class="headerlink" title="控制策略"></a>控制策略</h2><p>BLEEX下肢外骨骼的有效性来自于穿戴者提供的人类智能和外骨骼提供的力量优势。换句话说，人类为外骨骼提供了一个智能控制系统，而外骨骼执行器提供了行走所需的大部分力量。控制算法确保外骨骼与穿戴者之间的协调运动，使两者之间的相互作用力最小。控制器不需要直接测量人机之间的交互力；相反，控制器只根据外骨骼自身的测量数据来估计如何移动才能让穿戴者感受到很小的力量。该控制方案之前从未应用于任何机器人系统，是在穿戴者与外骨骼的接触位置未知且不可预测的情况下产生运动的有效方法。该控制方法不同于应用于上肢外骨骼和触觉系统的柔顺控制方法，因为它不需要穿戴者与外骨骼之间的力传感器。</p>
<p>BLEEX控制的基本原理是：<strong>外骨骼需要快速且无延迟地跟踪穿戴者的自主和非自主运动</strong>。这需要对外骨骼上的力和力矩进行高灵敏性的响应，尤其是那些由穿戴者作用在外骨骼上的力。在闭环反馈系统的设计中，这一需求与控制科学中最小化系统灵敏度的目标发生冲突。如果外骨骼的灵敏度较低，它就无法与佩戴者协调运动；而提高系统对外部力和力矩的灵敏度，则会导致系统鲁棒性的损失。</p>
<p>考虑到这个新方法，我们的目标是开发一个高灵敏度的BLEEX控制系统，在这过程中面临两个现实的问题。第一问题是，外骨骼对外部力和扭矩的高灵敏度会对穿戴者以外的力做出反应。例如，如果有人推一个具有高灵敏度的外骨骼，外骨骼就会像它在穿戴者的控制下一样移动。尽管这种对于外力不稳定的行为听起来像一个严重的问题，当其发生时，穿戴者可以通过主动的控制来抵抗这些非期望的运动。稳定外骨骼并的关键在于穿戴者自身的快速移动，为自己和外骨骼创造一个稳定的环境。因此需要设计一个非常宽的控制带宽，这样外骨骼才能即使响应穿戴者的自愿和非自愿运动（对扰动的反应）。第二个问题是，对外力和扭矩的高灵敏度的系统对变化不具有鲁棒性，因此系统性能的精度将取决于外骨骼动态模型的精度。这是一个严重的缺点，但我们认为是不可避免的。尽管如此，我们实验室的各种实验已经证明了该控制方法在跟踪穿戴者运动方面的有效性。</p>
<h3 id="灵敏度放大控制"><a href="#灵敏度放大控制" class="headerlink" title="灵敏度放大控制"></a>灵敏度放大控制</h3><h4 id="单自由度情况"><a href="#单自由度情况" class="headerlink" title="单自由度情况"></a>单自由度情况</h4><p>接下将从单自由度情况对控制算法进行分析。</p>
<p><img src="/2022/06/01/2-Exoskeleton/BLEEX/1580829876938-8447654.png" style="zoom: 80%;"></p>
<p>图2所示为人腿与一自由度外骨骼的连接情况，其中外骨骼腿为一个围绕关节旋转的刚性连接，并由一个驱动器驱动，能够在A点产生一个力矩。穿戴者除了脚与外骨骼相连外，身体的其他地方也可以与外骨骼相连接，这些连接的位置和作用力的方向可以未知的。穿戴者作用在外骨骼上的等效力矩用 $d$ 表示。</p>
<p><img src="/2022/06/01/2-Exoskeleton/BLEEX/1580831833133-8447654.png" style="zoom:80%;"></p>
<p>图三表示在不考虑重力作用下，外骨骼的动力学特性：</p>
<script type="math/tex; mode=display">
v=Gr+Sd</script><p>$v$为外骨骼的角速度，$r$为驱动器输入（力矩），$G$为$r$到$v$的传递函数。$S$表示等效交互力矩$d$到外骨骼速度$v$之间的传递函数，也称为灵敏度函数。<strong>灵敏度函数表示等效交互力矩$d$与外骨骼速度$v$之间的映射关系，灵敏度函数的幅值越大则交互力越容易改变外骨骼的速度；当灵敏度函数非常大时，很小的交互力就可以产生很大的速度，换而言之人机之间的交互力会很小</strong>。如果执行机构已经有某种主要的稳定控制器，那么人机之间的交互力矩对稳定控制器而言是外界扰动，交互力矩对外骨骼的影响将会变小，新系统下灵敏度函数的幅值也会减小。</p>
<p>注意到等效交互力矩$d$并不是一个外部输入，它是关于外骨骼穿戴者生物力学和动力学的函数。控制器设计的目标是尽可能的减少等效交互力矩。一种直接的思路是对d进行测量，然后设计相应的控制器，但在我们的前期试验中发现，现有传感器技术无法做到力矩的准确测量，同时也会给系统的设计和成本带来很多问题。因此我们想通过非直接测量的方式来实现我们的控制目标。</p>
<p><img src="/2022/06/01/2-Exoskeleton/BLEEX/1580834475727-8447654.png" style="zoom:80%;"></p>
<p>考虑为外骨骼设计一个负反馈控制器$C$，如图4所示。则在反馈回路下，新的灵敏度函数为：</p>
<script type="math/tex; mode=display">
S_{N E W}=\frac{v}{d}=\frac{S}{1+G C}</script><p>可以看出在负反馈控制下，$1+G C&gt;1$，因而总是有$S_{N E W} \leq S$。</p>
<p>实际上，在经典控制和现代控制理论中，人们尽一切努力使系统对外部力和力矩的灵敏度函数最小化。但是对于外骨骼控制，我们需要一个完全相反的目标：最大化闭环系统对力和力矩的敏感性。为了实现这个目标，我们利用外骨骼的逆动力学模型，并通过正反馈进行控制：</p>
<script type="math/tex; mode=display">
S_{N E W}=\frac{v}{d}=\frac{S}{1-G C}</script><p>如果选择$C=0.9 G^{-1}$，则$S_{N F W}=10 S$，也就是在正反馈控制下外骨骼的灵敏度函数变为原来的10倍。因此我们设计的外骨骼控制器的一般形式为：</p>
<script type="math/tex; mode=display">
C=\left(1-\alpha^{-1}\right) G^{-1}</script><p>其中$\alpha$为大于1的方法系数。另外需要注意的是，在实际实现时控制器$C$中还需要加入对高频噪声的滤波器。</p>
<h4 id="参数变化的鲁棒性"><a href="#参数变化的鲁棒性" class="headerlink" title="参数变化的鲁棒性"></a>参数变化的鲁棒性</h4><p>看出这种控制器严重依赖模型，当模型不准确时，控制器的性能较差。当模型存在10%的不确定时，灵敏度函数的不确定性达到90%。因此要想要使这种方法有比较好的效果，就必须对外骨骼的动力学模型有深刻的理解。这种方法可以看做是传感与控制之间一种tradeoff：若想不依赖交互力的信息，则必须要有准确的模型。这种方法本身不具备稳定性，系统的稳定是由穿戴者自身的控制来实现，接下来我们将进一步说明。</p>
<h4 id="人体动力学"><a href="#人体动力学" class="headerlink" title="人体动力学"></a>人体动力学</h4><p>在所涉及的控制方案中，不需要考虑穿戴者肢体模型的内部组成：神经传导、肌肉收缩以及中枢神经系统的详细动态过程，这些在构建飞行员肢体的动态模型时被隐式地考虑。假设穿戴者与外骨的人机交互力是关于穿戴者人体的动力学$H$和运动学的函数，这里认为$H$是一个非线性函数并表示穿戴者的运动学与交互阻抗之间的关系：</p>
<script type="math/tex; mode=display">
d=-H(v)</script><p><img src="/2022/06/01/2-Exoskeleton/BLEEX/1580849529486-8447654.png" style="zoom:80%;"></p>
<p>考虑人体动力学之后，人机系统就可以看过是一个双闭环的系统，如上图所示。上层反馈环路展示穿戴者的交互力对外骨骼的影响，底层环路展示反馈控制器对外骨骼的作用。尽管下面环路中的控制器是一个不稳定的正反馈，但上面环路中穿戴者的操控可以使整个系统得以稳定。也就是说，系统的稳定性取决于人体的平衡能力，人的平衡能力越强，那就可以设计更加不稳定的控制器，使人承受更多的重量，为此，作者Kazerooni改用尼采的名言来描述这种方法：</p>
<blockquote>
<p><strong>That which does not stabilize, will only make us stronger.</strong></p>
</blockquote>
<p><img src="/2022/06/01/2-Exoskeleton/BLEEX/v2-8369d023b420645ae1a71d284f884ba4_1440w.jpeg" style="zoom:50%;"></p>
<h3 id="控制算法的实现"><a href="#控制算法的实现" class="headerlink" title="控制算法的实现"></a>控制算法的实现</h3><p>在一般的步态分析中，步态周期通常被划分为7个阶段。在本文的方法中，出于简单考虑我们将其分为具有不同动力学模型的3个阶段：单支撑阶段、双支撑阶段和有冗余的双支撑阶段，最后一个是指后侧脚后跟抬起的状态，如图8所示：</p>
<p><img src="/2022/06/01/2-Exoskeleton/BLEEX/1580850923188-8447654.png" style="zoom:90%;"></p>
<p>在控制器设计的初期，我们将髋关节外展/内收的控制与其他的控制进行了解耦。髋关节的外展/内收运动相对缓慢，与矢状面运动相比，外展-内收运动可视为准静态运动，对系统其余部分的动态影响较小；这也表明外骨骼矢状面上的动力学只受髋关节外展/内收角影响，而与其速度、加速度无关。</p>
<h4 id="单支撑阶段"><a href="#单支撑阶段" class="headerlink" title="单支撑阶段"></a>单支撑阶段</h4><p>在单支撑阶段，我们将BLEEX建模为矢状面上7自由度的连杆机构，如图10所示。动力学模型可以表示为：</p>
<script type="math/tex; mode=display">
M(\theta) \ddot{\theta}+C(\theta, \dot{\theta}) \dot{\theta}+P(\theta)=T+d</script><p>其中$\theta=\left[\begin{array}{lll}{\theta_{1}} &amp; {\theta_{2}} &amp; {\cdots} &amp; {\theta_{7}}\end{array}\right]^{T}$，$T=\left[\begin{array}{lll}{0} &amp; {T_{1}} &amp; {T_{2}} &amp; {\dots} &amp;  {T_{6}} \end{array}\right]^{T}$，$M$ 为质量矩阵，$C$ 为离心力与科氏力矩阵，$P$ 为重力向量，$T$ 为驱动器力矩向量，$d$ 为等效人机交互力矩向量。</p>
<p>则控制器的控制可表示为：</p>
<script type="math/tex; mode=display">
T=\hat{P}(\theta)+\left(1-\alpha^{-1}\right)[\hat{M}(\theta) \ddot{\theta}+\hat{C}(\theta, \dot{\theta}) \dot{\theta}]</script><p>其中第一项可以理解为对重力作用的补偿，后面一项为正反馈项。在理想情况下，放大系数较大时，交互力矩近似接近于零；每当人机之间存在交互力时，控制器控制电机迅速产生驱动作用补偿由模型估计的交互力，使得交互力维持在一个很小的水平。</p>
<p><img src="/2022/06/01/2-Exoskeleton/BLEEX/1580851493579-8447654.png" style="zoom:67%;"></p>
<h4 id="双支撑阶段"><a href="#双支撑阶段" class="headerlink" title="双支撑阶段"></a>双支撑阶段</h4><p><img src="/2022/06/01/2-Exoskeleton/BLEEX/1580853229872-8447654.png" style="zoom:67%;"></p>
<p>在双支撑阶段，BLEEX的两条腿与地面均有接触与力的作用。外骨骼被建模为两个三自由度平面连杆并在顶轴相连接，如图11所示。动力学模型表示为如下形式：</p>
<script type="math/tex; mode=display">
M_{L}\left(m_{T L}, \theta_{L}\right) \ddot{\theta}_{L}+C_{L}\left(m_{T L}, \dot{\theta}_{L}, \theta_{L}\right) \dot{\theta}_{L}+P_{L}\left(m_{T L}, \theta_{L}\right)=T_{L}+d_{L}</script><script type="math/tex; mode=display">
M_{R}\left(m_{T R}, \theta_{R}\right) \ddot{\theta}_{R}+C_{R}\left(m_{T R}, \dot{\theta}_{R}, \theta_{R}\right) \dot{\theta}_{R}+P_{R}\left(m_{T R}, \theta_{R}\right)=T_{R}+d_{R}</script><p>其中$ \theta_{L}=\left[\begin{array}{lll}{\theta_{L I}} &amp; {\theta_{L 2}} &amp; {\theta_{L 3}}\end{array}\right]^{T}$， $\theta_{R}=\left[\begin{array}{lll}{\theta_{R l}} &amp; {\theta_{R 2}} &amp; {\theta_{R 3}}\end{array}\right]^{T}$，$m_{T R}$和$m_{T L}$表示每条腿所支撑的躯干质量，并进一步用躯干质心相对踝关节的水平距离进行简化计算（只在准静态条件下适用）：</p>
<script type="math/tex; mode=display">
\frac{m_{T R}}{m_{T L}}=\frac{x_{T L}}{x_{T R}}</script><p>在双支撑阶段，控制器的控制率可表示为：</p>
<script type="math/tex; mode=display">
T_{L}=\hat{P}_{L}\left(m_{T L}, \theta_{L}\right)+\left(1-\alpha^{-1}\right)\left[\hat{M}_{L}\left(m_{T L}, \theta_{L}\right) \ddot{\theta}_{L}+\hat{C}_{L}\left(m_{T L}, \theta_{L}, \dot{\theta}_{L}\right) \dot{\theta}_{L}\right]</script><script type="math/tex; mode=display">
T_{R}=\hat{P}_{R}\left(m_{T R}, \theta_{R}\right)+\left(1-\alpha^{-1}\right)\left[\hat{M}_{R}\left(m_{T R}, \theta_{R}\right) \ddot{\theta}_{R}+\hat{C}_{R}\left(m_{T R}, \theta_{R}, \dot{\theta}_{R}\right) \dot{\theta}_{R}\right]</script><h4 id="冗余双支撑阶段"><a href="#冗余双支撑阶段" class="headerlink" title="冗余双支撑阶段"></a>冗余双支撑阶段</h4><p>在冗余双支撑阶段，外骨骼的站立腿建模为平面三连杆，而另一条腿建模为平面四连杆，如图11所示。动力学模型与双支撑阶段形式相同，其中</p>
<script type="math/tex; mode=display">
\theta_{L}=\left[\begin{array}{llll}{\theta_{L 1}} & {\theta_{L 2}} & {\theta_{L 3}} & {\theta_{L 4}}\end{array}\right]^{T}</script><script type="math/tex; mode=display">
\theta_{R}=\left[\begin{array}{lll}{\theta_{R I}} & {\theta_{R 2}} & {\theta_{R 3}}\end{array}\right]^{T}</script><script type="math/tex; mode=display">
T_{L}=\left[\begin{array}{llll}{0} & {T_{L 1}} & {T_{L 2}} & {T_{L 3}}\end{array}\right]^{T}</script><script type="math/tex; mode=display">
T_{R}=\left[\begin{array}{lll}{T_{R 1}} & {T_{R 2}} & {T_{R 3}}\end{array}\right]^{T}</script><h3 id="混合控制"><a href="#混合控制" class="headerlink" title="混合控制"></a>混合控制</h3><p>灵敏度放大控制能够快速跟随穿戴者的运动，但这种方法依赖系统的精确模型，当模型、负载变化时会严重影响控制性能。之后BLEEX的研究人员采用混合控制策略：支撑阶段采用位置控制，摆动阶段采用灵敏度放大控制。这种控制能够降低对精确模型的依赖程度，从而提高系统的鲁棒性和稳定性。</p>
<p>在步态运动的过程中，摆动腿运动范围大但只需要支撑自己的重量，支撑腿的运动范围小但却需要支撑整个躯干和负载的重力；反应到控制中，摆动腿需要相对小的力矩和相对高的带宽，而支撑腿需要相对大的力矩和相对低的带宽。基于这个观点，我们在BLEEX中采用混合控制：支撑阶段采用位置控制，而摆动阶段采用灵敏度放大控制。因此，鲁棒稳定性（支撑阶段的位置控制）和对穿戴者人机交互力的高灵敏性（摆动阶段的灵敏度放大控制）能够在BLEEX上同时得以实现。</p>
<h4 id="摆动阶段：灵敏度放大控制"><a href="#摆动阶段：灵敏度放大控制" class="headerlink" title="摆动阶段：灵敏度放大控制"></a>摆动阶段：灵敏度放大控制</h4><p>在摆动阶段采用灵敏度放大控制，正如如上所述，其中只采用摆动阶段的建模与控制。</p>
<h4 id="支撑阶段：位置控制"><a href="#支撑阶段：位置控制" class="headerlink" title="支撑阶段：位置控制"></a>支撑阶段：位置控制</h4><p>在支撑阶段，控制器使外骨骼的关节角度跟踪穿戴者的关节角度，控制结构图如下：</p>
<p><img src="/2022/06/01/2-Exoskeleton/BLEEX/1581258656321.png" style="zoom:80%;"></p>
<p>理想情况下，当角度误差为零时，人机之间的交互力矩也近似为零。控制器的实现采用比例控制：</p>
<script type="math/tex; mode=display">
T_{a c t}=K\left(\theta_{h}-\theta_{e x o}\right)</script><p>对于每一个关节，采用独立的控制器进行控制：</p>
<p><img src="/2022/06/01/2-Exoskeleton/BLEEX/1581259115805.png" style="zoom:80%;"></p>
<p>在单关节（膝关节）情况下的控制效果如下所示（采样周期25ms），在低频时有不错的跟踪效果：</p>
<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img src="/2022/06/01/2-Exoskeleton/BLEEX/1581258867007.png" class></div><div class="group-picture-column" style="width: 50%;"><img src="/2022/06/01/2-Exoskeleton/BLEEX/1581258884955.png" class></div></div></div></div>
<p>在进行位置控制时，有两点需要注意。第一个问题是外骨骼与人体之间必须为柔顺连接，如图6所示。当人体想要进行运动时，其必须要很容易就能移动，也就是人机之间的阻抗应当很小，这样才能够产生位置误差，进而使外骨骼跟随；当人机之间为图11所示刚性连接时，穿戴者需要同时移动自己和外骨骼，此时人机之间的关节角误差将始终为零，同时交互力矩也将会很大。</p>
<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img src="/2022/06/01/2-Exoskeleton/BLEEX/1581259199208.png" class></div><div class="group-picture-column" style="width: 50%;"><img src="/2022/06/01/2-Exoskeleton/BLEEX/1581259345430.png" class></div></div></div></div>
<p>另外一个问题是外骨骼关节角与人体关节角之间的差异，由于BLEEX是拟人化设计，角度差异所导致的影响比较小，因此就没有专门进行处理。</p>
<blockquote>
<p>在研究的前期阶段，研究人员有尝试在步态的整个过程都使用位置控制，但很快发现这种方法在摆动阶段并不合适。穿戴者需要主动移动躯干才能使外骨骼前进，因此外骨骼的行走过程非常不自然，同时穿戴者感觉也非常不舒服。</p>
</blockquote>
<h4 id="控制器的过渡问题"><a href="#控制器的过渡问题" class="headerlink" title="控制器的过渡问题"></a>控制器的过渡问题</h4><p>由于在步态过程中采用两种不同的控制方案，为了避免控制器切换时的突变，需要设置控制器的过渡策略。研究采用渐变增益的方法，其中由灵敏度放大控制切换到位置控制的过渡时间为1s，由位置控制切换到灵敏度放大控制的过渡时间为0.4s。</p>
<hr>
<h2 id="小结与思考"><a href="#小结与思考" class="headerlink" title="小结与思考"></a>小结与思考</h2><p>从设计初衷来说，BLEEX的operator的思想使其更像是“机甲”，穿戴者是一个“装甲”的操作者而不是一个被强化的“Superman”。作为旧世代最出名的外骨骼，BLEEX的结构设计有诸多精妙之处。BLEEX将外骨骼结构设计向伪拟人化和非拟人化方向拓展，非拟人化架构只在躯干和足部进行刚性固定，而中间没有刚性固定；人和外骨骼具有各自的运动链，可看做并联结构，没有关节轴对齐问题；结构上的Actuator Mount、Foot Attachment、Length Adjustment、Pressure Sensor都值得借鉴，模块化设计也是很好的尝试。</p>
<p>本研究所提出的灵敏度放大方法本质上是一种正反馈控制，通过放大扰动来实现对穿戴者的运动跟随。控制器本身不具有稳定性，但可以由穿戴者稳定住整个系统。灵敏度放大不直接测量交互力，控制带宽高、响应快，但对模型参数不具有鲁棒性，无法对抗外界扰动，以至于作者自身都不得不考虑使用混合控制来减少不稳定的影响。虽算法本身在真实系统上实现时会遇到各种问题，但其所反映的思想却清晰直观：外骨骼控制的目的是放大，放大人体力量，并同时降低人体所承受的作用。这为外骨骼领域的研究拓展了思路，在很多系统中依然可以看到这个思想的影子。</p>
<hr>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="/download/2005_BLEEX_mechanical_design.pdf">On the Mechanical Design of the  Berkeley Lower Extremity Exoskeleton (BLEEX)</a></p>
<p><a href="/download/2005_BLEEX_Control.pdf">On the Control of the  Berkeley Lower Extremity Exoskeleton (BLEEX)</a></p>
<p><a href="/download/2006_BLEEX_Hybird_Control.pdf">Hybrid Control of the Berkeley Lower Extremity Exoskeleton (BLEEX)</a></p>
]]></content>
      <categories>
        <category>exoskeleton</category>
      </categories>
      <tags>
        <tag>外骨骼系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Stanford下肢外骨骼系统设计控制与优化</title>
    <url>/2022/06/01/2-Exoskeleton/Stanford%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%8E%A7%E5%88%B6%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>下肢外骨骼能够提高士兵、急救人员、体力工人、老年人、肢体损伤患者的动能力。在前期研究中，Stanford大学的Steven H Collins（原卡内基梅隆大学）研究组已经设计了踝关节骨骼用于步态运动过程的辅助，并成功的降低了穿戴者的代谢耗能。在此基础上，该研究组进一步设计开发了髋-膝-踝三关节外骨骼系统，用于外骨骼辅助策略的探索。本篇博客将简要介绍该三关节外骨骼的设计、控制与优化。</p>
<p><img src="/2022/06/01/2-Exoskeleton/Stanford%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%8E%A7%E5%88%B6%E4%B8%8E%E4%BC%98%E5%8C%96/image-20210405104954391.png" alt="image-20210405104954391" style="zoom:80%;"></p>
<span id="more"></span>
<h2 id="外骨骼设计"><a href="#外骨骼设计" class="headerlink" title="外骨骼设计"></a>外骨骼设计</h2><p><img src="/2022/06/01/2-Exoskeleton/Stanford%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%8E%A7%E5%88%B6%E4%B8%8E%E4%BC%98%E5%8C%96/2.png" alt="image-20210405183442911" style="zoom:80%;"></p>
<p>该外骨骼系统依然是采用emulator方式，end-effector穿戴在人体上，能够为髋关节、膝关节的弯曲和伸展以及踝关节的跖屈提供力矩辅助，两侧共计十个驱动电机与人体分离，电机的辅助通过鲍登管进行传递。整个外骨骼的机械结构由躯干、大腿、小腿和足部四个部分组成，每个部分主要由矢状面上的碳纤维板和横向的铝合金/钛合金支撑，除了换踝关节部分以外，其余的横向连接件都采用管型设计，能够提供更高的弯曲强度和扭转强度，各个部分之间通过关节轴轴进行连接。</p>
<p><img src="/2022/06/01/2-Exoskeleton/Stanford%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%8E%A7%E5%88%B6%E4%B8%8E%E4%BC%98%E5%8C%96/image-20210405183442911.png" alt="image-20210405183442911" style="zoom:60%;"></p>
<p>躯干部分由后背X型的碳纤维支架和腰部框架组成，两者之间通过一个竖直的碳纤维板进行连接。X型的碳纤维支架用来连接肩部吊带和背部护垫，一方面将外骨骼的重量更均匀的分配，另一方面增加了躯干远端的接触能够提高外骨骼与人体之间交互柔顺性。</p>
<p>腰部框架由一个铝合金管和两侧的碳纤维板组成，碳纤维板的前部和后部分别由两个鲍登管的固定结构(图中的h)，这个固定结构包括三个部分：用来转换鲍登绳方向的滑轮，用来固定鲍登外管、同时防止鲍登绳脱落的黑色尼龙结构，以及用来防止鲍登管过度弯曲的白色弹性TPU护圈。碳纤维板的中下部安装的是外骨骼的髋关节轴，每个轴都由两个轴承来支撑，关节轴的外侧装有绝对式的磁编码器。</p>
<p><img src="/2022/06/01/2-Exoskeleton/Stanford%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%8E%A7%E5%88%B6%E4%B8%8E%E4%BC%98%E5%8C%96/image-20210405183522883.png" alt="image-20210405183522883" style="zoom:60%;"></p>
<p>大腿部分采用分体式设计，上部分碳纤维板连接髋关节，下部分连接膝关节，两块碳板之间通过一组孔进行固定，可以通过孔的位置来调整大腿部分的整体长度。来自腰部的鲍登绳在经过横向支撑管上的滑轮改变方向后，连接到垂直于碳纤维板的拉力传感器上。在前侧和后侧横向支架的中间，分别有用于膝关节弯曲于伸展辅助的鲍登管的固定端；在膝关节内侧有用来减缓碰撞的尼龙保护壳，外侧有安装磁编码器测量膝关节角度。</p>
<p><img src="/2022/06/01/2-Exoskeleton/Stanford%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%8E%A7%E5%88%B6%E4%B8%8E%E4%BC%98%E5%8C%96/image-20210405203009154.png" alt="image-20210405203009154" style="zoom:60%;"></p>
<p>小腿部分和大腿部分一样采用了分体式结构，通过调节连接孔的方式改变小腿部分的长度。在前侧的横向支架和后方的铝合金悬臂上装有拉力传感器(a, f)，分别测量膝关节弯曲与伸展辅助的辅助力。这两个拉力传感器都可以沿着安装轴旋转，使得测量方向始终与拉力方向共线，同时有额外的尼龙结构防止鲍登绳松弛时拉力传感器的过度旋转。</p>
<p><img src="/2022/06/01/2-Exoskeleton/Stanford%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%8E%A7%E5%88%B6%E4%B8%8E%E4%BC%98%E5%8C%96/image-20210405203138708.png" alt="image-20210405203138708" style="zoom:60%;"></p>
<p><img src="/2022/06/01/2-Exoskeleton/Stanford%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%8E%A7%E5%88%B6%E4%B8%8E%E4%BC%98%E5%8C%96/image-20210406084432773.png" alt="image-20210406084432773" style="zoom:60%;"></p>
<p>足部部分主体沿用了之前踝关节外骨骼的设计，但脚跟处的拉绳变为了刚性的碳纤维，碳纤维板通过一个铝合金悬臂连接到关节轴上，底部通过一个钢轴连接到鞋跟，同时前脚掌的碳纤维板也换为了钢轴。在踝关节轴的内侧同样增加了一个尼龙外壳以减轻两侧之间的碰撞。</p>
<h2 id="外骨骼驱动"><a href="#外骨骼驱动" class="headerlink" title="外骨骼驱动"></a>外骨骼驱动</h2><p><img src="/2022/06/01/2-Exoskeleton/Stanford%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%8E%A7%E5%88%B6%E4%B8%8E%E4%BC%98%E5%8C%96/3.png" alt="image-20210406103333588" style="zoom:60%;"></p>
<p>这套外骨骼的每条腿共有五个驱动自由度，以驱动作用在外骨骼上的角度来看，髋关节弯曲(flexion)辅助的鲍登线从腰部碳纤维板前侧连接到大腿碳纤维板前侧的支撑横架，再通过滑轮转向后垂直连接到大腿碳纤维板上，实际的辅助仅为腰部前侧碳纤维板到大腿前侧支撑横架这一段，通过滑轮转向仅为了方便拉力传感器的安装和测量。髋关节伸展辅助的鲍登线从腰部碳纤维板后部连接到大腿碳纤维板后方伸出的横向支架上，同样通过滑轮转向后连接到大腿碳纤维板。膝关节弯曲辅助的鲍登绳从大腿后方横向支架连接到小腿后方的横向支架上，伸展辅助则是由大腿前侧支撑横架连接到小腿前侧的横向支架。对于膝关节伸展辅助，通过合适的几何设计，使得当膝关节角度为零时，拉力作用线对膝关节轴的力臂也为零，从而提供保护作用。踝关节趾屈辅助则是和之前一样，通过小腿后方的横向支撑连接到足部后方的碳合金悬臂上。</p>
<img src="/2022/06/01/2-Exoskeleton/Stanford%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%8E%A7%E5%88%B6%E4%B8%8E%E4%BC%98%E5%8C%96/image-20210406091944324.png" class title="image-20210406091944324">
<p>外骨骼的机械结构通过脚上的靴子和身体各部分的绑带将外骨骼的辅助传递到人体上，设计时绑带上的作用力被设计为法向力，从而尽可能的为人体提供力矩辅助。为了降低人体与外骨骼之间的交互力，绑带被尽可能的佩戴在辅助关节的远端肢体上，比如对于髋关节辅助，大腿上靠近膝关节的绑带和躯干的肩带与背垫都有更长的力臂，从而降低绑带上的拉力。</p>
<p><img src="/2022/06/01/2-Exoskeleton/Stanford%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%8E%A7%E5%88%B6%E4%B8%8E%E4%BC%98%E5%8C%96/image-20210406103118884.png" alt="image-20210406103118884" style="zoom:60%;"></p>
<p><img src="/2022/06/01/2-Exoskeleton/Stanford%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%8E%A7%E5%88%B6%E4%B8%8E%E4%BC%98%E5%8C%96/image-20210406103333588.png" alt="image-20210406103333588" style="zoom:60%;"></p>
<p>整套外骨骼重13.5kg，其中机械部分仅重7.5kg，靴子和鲍登管都有比较大的重量。在9名测试者的穿戴实验中，1.25m/s的步态速度下，平均代谢耗能相对于不穿戴外骨骼增加了1.18W/kg，除去静态代谢，相当于增加了38.8%的代谢消耗。</p>
<p><img src="/2022/06/01/2-Exoskeleton/Stanford%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%8E%A7%E5%88%B6%E4%B8%8E%E4%BC%98%E5%8C%96/4.png" alt="image-20210406103333588"></p>
<p>研究人员将该外骨骼穿戴在铝合金框架上对外骨骼的结构性能进行了测试，其中髋关节弯曲、伸展，膝关节伸展，踝关节趾屈都能提供200Nm以上的力矩，膝关节弯曲辅助最大能提供140Nm的力矩。闭环带宽的结果存在一定的问题，但总体来说带宽都大于10Hz，表明系统能提供很好的力矩跟踪特性。</p>
<h2 id="外骨骼控制"><a href="#外骨骼控制" class="headerlink" title="外骨骼控制"></a>外骨骼控制</h2><p><img src="/2022/06/01/2-Exoskeleton/Stanford%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%8E%A7%E5%88%B6%E4%B8%8E%E4%BC%98%E5%8C%96/image-20210406114738373.png" alt="image-20210406114738373"></p>
<p>外骨骼系统采用了和之前相同的控制方法，控制器由上层力矩规划和底层的反馈控制组成。对于上层控制器，三个关节都有各自的期望力矩曲线，其中髋关节的辅助曲线和之前的定义完全一致，因此不在赘述。对于膝关节和髋关节外辅助，由于辅助力矩包含了弯曲和伸展两个方向，对于特定的方向，只有相应的辅助进行力矩控制，而与之相对的辅助采用跟随控制，从而使辅助在方向切换时能尽可能平滑。膝关节的辅助在步态前期到步态中期采用虚拟弹簧提供伸展力矩以模拟弹簧腿的特性，在支撑中期到支撑后期提供一个基于步态时间弯曲力矩。髋关节辅助在摆动末期到支撑初期提供伸展力矩，也就是后面的鲍登绳提供拉力，在支撑中期到摆动中期提供弯曲辅助，也就是前侧的鲍登绳产生拉力，由于髋关节在步态开始时刻，也就是脚跟着地时刻，处于力矩辅助状态，为了避免可能出现的期望力矩跳变，髋关节期望力矩曲线定义步态周期的84%为起始时刻。</p>
<script type="math/tex; mode=display">
\begin{array}{c}
u(i, n)=K_{\mathrm{p}} \cdot e(i, n)+K_{\mathrm{v}} \cdot \dot{\theta}_{\mathrm{m}}(i, n)+u_{\mathrm{L}}(i+D, n) \\
u_{\mathrm{L}}(i, n+1)=\beta \cdot u_{\mathrm{L}}(i, n)+K_{\mathrm{L}} \cdot e(i, n)
\end{array}</script><p>底层控制器依然采用<strong>力矩误差反馈</strong>加<strong>电机角速度的阻尼注入</strong>再加<strong>迭代学习</strong>的方式，下图为多关节辅助时的力矩跟踪效果，其中膝关节辅助在虚拟阻抗阶段由于无法进行迭代学习，因此有较大的跟踪误差，髋关节辅助在力矩方向转换时也有一个明显的跟踪误差。跟踪误差的RMS为1.81Nm，约9%的峰值力矩。</p>
<img src="/2022/06/01/2-Exoskeleton/Stanford%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%8E%A7%E5%88%B6%E4%B8%8E%E4%BC%98%E5%8C%96/image-20210406144425976.png" class title="image-20210406144425976">
<h2 id="外骨骼辅助优化"><a href="#外骨骼辅助优化" class="headerlink" title="外骨骼辅助优化"></a>外骨骼辅助优化</h2><p>在这样的多关节下肢外骨骼平台上，我们最希望从中了解的就是多关节外骨骼的辅助效果。毫无疑问多关节辅助肯定比单关节辅助有更高的效益，但考虑到外骨骼自身结构、重量带来的负面影响，某些形式的单关节外骨骼辅助可能更有效率，因此Collins研究组在这套多关节外骨骼上采用人在环中优化方法对不同关节组合辅助进行了对比。</p>
<p><img src="/2022/06/01/2-Exoskeleton/Stanford%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%8E%A7%E5%88%B6%E4%B8%8E%E4%BC%98%E5%8C%96/image-20210406220740906.png" alt="image-20210406220740906"></p>
<p>外骨骼三个关节的辅助力矩曲线与之前控制器中的力矩曲线形式基本一致。其中踝关节辅助依然是四个参数；髋关节辅助包括弯曲力矩和伸展力矩，每个部分都和踝关节的单峰辅助有相同的形式，因此有八个参数；膝关节辅助由虚拟刚度、时间力矩和虚拟阻尼三部分组成，时间力矩部分具有四个参数，虚拟刚度部分和虚拟阻尼部分各有三个参数，因此共有10个参数。三个关节一共有22个优化参数。</p>
<img src="/2022/06/01/2-Exoskeleton/Stanford%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%8E%A7%E5%88%B6%E4%B8%8E%E4%BC%98%E5%8C%96/image-20210407095126152.png" class title="image-20210407095126152">
<p>人在环中优化采用的依然是CMA-ES算法。受新冠病毒的影响，该项研究的受试者仅有三名，年龄从19岁到26岁，体重从60kg到90kg。人在环中优化实验分为三组，分别为单关节辅助优化，双关节辅助优化和三关节辅助优化，其中双关节辅助只有受试者P1进行。优化的时间长度可能影响最终的优化结果，因此P1受试者的优化实验进行了较长的时间，踝关节辅助优化了12代，可以在优化代数更新的中间中断休息，整个优化在3天内完成，但由于缺乏补充材料，并不清楚更具体的实验细节；髋关节、膝关节和三关节辅助优化进行了9代，双关节辅助优化进行了6代。在P1的基础上，受试者P2和P3优化的代数要小一些，更多细节在补充材料中，但每个受试者总的实验时间不小于50小时。</p>
<p>人在环中优化完成后，优化结果通过验证实验进行评估，其中静态站立6min，零力矩模式行走10min，每个辅助模式行走20min，实验中测量了受试者的代谢肌电和关节角度。</p>
<p><img src="/2022/06/01/2-Exoskeleton/Stanford%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%8E%A7%E5%88%B6%E4%B8%8E%E4%BC%98%E5%8C%96/image-20210407133156706.png" alt="image-20210407133156706" style="zoom:60%;"></p>
<p>代谢耗能的结果均以减去了站立时静态代谢，且都是以穿戴外骨骼无辅助模式进行对比。无外骨骼的代谢相对于穿外骨骼无辅助低22%，相当于穿戴外骨骼增加了28%的代谢消耗。在各种辅助策略下，代谢耗能均有一定程度的下降。单关节辅助而策略下，踝关节的辅助效益最明显，代谢下降30%，髋关节下降26%，膝关节下降13%且不显著。单受试者的双关节辅助优化结果表示，髋-踝组合辅助的效益最大，代谢耗能下降42%。在三关节辅助下，代谢耗能有60%的下降。无论是单关节辅助还是双关节的组合，膝关节辅助的作用相比另两个关节更不明显，这个优化辅助的结果与步态分析相一致，因为踝关节是行走过程产生能量最大的关节，髋关节次之，膝关节最小。在其他的步态运动中，例如上坡、上下台阶，膝关节辅助可能会起到更大的作用。另一方面，膝关节的优化参数是三个关节中最多的，不充分的优化可能是导致膝关节辅助效益较低的一个原因，后面的优化力矩结果会进一步说明。另外一个值得关注的是，单关节辅助比多关节辅助有更大平均效益，即三个关节单独辅助的代谢下降之和，要小于三关节共同辅助的代谢下降。由于关节之间存在耦合，辅助影响了行走的整个动力学过程，单关节辅助也会的对其他的关节产生影响，使得代谢有更大程度的下降。因此考虑到结构复杂性与外骨骼的附加重量，可能但关节外骨骼，或某些组合的双关节外骨骼，可能比全下肢外骨骼更有效率。</p>
<img src="/2022/06/01/2-Exoskeleton/Stanford%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%8E%A7%E5%88%B6%E4%B8%8E%E4%BC%98%E5%8C%96/image-20210407140302142.png" class title="image-20210407140302142">
<p>不同辅助组合下优化的关节力矩如上图所示。其中踝关节和髋关节的辅助曲线，在不同的辅助组合下具有比较好的一致性。踝关节力矩在单关节辅助下有更大的力矩峰值，在多关节辅助下有更大的上升时间，且几种不同的组合下的优化力矩基本相同。髋关节力矩在在不同的辅助组合下，力矩峰值有明显差异，但峰值时间基本一致，其中髋-踝辅助时弯曲力矩峰值最大，髋-膝辅助时伸展力矩峰值最大，而三关节辅助时的力矩峰值相对较小。膝关节辅助力矩的优化结果比较缺乏规律，尤其三关节优化的结果力矩比较小。一方面所设置的膝关节辅助曲线形式可能并不合适，目前对于膝关节的辅助研究相比于踝关节和髋关节还不够充分；另一方面由于膝关节辅助的优化参数太多，算法容易收敛到局部极值，高维优化的效果可能并不理想。因此后面非常有必要探索影响膝关节辅助效果的核心参数，就像踝关节的峰值力矩峰值与峰值时间那样，并在更需要膝关节的步态运动中探索膝关节的辅助效益。</p>
]]></content>
      <categories>
        <category>exoskeleton</category>
      </categories>
      <tags>
        <tag>外骨骼系统</tag>
      </tags>
  </entry>
  <entry>
    <title>下肢外骨骼系统简介</title>
    <url>/2022/06/01/2-Exoskeleton/%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>可穿戴机器人是人类长久以来的梦想，它能够像衣服一样方便的穿戴在身体上。通过外骨骼的辅助，穿戴者能够实现原本难以实现或不可能实现的任务。根据设计目的和应用领域，外骨骼可主要分为三类：辅助外骨骼、康复外骨骼和增强型外骨骼。</p>
<img src="/2022/06/01/2-Exoskeleton/%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/1606959581158.png" class title="|center">
<span id="more"></span>
<p>辅助外骨骼<code>Assistive Exoskeleton</code>通常用来弥补穿戴者已经丧失的能力，使其在辅助下能够完成基本的日常活动，其作用类似于假肢。例如对于脊髓损伤的患者，辅助外骨骼能够帮助他们重新行走。这类外骨骼较多采用位置控制策略，并且需要较高的控制精度，因为穿戴者完全没有运动能力；控制器中会预先设定好不同模式的运动轨迹，由穿戴者的运动意图触发，在不同的模式之间切换。</p>
<p>康复外骨骼<code>Rehabilitation Exoskeleton</code>通常用来帮助恢复穿戴者受损伤的能力，使穿戴者能最终能够不借助外骨骼完成基本的日常活动。这类外骨骼通常需要在线调整控制策略，使外骨骼仅在“需要”时进行辅助，并随着穿戴者能力的提升逐渐减小辅助。控制上也有部分预定义的运动轨迹，因为穿戴者在康复时需要正确的运动轨迹进行指引，同时控制系统也会根据穿戴者的实际反应进行调整。在康复外骨骼的设计中，尺寸重量便携性一般不作考虑，大部分康复外骨骼系统都是固定在跑步机上，并在医生监督下使用。</p>
<p>最后一类下肢外骨骼是用来增强人体能力<code>Augmentation Exoskeleton</code>，设计理念可以用一句话概括：<code>making the user superman.</code>增强型外骨骼通常装备在健康个体身上，因此预定义轨迹的策略不再适用，外骨骼大多跟随穿戴者的肢体运动，例如采用阻抗/导纳控制甚至基于正反馈的灵敏度放大控制。由于穿戴者本身具备运动能力，因此这类外骨骼通常采用非精确但有高能量密度的驱动器，如串联弹性驱动<code>SEA</code>、液压驱动等。</p>
<p>由于不同类别的外骨骼有着完全不同的目的，结构设计、控制策略都有所不同，接下来我们对每个类别的外骨骼进行简单讨论。</p>
<h2 id="辅助型外骨骼"><a href="#辅助型外骨骼" class="headerlink" title="辅助型外骨骼"></a>辅助型外骨骼</h2><img src="/2022/06/01/2-Exoskeleton/%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/1606959610532.png" class title="|center">
<p>辅助外骨骼主要用于脊髓损伤<code>spinal cord injury(SCI)</code>患者。大部分胸椎级别的脊髓损伤患者永久失去了行走能力，只能通过轮椅进行移动。然而轮椅的可达范围是非常有限的，长时间保持坐立状态也会带来很多健康问题，例如压疮、骨结节、下肢骨密度降低等，因此需求一种能够帮助穿戴者保持直立并有良好移动性的辅助设备。</p>
<img src="/2022/06/01/2-Exoskeleton/%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/1606960023906.png" class title="|center">
<p>辅助性外骨骼一般是采用层次控制器，实际上大部分外骨骼系统都是采用层次控制器。由于SCI患者完全失去了运动能力，因此基本上不需要考虑人机交互问题，外骨骼辅助能够使穿戴者完成基本运动即达到目标，因此辅助性外骨骼的控制通常采用位置控制策略。由于穿戴者没有运动能力，所以需要先识别出穿戴者的运动意图，如“前进”、“停止”等。除了额外的操作手柄外，目前商业化的辅助外骨骼较多采用IMU或足底压力数据来进行模式分类，这些信号在用于识别运动意图时有较好的效果，除此之外还有使用EMG信号和EEG信号来判断运意图，但都有一定的局限性，如个体差异、穿戴复杂等，甚至对于SCI患者，其下肢肌肉可能不存在EMG信号。</p>
<p>当意图识别完成后，上层控制器会根据任务目标生成相应的期望轨迹，这些轨迹往往是根据任务预先定义好的。由于人的步态运动有着支撑、摆动不同的阶段，每个阶段都有不同的动力学模型，因此上层控制器会经过有限状态机来判断当前的步态状态，然后在根据步态状态和任务需求来生成轨迹。底层控制器根据随设定的轨迹进行闭环控制，大部分采用PID，有时也会加入迭代学习来提高跟踪精度。</p>
<img src="/2022/06/01/2-Exoskeleton/%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/1606960068092.png" class title="|center">
<p>辅助型外骨骼最大的挑战是保证人机系统的平衡，可以说现有的外骨骼系统基本没有做到完全意义上的平衡控制，像Ekso、ReWalk这样的商业外骨骼也都是搭配了拐杖进行辅助。MindWalker通过类似ZMP的方法来防止跌倒，但依然没有实现完全的自平衡。自平衡问题的难点来自于两部分：一是外骨骼系统欠驱动特性，人的每条腿有6个自由度，部分冗余的自由度提高了人类运动时的稳定性，但大部分外骨骼为了简化设计都选择忽略部分自由度，这种简化设计造成系统的欠驱动；另一方面，机器人领域中为实现双足机器人的步态运动需要对系统进行精确建模，但在外骨骼领域中现有的技术难以实现对人机系统参数的精确测量。</p>
<h2 id="康复外骨骼"><a href="#康复外骨骼" class="headerlink" title="康复外骨骼"></a>康复外骨骼</h2><p>康复外骨骼是用来帮助恢复穿戴者受损伤的能力，使穿戴者能最终能够不借助外骨骼完成基本的日常活动。对于脊髓损伤患者，其运动能力的丧失一般是由于神经回路的损伤，而脑卒中患者一般是由于部分脑区受到损伤。不同于人体的骨骼和肌肉，人的神经损伤是永久性的，一旦受损就没有复原的可能。但循证医学发现，在一些连接通路断了之后，通过大量的、重复的、高强度的训练，能够重新构建出新的连接通路，甚至是重新构建一些脑区的连接，这叫神经体统的可塑性<code>Neuroplasticity</code>。</p>
<img src="/2022/06/01/2-Exoskeleton/%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/1606961554639.png" class title="Alt text">
<p>为了重建出新的连接来替代原来损伤的通路，需要进行大量的、重复的、高强度的神经康复训练<code>Neurorehabitation</code>。这样的康复训练往往需要多个理疗师来协助患者进行运动，康复的效果很大程度上取决于理疗师辅助的力量，对理疗师的体力有很高的要求。在中国，每年新增脑卒中患者200万，而现有的康复理疗师数量远远不能满足需要，所以我国的脑卒中致死率和致残率都远远高于美国和欧洲。因此使用康复外骨骼代替理疗师对患者进行康复训练成为了很大的需求。</p>
<img src="/2022/06/01/2-Exoskeleton/%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/120201203_102740.gif" class title="Alt text">
<p>在康复外骨骼的设计中，尺寸重量便携性一般不作考虑，大部分康复外骨骼系统都是固定在跑步机上，并在医生监督下使用。因为和辅助型外骨骼一样没有很好的平衡控制策略，因此在躯干处会连接一些支撑结构以承担体重。康复外骨骼所面对的是运动能力较弱或有有障碍的患者，其具有一定的自主运动能力，因此辅助型外骨骼中的位置控制策略不再适用。实际上，康复外骨骼一大核心问题就是辅助的柔顺性，所谓的柔顺是指人机之间交互力应当是平稳连续且舒适的，而不是剧烈变化或大到难以承受。有两种方法增加柔顺，在人机之间增加弹簧，或是通过控制算法来模拟一种柔顺特性。例如当患者穿戴外骨骼进行步态运动时，控制器预先定义好一条关节轨迹，当患者的运动轨迹与设置轨迹完全重合时，外骨骼不提供辅助，而当患者的运动轨迹与预定轨迹偏离时，外骨骼提供辅助，偏离位置越大辅助力也越大，形式上如同在关节上施加了一个虚拟的弹簧，这样方法叫做阻抗控制。</p>
<img src="/2022/06/01/2-Exoskeleton/%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/1606962702446.png" class title="Alt text">
<p>在康复外骨骼中，辅助并不是目的，目的是康复，需要让患者尽最大努力去参与到康复训练中。单纯采用阻抗控制方法容易使患者陷入一种被动的运动中，患者不再积极主动的进行训练，而是对辅助产生依赖。为了提高康复效果，辅助策略一般需要进行在线调整，仅在患者需要的时候进行辅助，并且随着患者的恢复逐渐降低辅助水平，这种策略叫做Assisted as Need。一般是通过定义一些目标函数，结合简化的人机交互模型，在维持运动目标的前提下最大化人体输出，或是最小化外骨骼输出。</p>
<img src="/2022/06/01/2-Exoskeleton/%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/1606962724477.png" class title="Alt text">
<h2 id="增强型外骨骼"><a href="#增强型外骨骼" class="headerlink" title="增强型外骨骼"></a>增强型外骨骼</h2><img src="/2022/06/01/2-Exoskeleton/%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/1606962804430.png" class title="Alt text">
<p>以上讨论的两种外骨骼都是面向有运动功能障碍的患者，增强型外骨骼的用户为健康人，通过外骨骼来增强或放大穿戴者的一些能力。增强型外骨骼主要存在两个分支，或者说是两种研究思路。第一种外骨骼是面向任务型的，可以让穿戴者在搬运重物的时候感受到的重量只有实际重量的十分之一，帮助护士去搬运病人或者是帮助士兵搬运弹药。这样的外骨骼必须是全下肢的，且主体为刚性结构，这样外部的负重才能够通过通过外骨骼结构传导到地面上，从而减轻人的负担。另一种是面向用户的，外骨骼仅辅助人体本身，多数情况下仅在部分关节施加辅助，其效果相当于给人增加了额外的肌肉，穿戴者依然需要自己需完成特定的任务，但在辅助下会轻松很多，但外界作用力最终还是需要经过人体。这一类外骨骼以Harvard大学Conor研究组的柔性外骨骼最为典型，可以做到轻型、便携、舒适。</p>
<img src="/2022/06/01/2-Exoskeleton/%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/1606962871187.png" class title="Alt text">
<p>面向任务型的外骨骼有两款比较出名的设计，一个是美国的BLEEX，一个是日本的HAL。先来说一下伯克利下肢外骨骼，Kazerooni等人对BLEEX的定位是可移动负载搬运全下肢外骨骼，它将外骨骼上的负载重量通过外骨骼的机械结构传递到地面上，而让人感觉不到这些重量的存在，同时能够跟随人体运动。它的每条腿有4个驱动自由度，驱动方式为液压驱动，髋关节两个，膝关节和踝关节各一个，其余没有驱动的方向上均为被动自由度。</p>
<img src="/2022/06/01/2-Exoskeleton/%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/1606962901455.png" class title="Alt text">
<p>在控制上，BLEEX的研究人员提出了一种灵敏度放大控制的方法，这种方法能够在不测量人机交互力的情况下使外骨骼能够跟随人体的运动。考虑一个单自由度的情况，外骨骼的机械结构受到驱动器和人体共同作用，我们用一个控制框图来表示，其中r表示驱动器的输出力矩，d表示人体的作用力矩，G和S分别是相应对于单自由度关节角速度的传递函数。对于典型的控制系统，我们一般是要设计负反馈控制，使系统保持稳定或跟随特定目标，这时人体对于外骨骼的作用力对控制系统而言是外部扰动，是控制系统需要克服的对象。在负反馈闭环系统下人体作用力矩到关节速度的传递函数Snew相对原来的S变小，从外骨骼的角度看，外骨骼更不容易受到人的影响，但从人体的角度来看，外骨骼变得铁板一块，没办法被控制。对于负载搬运外骨骼而言，其设计目的是为了让外骨骼跟随人体运动，让人感受不到外骨骼的存在，因此灵敏度放大控制将负反馈变成了正反馈，控制系统不再抑制扰动，而是放大扰动，新的传递函数也因此变大，人体更够更轻易的影响外骨骼。</p>
<p>说到这，学控制的同学可能坐不住了，这样一个正反馈系统怎么能够保证系统的稳定性呢？的确，这样的控制系统的确是不稳定的，但对于一个人机交互系统而言，不仅有外骨骼的控制回路，还有人体的控制回路，虽然控制系统不稳定，但如果人体能够控制的住外骨骼，那整个人机交互系统就是稳定的。也就是说，系统的稳定性取决于人体的平衡能力，人的平衡能力越强，那就可以设计更加不稳定的控制器，使人承受更多的重量，因此Kazerooni改用尼采的名言来描述这种方法，那些不稳定的，都使我们更加强大。</p>
<blockquote>
<p><strong>That which does not stabilize, will only make us stronger.</strong></p>
</blockquote>
<img src="/2022/06/01/2-Exoskeleton/%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/1606963028047.png" class title="Alt text">
<p>但在实际系统中，外骨骼受到的扰动不仅来自穿戴者的运动意图，还有来自外界真正的干扰，比如说外骨骼被人踹了一脚。控制系统并不能分辨哪些扰动是人体的，哪些是外界的，因此一并进行了放大，因此穿戴者不仅需要去维持一个系统的稳定，还要去抵抗被放大了的外界扰动。天下没有免费的午餐，想要承担更多的重量，就必须花费更多的力气去维持系统稳定，甚至这些力气可能比减轻了的重量还多。在第二年他们又提出了混合控制的策略，在步态的摆动相采用灵敏度放大控制，支撑相采用角度控制。但在这种混合控制策略下，外骨骼的最高移动速度只有0.5m/s。</p>
<img src="/2022/06/01/2-Exoskeleton/%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/1606963089953.png" class title="Alt text">
<p>与BLEEX几乎处于同一时期的外骨骼HAL，却采用完全不一样的控制思路。HAL的研究人员考虑能否从人体的神经系统中直接获得控制外骨骼的信号，就像控制人自身的肌肉一样来控制外骨骼。控制系统通过采集相关肌肉的肌电信号，经过滤波处理后乘以一个系数作为期望力矩，这种方法被称为比例肌电控制。这种方法的另一个意义在于，来自人体神经系统的肌电信号具有超前运动的特性，因此弥补控制系统的延时。当然这种方法的问题也很多，实际采集的肌电信号包含巨大的噪声，因此很难做到精确控制。另外这种肌电反馈的机制，必须存在肌电信号，才能产生力矩输出，没有肌电信号就没有外骨骼辅助，而肌电信号又包含巨大噪声，所以在这种控制策略下外骨骼无法实现完美辅助。</p>
<img src="/2022/06/01/2-Exoskeleton/%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/1606963132997.png" class title="Alt text">
<p>这些全下肢的刚性外骨骼都有相同的特点，太过笨重，有的甚至达到了150Kg。这个世界物理法则使得越重的物体有越大的惯性，人们原本希望穿上外骨骼之后可以变身钢铁侠，但实际却变成了相扑运动员，完全丧失了原有的机动性。于是人们开始思考，这样的外骨骼有没有意义？外骨骼的研究向着单关节、轻型便携化的方向发展，并且以代谢耗能作为终极指标。由于生物力学表明在步态运动中踝关节有着最大的力矩输出与能量输出，因此大部分单关节外骨骼都集中在踝关节辅助上，但驱动方式各有不同，MIT采用SEA，密西根采用气动人工肌肉，CMU采用刚性框架加绳驱动，哈佛采用绳索驱动的完全柔性外骨骼。但无论是怎样的外骨骼，其最终只有一个目标 - 降低代谢耗能，此后10年一直到现在，增强型外骨骼的核心研究课题就是如施加辅助才能够使代谢耗能下降。</p>
<img src="/2022/06/01/2-Exoskeleton/%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/1606963183136.png" class title="Alt text">
<p>最早在2007年，弗吉尼亚大学的Norris、密歇根大学的Ferris首先尝试了外骨骼辅助下代谢耗能的变化，之后13年根特大学的Philippe Malcolm第一次实现了外骨骼辅助下的代谢耗能下降，进一步CMU的Juanjuan Zhang与哈佛大学的Ding Ye用代谢耗能作为目标函数来优化固定步态运动下的辅助模式，也就是人在环中优化；到19年哈佛大学Conor Walsh研究组成功的在不同的运动中使外骨骼辅助降低人体的代谢耗能。</p>
<img src="/2022/06/01/2-Exoskeleton/%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/1606964062826.png" class title="Alt text">
<p>除了主动施加合适的辅助来降低代谢消耗，一些脑洞清奇的研究人员考虑能不能设计一种外骨骼，从人体本身吸收能量，再反过来降低人体的代谢耗能。这种有点像永动机的想法背后，体现的是对人体运动消耗能量的思考，为什么轮子朝前滚的时候基本不需要消耗能量，而人两条腿朝前走的时候就需要消耗能量呢？研究人员提出不同模型去描述双足生物的行走过程，典型的有倒立摆模型和质点弹簧模型，这些模型解释了人体行走时能量消耗的原因。Collins分析了行走过程中肌肉收缩的机制，并在此基础上设计了只有弹簧和棘轮组成的完全被动的外骨骼，并使穿戴者的代谢耗能下降了7%。这项研究发表在Nature上是因为其证明了人体不是一个完全优化结构，至少在特定的运动下能够通过一些被动原件使人体的结构得到优化。但对于外骨骼领域而言，这样纯机械结构的被动外骨骼有着主动驱动式外骨骼无法比拟的可靠性。</p>
<p>经过几十年的发展，外骨骼技术的确取得了长足的进步，尤其是康复外骨骼已经展现的巨大的应用价值。但增强型外骨骼的道路依旧漫长，现有技术对于代谢耗能的下降仍不足以产生具有变革性的应用与产品。增强型外骨骼领域还需要更加深入的研究人机交互方法、人机协调控制方法，除了已展现的对力量和耐力的增强外，还需探讨如何通过外骨骼提高人体的机动性、敏捷性、平衡性，考虑外骨骼对于复杂环境的鲁棒性、对于穿戴者个体差异的适应性，这样才能诞生出真正有应用价值和社会意义的产品。最后希望外骨骼的研究者能够更多的去思考人道主义精神，减少文明之间碰撞与冲突的可能，用知识和技术去减少人类社会的苦难，增强人类探索未知世界的能力。愿我们的征途都是星辰大海。</p>
<hr>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>Lee H, Ferguson P W, Rosen J. Lower Limb Exoskeleton Systems—Overview[M]//Wearable Robotics. Academic Press, 2020: 207-229.</li>
<li>Esquenazi A, Talaty M, Packel A, et al. The ReWalk powered exoskeleton to restore ambulatory function to individuals with thoracic-level motor-complete spinal cord injury[J]. American journal of physical medicine &amp; rehabilitation, 2012, 91(11): 911-921.</li>
<li>Wang S, Wang L, Meijneke C, et al. Design and control of the MINDWALKER exoskeleton[J]. IEEE transactions on neural systems and rehabilitation engineering, 2014, 23(2): 277-286.</li>
<li>Cramer S C, Sur M, Dobkin B H, et al. Harnessing neuroplasticity for clinical applications[J]. Brain, 2011, 134(6): 1591-1609.</li>
<li>Emken J L, Bobrow J E, Reinkensmeyer D J. Robotic movement training as an optimization problem: designing a controller that assists only as needed[C]//9th International Conference on Rehabilitation Robotics, 2005. ICORR 2005. IEEE, 2005: 307-312.</li>
<li>Zoss A, Kazerooni H, Chu A. On the mechanical design of the Berkeley Lower Extremity Exoskeleton (BLEEX)[C]//2005 IEEE/RSJ international conference on intelligent robots and systems. IEEE, 2005: 3465-3472.</li>
<li>Kazerooni H, Racine J L, Huang L, et al. On the control of the berkeley lower extremity exoskeleton (BLEEX)[C]//Proceedings of the 2005 IEEE international conference on robotics and automation. IEEE, 2005: 4353-4360.</li>
<li>Kazerooni H, Steger R, Huang L. Hybrid control of the Berkeley lower extremity exoskeleton (BLEEX)[J]. The International Journal of Robotics Research, 2006, 25(5-6): 561-573.</li>
<li>Kawamoto H, Lee S, Kanbe S, et al. Power assist method for HAL-3 using EMG-based feedback controller[C]//SMC’03 Conference Proceedings. 2003 IEEE International Conference on Systems, Man and Cybernetics. Conference Theme-System Security and Assurance (Cat. No. 03CH37483). IEEE, 2003, 2: 1648-1653.</li>
<li>Mooney L M, Rouse E J, Herr H M. Autonomous exoskeleton reduces metabolic cost of human walking[J]. Journal of neuroengineering and rehabilitation, 2014, 11(1): 151.</li>
<li>Witte K A, Zhang J, Jackson R W, et al. Design of two lightweight, high-bandwidth torque-controlled ankle exoskeletons[C]//2015 IEEE International Conference on Robotics and Automation (ICRA). IEEE, 2015: 1223-1228.</li>
<li>Bae J, Siviy C, Rouleau M, et al. A lightweight and efficient portable soft exosuit for paretic ankle assistance in walking after stroke[C]//2018 IEEE International Conference on Robotics and Automation (ICRA). IEEE, 2018: 2820-2827.</li>
<li>Zhang J, Fiers P, Witte K A, et al. Human-in-the-loop optimization of exoskeleton assistance during walking[J]. Science, 2017, 356(6344): 1280-1284.</li>
<li>Ding Y, Kim M, Kuindersma S, et al. Human-in-the-loop optimization of hip assistance with a soft exosuit during walking[J]. Science Robotics, 2018, 3(15): eaar5438.</li>
<li>Kim J, Lee G, Heimgartner R, et al. Reducing the metabolic rate of walking and running with a versatile, portable exosuit[J]. Science, 2019, 365(6454): 668-672.</li>
<li>Collins S H, Wiggin M B, Sawicki G S. Reducing the energy cost of human walking using an unpowered exoskeleton[J]. Nature, 2015, 522(7555): 212-215.</li>
</ol>
]]></content>
      <categories>
        <category>exoskeleton</category>
      </categories>
      <tags>
        <tag>外骨骼系统</tag>
      </tags>
  </entry>
  <entry>
    <title>CPET - 心肺运动实验</title>
    <url>/2021/12/02/3-Biomechanics/CPET-%E5%BF%83%E8%82%BA%E8%BF%90%E5%8A%A8%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<img src="/2021/12/02/3-Biomechanics/CPET-%E5%BF%83%E8%82%BA%E8%BF%90%E5%8A%A8%E5%AE%9E%E9%AA%8C/1.png" class>
<p>心肺运动试验(Cardiopulmonary Exercise Testing, CPET)是指在特定的运动负荷下，通过手机受试者呼出的气体并加以分析，检测机体在运动状态下的各项指标，并同步心电导联，综合评价心肺等器官系统的整体功能和储备能力，与常规肺功能和一般心脏负荷试验不同。</p>
<span id="more"></span>
<img src="/2021/12/02/3-Biomechanics/CPET-%E5%BF%83%E8%82%BA%E8%BF%90%E5%8A%A8%E5%AE%9E%E9%AA%8C/2.png" class>
<p>CPET主要是通过运动激发受试者增加氧气吸入与二氧化碳排出，增加肺通气。肺与血液氧气、二氧化碳交换称为<strong>外呼吸</strong>，氧气与二氧化碳通过血液转运，毛细血管与肌肉组织进行氧气与二氧化碳交换称为<strong>内呼吸</strong>，人体运动时的生理学反应就是表现在<strong>外呼吸与内呼吸的耦联过程</strong>。</p>
<img src="/2021/12/02/3-Biomechanics/CPET-%E5%BF%83%E8%82%BA%E8%BF%90%E5%8A%A8%E5%AE%9E%E9%AA%8C/3.png" class>
<h3 id="心肺运动试验的应用"><a href="#心肺运动试验的应用" class="headerlink" title="心肺运动试验的应用"></a>心肺运动试验的应用</h3><ol>
<li>早期/早早期诊断：心肌缺血；</li>
<li>指导运动处方的制定一一心血管疾病和呼吸系统疾病；确定运动强度；</li>
<li>客观定量评价治疗效果；</li>
<li>诊断与鉴别诊断：如区分心源性、肺源性呼吸困难;</li>
<li>疾病功能受限严重程度的客观定量分级：如心衰、COPD；</li>
<li>冠心病、心衰、COPD等死亡/存活预后的预测</li>
<li>心衰严重程度和心䏏移植术前评估</li>
<li>麻醉手术危险性评估</li>
</ol>
<h3 id="CPET测试流程"><a href="#CPET测试流程" class="headerlink" title="CPET测试流程"></a>CPET测试流程</h3><ul>
<li>静息：保持静息状态1分钟以上，测定患者静息时的参数，如静息心率、静息血压、基础代谢等</li>
<li>空蹬：热身阶段，1分钟以上，功率自行车不加载功率或保持较低的功率</li>
<li>负荷递增：测试阶段，蹬车速度不变，运动功率逐渐增加，尽可能接近受试者的体能极限，试验时间维持在10分钟以内</li>
<li>恢复：无负荷运动1-2分钟，避免剧烈运动突然停止出现的血压骤降、头痛、心率失常等</li>
</ul>
<img src="/2021/12/02/3-Biomechanics/CPET-%E5%BF%83%E8%82%BA%E8%BF%90%E5%8A%A8%E5%AE%9E%E9%AA%8C/4.png" class title="Untitled">
<h3 id="CPET试验有效指标"><a href="#CPET试验有效指标" class="headerlink" title="CPET试验有效指标"></a>CPET试验有效指标</h3><ul>
<li>HR &gt; 180</li>
<li>呼吸商 RQ &gt; 1.15</li>
<li>随着运动负荷的增加，VO2不在增加或者稍有下降</li>
<li>受试者主管感觉已经精疲力竭，虽经反复鼓励仍不能维持既定速率</li>
</ul>
<h3 id="CPET主要参数指标-1"><a href="#CPET主要参数指标-1" class="headerlink" title="CPET主要参数指标 - 1"></a>CPET主要参数指标 - 1</h3><ul>
<li><strong>反映运动耐量以及心功能的指标</strong>：<strong>摄氧量 $VO_{2\ max}$</strong>、<strong>无氧阈 AT</strong>、<strong>最大氧脉搏</strong>、摄氧量等</li>
<li><strong>反映通气功能的指标</strong>：呼吸储备、通气量、潮气量、呼吸频率等</li>
<li><strong>反映气体交换的指标</strong>：潮气末氧及二氧化碳分压、氧通气当量、二氧化碳通气当<br>量、死腔和潮气量的关系等</li>
<li><strong>反映骨骼肌功能的指标</strong>：摄氧量、无氧阈、做功效率</li>
<li><strong>其他指标</strong>：血压反应性 心率反应性 心电图反应</li>
</ul>
<h3 id="CPET主要参数指标-2"><a href="#CPET主要参数指标-2" class="headerlink" title="CPET主要参数指标 - 2"></a>CPET主要参数指标 - 2</h3><ul>
<li><strong>最大摄氧量 $VO_{2\ max}$</strong><ul>
<li>指运动中每分钟能够摄入人体内并被身体利用的最大摄氧量，通常用绝对值$L/min$和相对值$ml/min\cdot Kg$表示</li>
<li>在负荷递增的运动过程中，某一时刻$VO_2$不再随着负荷和心率的增加而增加，出现了一个平台，这就叫做$VO_{2\ max}$，它表示机体利用氧的最大上限，同时反应机体的气体运输系统(肺、心血管、血红蛋白)以及肌肉细胞的有氧代谢是否正常。</li>
<li>女性 $27-29 ml/min\cdot Kg$，男性 $30-35 ml/min\cdot Kg$，马拉松运动员 $&gt;40 ml/min\cdot Kg$</li>
</ul>
</li>
<li><strong>无氧域值</strong> (Anaerobic Threshold, AT)<ul>
<li>在负荷递增的运动过程中，机体内的供能方式由有氧代谢像无氧代谢过渡的临界点，此点时体内乳酸的形成率和从血液中的清除率达到动态的平衡</li>
<li>FOX定义：只有当最大吸氧量的百分利用率达到一个临界点时，身体中才开始聚集乳酸，这个临界点称为无氧域。因此一般用在AT点时$VO_2$占$VO_{2\ max}$的百分比来表示AT值</li>
<li>AT值表示体力活动和心肺系统能够为肌肉提供足以维持有氧代谢摄氧量的最高水平，在相关文献中，AT被列为人体的第五大生命体征（体温、脉搏、呼吸、血压），反应一个人的生活质量，可以用于治疗前后的功能评价以及锻炼效果与运动耐力的评价</li>
<li>正常人  $&gt;40\%\cdot VO_{2\ max}$</li>
</ul>
</li>
<li><strong>氧脉搏</strong>   $O_{2\ pluse}$<ul>
<li>非直接测量参数， $O_{2\ pluse} = VO_2\ /\ {HR}$</li>
<li>$O_{2\ pluse}$主要反应心脏每搏的输出氧的能力，是评价循环/氧气转运有效性的指标，是心脏疾病限制运动的关键参数</li>
<li>运动早期心脏主要是通过心搏量（SV）的增加使VO2增加，运动后期主要靠心率（HR）的增加，来使VO2增加，当心功能不全时，心搏量不能随着运动负荷的增加而增加，心脏只有通过HR的增加来满足运动着的肌体对氧的需求，HR增大，VO2/HR就减小，反应了心脏的储备功能降低。氧脉搏降低也可见于贫血、高碳氧血红蛋白或严重的动脉低氧血症等动脉血氧含量减少的病症。</li>
</ul>
</li>
</ul>
<h3 id="CPET九宫图浅读"><a href="#CPET九宫图浅读" class="headerlink" title="CPET九宫图浅读"></a>CPET九宫图浅读</h3><img src="/2021/12/02/3-Biomechanics/CPET-%E5%BF%83%E8%82%BA%E8%BF%90%E5%8A%A8%E5%AE%9E%E9%AA%8C/5.png" class title="Untitled">
<h3 id="图-1-VO-2-与-VCO-2"><a href="#图-1-VO-2-与-VCO-2" class="headerlink" title="图 1 - $VO_2$ 与 $VCO_2$"></a>图 1 - $VO_2$ 与 $VCO_2$</h3><p>开始运动时人体的供能方式主要以有氧代谢为主，$VCO_2$接近并略低于$VO_2$，随着运动强度逐渐增加，人体运动的供能向无氧代谢转变，$VCO_2$迅速增加并超过$VO_2$，极限时的$VO_2$为最大摄氧量 $VO_{2\ max}$。**</p>
<ul>
<li>$VO_2$曲线存在两段斜率：热身阶段，功率递增阶段</li>
<li>$VCO_2$曲线存在三段斜率：热身阶段，AT点前，AT点后</li>
</ul>
<img src="/2021/12/02/3-Biomechanics/CPET-%E5%BF%83%E8%82%BA%E8%BF%90%E5%8A%A8%E5%AE%9E%E9%AA%8C/6.png" class title="Untitled">
<h3 id="图-2-HR-与-O-2-pluse"><a href="#图-2-HR-与-O-2-pluse" class="headerlink" title="图 2 - HR 与 $O_{2\ pluse}$"></a>图 2 - HR 与 $O_{2\ pluse}$</h3><p>在负荷递增的运动早期，人体主要通过增加每搏量来增加摄氧量，在运动后期主要通过增加心率的来增加摄氧量；对于心功能不全的患者，其每搏量是不会随运动负荷而增加的</p>
<img src="/2021/12/02/3-Biomechanics/CPET-%E5%BF%83%E8%82%BA%E8%BF%90%E5%8A%A8%E5%AE%9E%E9%AA%8C/7.png" class>
<h3 id="图-3-V-slope曲线图"><a href="#图-3-V-slope曲线图" class="headerlink" title="图 3 - V-slope曲线图"></a>图 3 - V-slope曲线图</h3><p>V-slope曲线图是判断AT点最经典的方法。<strong>AT点</strong>在负荷递增的运动过程中，机体内的供能方式由有氧代谢像无氧代谢过渡的临界点，此点时体内乳酸的形成率和从血液中的清除率达到动态的平衡。对于心功能低下的受试者，机体在运动早期就启动 无氧代谢，致使无氧阈降低，因此AT可用来反映 心功能。</p>
<p>V-slope图横坐标是VO2，纵坐标是VCO2。在有氧运动中，二氧化碳排出量等于摄氧量，因此曲线开始时的斜率为1左右。在AT点之后，人体进行无氧呼吸，二氧化碳排出量明显大于摄氧量，曲线斜率发生改变。通过绘制两条直线的交点，即可得到AT点。</p>
<img src="/2021/12/02/3-Biomechanics/CPET-%E5%BF%83%E8%82%BA%E8%BF%90%E5%8A%A8%E5%AE%9E%E9%AA%8C/8.png" class>
<h3 id="图-4-氧当量与二氧化碳通气当量"><a href="#图-4-氧当量与二氧化碳通气当量" class="headerlink" title="图 4 - 氧当量与二氧化碳通气当量"></a>图 4 - 氧当量与二氧化碳通气当量</h3><p>每吸入1L的O2或排出1L的CO2所需要的通气量，即VE/O2和VE/CO2，该值越高表明通气效率越低，是反应气体交换效率、通气与血流灌注配比的重要指标。</p>
<p>通气当量图也可以用来确定AT点，位置为：VE/O2开始增加，而VE/CO2没有响应的增加，后者增加为呼吸代偿（RCP点）</p>
<img src="/2021/12/02/3-Biomechanics/CPET-%E5%BF%83%E8%82%BA%E8%BF%90%E5%8A%A8%E5%AE%9E%E9%AA%8C/9.png" class>
<h3 id="图-5-分钟通气量"><a href="#图-5-分钟通气量" class="headerlink" title="图 5 - 分钟通气量"></a>图 5 - 分钟通气量</h3><p>正常情况下，随着运动量的增加，通气量逐渐 升高，如果出现通气量平台或者下降，提示受 试者存在呼吸受限；辅助判断通气功能障碍 (VE/MVV正常值: $\leq 80 \%$)。</p>
<p>VE曲线存在四端斜率：</p>
<ul>
<li>热身阶段</li>
<li>功率递增开始，氧气需求逐渐增加，通气量也逐渐增加</li>
<li>AT点后，CO2增加，通气量进一步提升以增加CO2的排出</li>
<li>呼吸代偿点（RCP）后PH下降，提问上升，进一步刺激呼吸</li>
</ul>
<img src="/2021/12/02/3-Biomechanics/CPET-%E5%BF%83%E8%82%BA%E8%BF%90%E5%8A%A8%E5%AE%9E%E9%AA%8C/10.png" class title="Untitled">
<h3 id="图-6-VE-VCO2斜率"><a href="#图-6-VE-VCO2斜率" class="headerlink" title="图 6 - VE/VCO2斜率"></a>图 6 - VE/VCO2斜率</h3><p>反映通气效率，通气与血流灌注配比的重要指标，异常增高提示无效腔通气增加，常见于肺血管病、 肺动脉高压、慢性心衰等。</p>
<ul>
<li>正常值：&lt; 30</li>
<li>可疑异常：30 ~ 34</li>
<li>异常：&gt; 34</li>
<li>老年人可轻度增加</li>
</ul>
<img src="/2021/12/02/3-Biomechanics/CPET-%E5%BF%83%E8%82%BA%E8%BF%90%E5%8A%A8%E5%AE%9E%E9%AA%8C/11.png" class title="Untitled">
<h3 id="图-7-PETO2和PETCO2"><a href="#图-7-PETO2和PETCO2" class="headerlink" title="图 7 - PETO2和PETCO2"></a>图 7 - PETO2和PETCO2</h3><p>潮气末氧分压PETO2和潮气末二氧化碳分压PETCO2，是气体交换指标。也可以用于鉴别无氧阈AT和呼吸代偿点RCP的判断：PETO2开始增加，而PETCO2处于平段尚末降低，后者降低时为RCP点。</p>
<img src="/2021/12/02/3-Biomechanics/CPET-%E5%BF%83%E8%82%BA%E8%BF%90%E5%8A%A8%E5%AE%9E%E9%AA%8C/12.png" class title="Untitled">
<h3 id="图-8-呼吸储备BR与呼吸交换律RER"><a href="#图-8-呼吸储备BR与呼吸交换律RER" class="headerlink" title="图 8 - 呼吸储备BR与呼吸交换律RER"></a>图 8 - 呼吸储备BR与呼吸交换律RER</h3><p>反映机体最大运动时的呯吸储备能力，即通气需求与通气能力之间的关系</p>
<script type="math/tex; mode=display">
\mathrm{BR=\mid MVV- VE_{max} \mid}\ or\ \mathrm{BR=\mid MVV- VE_{max} \mid/\ MVV \%}</script><p>正常情况下，随着运动量增加呼吸储备BR逐渐下降 (正常值：20%-40%)，BR &gt; 40% 提示用力不够或者运动不受限于呼吸系统； BR &lt; 20%提示通气功能受限，往往伴MVV下降。<br><strong>RER=VCO<em>2</em>/VO2</strong> ，又称呯吸交换率，用于判断运动是否尽力。</p>
<img src="/2021/12/02/3-Biomechanics/CPET-%E5%BF%83%E8%82%BA%E8%BF%90%E5%8A%A8%E5%AE%9E%E9%AA%8C/13.png" class>
<h3 id="图-9-呼吸储备BR与呼吸交换律RER"><a href="#图-9-呼吸储备BR与呼吸交换律RER" class="headerlink" title="图 9 - 呼吸储备BR与呼吸交换律RER"></a>图 9 - 呼吸储备BR与呼吸交换律RER</h3><p>反映运动过程中有无通气功能障碍。正常情况下，运动中VT &lt;80\% IC，也不超过MVV 若VT超过80% IC，提示存在限制性通气功能障碍 若VE超过80% MVV，提示存在阻塞性通气功能障碍 两者同时存在，则提示存在混合性通气功能障碍。</p>
<img src="/2021/12/02/3-Biomechanics/CPET-%E5%BF%83%E8%82%BA%E8%BF%90%E5%8A%A8%E5%AE%9E%E9%AA%8C/14.png" class>
]]></content>
      <categories>
        <category>biomechanics</category>
      </categories>
      <tags>
        <tag>生物力学</tag>
        <tag>心肺运动实验</tag>
      </tags>
  </entry>
  <entry>
    <title>Electromyography - 原理与应用基础</title>
    <url>/2021/12/01/3-Biomechanics/%E8%82%8C%E7%94%B5%E4%BF%A1%E5%8F%B7-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<img src="/2021/12/01/3-Biomechanics/%E8%82%8C%E7%94%B5%E4%BF%A1%E5%8F%B7-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/image-20211202160304804.png" class title="image-20211202160304804">
<span id="more"></span>
<h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1 - 基本概念"></a>1 - 基本概念</h2><blockquote>
<p>Electromyography (EMG) is an experimental technique concerned with the development, recording and analysis of myoelectric signals. Myoelectric signals are formed by physiological variations in the state of muscle fiber membranes. (Basmajian, J.V. &amp; De Luca, C.J., 1985).</p>
</blockquote>
<p>肌电信号(Electromyography, EMG)，是指测量引发肌肉收缩的电信号，并反应肌肉的收缩程度，在医疗、康复、运动科学等诸多应用科学领域中广泛使用。在外骨骼领域中，肌电信号是评估外骨骼辅助有效性的重要指标之一。一般来说，我们可以从肌电信号中获得如下信息：</p>
<ul>
<li><strong>时机</strong> - 肌肉何时被激活</li>
<li><strong>力量</strong> - 肌肉收缩有多强烈</li>
<li><strong>疲劳</strong> - 肌肉能否调动它的全部力量</li>
</ul>
<p>在<strong>生物力学</strong>中，表面肌电信号应用更为广泛。其采用非侵入式的测量方式，电信号通过粘贴在皮肤上的电极进行获取。与之相对的侵入式肌电信号，需要将一根探针直接插入相应的肌肉。表面肌电信号非侵入、不会限制受试者的运动，但其信号质量一般低于侵入式测量。</p>
<hr>
<h2 id="2-测量原理"><a href="#2-测量原理" class="headerlink" title="2 - 测量原理"></a>2 - 测量原理</h2><p>如上所述，表面肌电传感器通过测量<strong>皮肤表面的电位变化</strong>来感知肌肉收缩，这种电位变化被称为动作电位(<a href="https://www.biomechanist.net/muscle-contraction/">action potential</a>，AP)。来自神经细胞的肌肉激励信号，通过运动终板传导至肌肉的退极化区(resulting depolarization zone, 约为1-3mm²)。在初始激励之后，运动单元的动作电位(MUAP)会沿肌纤维以2-6米/秒的速度传递，动作电位的传递过程类似于带有负电荷的离子沿肌纤维的方向移动(如下动图所示)。如果现在将一对电极沿平行肌纤维的方向放置于待测肌肉上方(如下右图)，则动作电位先后经过AB两个电极时，电极会测量到一个完整周期的类正弦信号。</p>
<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img src="/2021/12/01/3-Biomechanics/%E8%82%8C%E7%94%B5%E4%BF%A1%E5%8F%B7-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/action-potential-crash-course.gif" alt="action-potential-crash-course.gif" style="zoom:50%;"></div><div class="group-picture-column" style="width: 50%;"><img src="/2021/12/01/3-Biomechanics/%E8%82%8C%E7%94%B5%E4%BF%A1%E5%8F%B7-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/Untitled.png" alt="Untitled" style="zoom: 100%;"></div></div></div></div>
<!-- <img src="肌电信号-原理与应用基础/action-potential-crash-course.gif" alt="action-potential-crash-course.gif" style="zoom: 88%;" /><img src="肌电信号-原理与应用基础/Untitled.png" alt="Untitled" style="zoom: 31%;" /> -->
<p>一般情况下，多个运动单元会被同时激活，动作电位同时在多个肌纤维上传递，而电极测量的信号是由多个肌纤维上的动作电位合成的结果。一个典型的电极测量的原始肌电信号如下图蓝色波形所示，其由大量的动作电平合成而得；信号的幅值越高说明同一时叠加的动作电位越多，激活的肌纤维数量也越多；由于每一个动作电位产生的电压信号积分为零，因此合成的肌电信号平均值(一段时间的积分)也基本为零。表面肌电信号非常微弱，幅值在µV到低mV范围内，因此一般会使用1000到10000倍的放大器放大测量信号。根据相关文献，肌电图信号的能量分布基本上在0 ~ 500 Hz的频率范围内，主要成分在50 ~ 150 Hz的范围内。</p>
<img src="/2021/12/01/3-Biomechanics/%E8%82%8C%E7%94%B5%E4%BF%A1%E5%8F%B7-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/image-20211202160503752.png" class title="image-20211202160503752">
<hr>
<h2 id="3-表面肌电信号的干扰与降噪"><a href="#3-表面肌电信号的干扰与降噪" class="headerlink" title="3 - 表面肌电信号的干扰与降噪"></a>3 - 表面肌电信号的干扰与降噪</h2><p>表面电极有诸多优点，但也非常容易收到各种噪声的干扰。下面讨论一些常见的干扰类型，以及可以采用的预防和降噪方法。</p>
<h3 id="a-生理噪声-physiological-noise"><a href="#a-生理噪声-physiological-noise" class="headerlink" title="a-生理噪声(physiological noise)"></a>a-生理噪声(physiological noise)</h3><p>生理噪音是指由身体内部生理活动所产生的，并可被表面电极接收到的电信号，例如<strong>心电信号</strong>和<strong>呼吸肌的收缩信号</strong>。对于这类干扰，可以将传感器放置远离干扰噪声源的地方并使用滤波方法来减少，但避免使用陷波滤波器。</p>
<h3 id="b-环境噪声-Ambient-Noise"><a href="#b-环境噪声-Ambient-Noise" class="headerlink" title="b-环境噪声(Ambient Noise)"></a>b-环境噪声(Ambient Noise)</h3><p>环境噪声包括<strong>电气工频干扰</strong>70-60Hz)和<strong>电缆伪影</strong>(cable artifacts，由线缆移动而导致的信号失真)。</p>
<p>电磁辐射在环境中几乎无处不在，但可以采用<strong>差动电极</strong>来减少这些干扰。表面肌电信号传感器由两个电极组成，它们沿着肌肉纤维以一定距离(通常为10mm)附着在皮肤上。两个电极都记录了基本噪声，也记录了具有延时的MUAPs(延时是因为电位沿着肌纤维扩散，从而首先到达第一个电极，然后到达第二个电极)。通过简单的差分计算消除环境噪声：</p>
<script type="math/tex; mode=display">V_{res}=(V_B+N_{env})-(V_A+N_{env})=V_B-V_A</script><p>对于电缆伪影，多数表面肌电传感器都会在测量电极后紧跟第一级放大器，从而传感器电缆的移动而产生的电缆伪迹减少到最小。</p>
<h3 id="c-基线噪声-Baseline-Noise"><a href="#c-基线噪声-Baseline-Noise" class="headerlink" title="c-基线噪声(Baseline Noise)"></a>c-基线噪声(Baseline Noise)</h3><p>基线噪声是肌电信号中最常见的噪声之一。它属于电化学噪声，由电极和皮肤中盐的离子交换所产生，当肌肉完全放松时所测量的信号主要就是基线噪声(以及生理噪声和环境噪声)。由于噪声发生在放大电路之前，所以基本无法被消除。基线噪声的大小与电极电阻的平方根成正比，因此可以通过增加电极的表面积来减少噪声，以及在使用肌电传感器前做好电极和皮肤的清洁工作。</p>
<h3 id="d-运动伪影-Movement-Artifacts"><a href="#d-运动伪影-Movement-Artifacts" class="headerlink" title="d-运动伪影(Movement Artifacts)"></a>d-运动伪影(Movement Artifacts)</h3><p>运动伪影也来自电极与皮肤之间的界面。一般来说，产生运动伪影的原因有两个：</p>
<ol>
<li>当肌肉收缩和放松时，肌肉的长度和横截面发生变化。这导致覆盖皮肤的拉伸和放松，进而导致皮肤电极界面的电化学平衡发生变化。</li>
<li>当肌肉产生一个力脉冲或从外部施加到身体上的力脉冲(例如脚跟撞击)，脉冲也会被转移到电极上。</li>
</ol>
<p>这两种情况都不可能完全消除干扰，只能通过对皮肤/电极进行良好的预处理和使用良好的过滤方法来缓解。</p>
<h3 id="e-肌肉串扰-Crosstalk-from-Other-Muscles"><a href="#e-肌肉串扰-Crosstalk-from-Other-Muscles" class="headerlink" title="e-肌肉串扰(Crosstalk from Other Muscles)"></a>e-肌肉串扰(<strong>Crosstalk from Other Muscles</strong>)</h3><p>当我们记录了表面肌电信号后，我们需要注意这个信号是否会收到其他肌肉的影响。如果需要确定某一个特定肌肉的激活情况，相对独立的肌肉能够被较为准确的测量(如胫骨前肌)，而位于肌群中的肌肉很难被准确测量(如位于股四头肌群中的股直肌)。即使小心翼翼地将电极放置在相应的肌肉上，信号仍然会被附近肌肉影响。通过选择两个差分电极之间相对较小的距离可以防止串扰，根据经验，两个电极之间的距离应不超过10mm。更多关于防止串扰的方法可以在其他文献中找到。</p>
<h3 id="f-脂肪组织-Fatty-Tissue"><a href="#f-脂肪组织-Fatty-Tissue" class="headerlink" title="f-脂肪组织(Fatty Tissue)"></a>f-脂肪组织(Fatty Tissue)</h3><p>一般来说，人体具有良好的导电性，但不同组织之间存在着很大的差异。其中脂肪组织起着决定性的作用，它类似于一个低通滤波器，过滤掉信号的高频部分。肌肉和电极之间的脂肪组织越多，过滤的作用就越强，当<strong>脂肪厚度大于40mm</strong>，肌电信号基本无法被检测到。这种特性也使得在不同受试者之间进行直接对比肌电信号的电压幅值比较非常困难，所以一般会根据肌肉的最大自主收缩(MVC)的对肌电信号进行归一化。</p>
<h3 id="g-皮肤和肌肉之间的相对运动-Relative-Movement-Between-Skin-and-Muscle"><a href="#g-皮肤和肌肉之间的相对运动-Relative-Movement-Between-Skin-and-Muscle" class="headerlink" title="g-皮肤和肌肉之间的相对运动(Relative Movement Between Skin and Muscle)"></a>g-皮肤和肌肉之间的相对运动(Relative Movement Between Skin and Muscle)</h3><p>当肌肉收缩时，它会在皮肤下面移动，贴在皮肤上的表面肌电传感器的测量区域也会发生变化。一方面，肌肉的动态收缩会导致信号来源(肌肉膜)和传感器之间的脂肪组织过滤器发生变化，从而影响信号的振幅和频谱；另一方面，它可能导致所测量的肌肉从传感器的视野中消失，而另一块不感兴趣的肌肉则成为了测量对象，进一步加重肌肉串扰的影响。</p>
<p>可以通过分析等距收缩(即没有长度变化的收缩)来避免运动带来的影响，这也是为什么等距收缩是研究最多的收缩类型。但在应用科学中，等距收缩对于肌肉运动的基本理解并不是那么重要，也很少发生在自然运动中。如何处理动态记录的数据以及这对数据解释的其他影响将在数据分析一节中解释。</p>
<p>肌电信号的质量取决于传感器的类型、放大器的质量、传感器的放置以及电极-皮肤的接触特性。如果您的实验室没有足够的预算来购买最新的表面肌电信号和放大器，您仍然可以改善后两点个方面。这些在准备阶段中发挥着核心作用，并对数据质量有巨大的影响。</p>
<hr>
<h2 id="4-肌电信号采集的准备工作"><a href="#4-肌电信号采集的准备工作" class="headerlink" title="4 - 肌电信号采集的准备工作"></a>4 - 肌电信号采集的准备工作</h2><h3 id="如何在皮肤上粘贴肌电传感器"><a href="#如何在皮肤上粘贴肌电传感器" class="headerlink" title="如何在皮肤上粘贴肌电传感器"></a>如何在皮肤上粘贴肌电传感器</h3><p>肌电电极应该尽可能的被<strong>粘贴在肌腹的中间</strong>。肌腹的信号幅值最大，信噪比更高，且更少的受到周围肌肉的串扰影响。每个肌电传感器应至少使用两个电极，通过差动电极将环境噪声影响降低到最小。电极应该<strong>沿着肌纤维的方向排列</strong>，使得动作电位先到达一个电极，再到达另一个电极。需要特别要注意肌肉纤维的排列和<strong>羽状角</strong>。表面肌电信号的幅值与电极间距离成正比，带宽与电极间距离成反比，因此两个电极之间的距离应该尽可能保持恒定以方便数据分析(如果不是由传感器给出的话)。</p>
<h3 id="如何清理皮肤"><a href="#如何清理皮肤" class="headerlink" title="如何清理皮肤"></a>如何清理皮肤</h3><p>表面肌电信号的质量很大程度上取决于皮肤和传感器之间的接触条件。清理皮肤的目的是尽可能减少皮肤的电阻，使表面肌电信号能够被准确地捕捉到(现代放大器通常设计为皮肤阻抗水平在5到50欧姆之间)。一般来说，在准备皮肤时要考虑两点：</p>
<ol>
<li><strong>剃除毛发</strong>。特别是受试者有大量出汗或需要分析高度动态的运动时，剃除毛发可以防止电极松动。出于卫生原因，请使用一次性剃须刀，使用后应立即丢弃。</li>
<li><strong>清洁皮肤</strong>。去除具有高抵抗力的死皮细胞，清洗皮肤上的污垢和汗水。大多数情况下，用浸过纯酒精的布轻轻擦拭皮肤就足够了。如果有更高的需求，可以用细砂纸去除表层的死皮细胞。可以通过万用表测量电极之间的电阻来检查皮肤清洁是否到位，下表可以作为一个粗略评估:</li>
</ol>
<img src="/2021/12/01/3-Biomechanics/%E8%82%8C%E7%94%B5%E4%BF%A1%E5%8F%B7-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/Untitled1.png" class title="Untitled">
<p>为了进一步了解肌电信号的质量，建议计算和检查信噪比(signal-to-noise ratio, SNR)：</p>
<script type="math/tex; mode=display">SNR=\frac{sEMG\ Amplitude}{Baseline \ Noise\ Amplitude}</script><img src="/2021/12/01/3-Biomechanics/%E8%82%8C%E7%94%B5%E4%BF%A1%E5%8F%B7-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/Untitled2.png" class title="Untitled">
<p>如果信噪比不理想，尝试检查传感器的粘贴或进一步清理皮肤；如果没问题，那就开始测量数据吧！</p>
<hr>
<h2 id="5-肌电信号的后处理"><a href="#5-肌电信号的后处理" class="headerlink" title="5 - 肌电信号的后处理"></a>5 - 肌电信号的后处理</h2><p>这里我们使用Matlab的信号分析工具箱Signal Analyzer，介绍肌电信号的后处理方法。实验数据是通过Delesys的无线肌电系统Trigo，并通过模拟量接口由dSPACE以5kHz的频率进行采集，测量了单个男性受试者以1.25m/s的速度在跑步机上行走时比目鱼肌、腓肠肌、胫骨前肌、股直肌、腘绳肌等8块的肌电信号，你可以在这里下载该实验的原始数据。</p>
<img src="/2021/12/01/3-Biomechanics/%E8%82%8C%E7%94%B5%E4%BF%A1%E5%8F%B7-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/Snipaste_2021-12-01_18-03-40.png" class title="Snipaste_2021-12-01_18-03-40.png">
<p>上图展示将数据加载进Signal Analyzer并进行显示，右侧为29s至30s(约一步)的比目鱼肌肌电信号。根据上面对于噪声干扰的分析，红色方框内的为基线噪声，绿色方框内的为运动伪影(因为这部分信号的频率和后面紫色框内的频率有显著差异)，紫色方框内为肌电的收缩信号。为了得到更有效的分析数据，挖掘肌电信号的信息，一般需要对原始肌电信号的后处理，主要涉及如下步骤：</p>
<img src="/2021/12/01/3-Biomechanics/%E8%82%8C%E7%94%B5%E4%BF%A1%E5%8F%B7-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/Untitled3.png" class title="Untitled">
<h3 id="高通滤波-High-Pass-Filter"><a href="#高通滤波-High-Pass-Filter" class="headerlink" title="高通滤波(High Pass Filter)"></a>高通滤波(High Pass Filter)</h3><p>对于大部分实验室而言，会使用数据采集卡或实时处理器，采集肌电系统的信号并和其他设备进行同步，并且大多数情况下会是模拟信号。不同设备间的电平基准可能存在不同，因此可能导致信号包含一定的直流偏置。如上所示的实验数据，其直流偏置约为<code>-0.003</code>。这部分的误差是由采集设备所造成的，因此并没有被归到上面的信号干扰中。直流偏置可以根据信号的平均值进行消除，也可以通过高通滤波器进行消除。这里采用Signal Analyzer的滤波功能，对原始数据先进行截止频率为20Hz的高通滤波。关于截止频率的选择，后面有更详细的解释。</p>
<img src="/2021/12/01/3-Biomechanics/%E8%82%8C%E7%94%B5%E4%BF%A1%E5%8F%B7-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/Untitled4.png" class title="Untitled">
<h3 id="整流矫正-Rectification"><a href="#整流矫正-Rectification" class="headerlink" title="整流矫正(Rectification)"></a>整流矫正(Rectification)</h3><p>由于肌电信号包含大量的噪声，所以在分析之前我们一般需要对数据进行平滑。但如上所述，原始肌电信号是双极性的，正负电压值的对称分布，若直接进行滑动均值滤波，会得到一条近乎直线的信号。所以为了提取有效信息，一般会对信号进行整流校正，也就是对每个数据点取绝对值。Signal Analyzer没有内置的信号整流功能，但可以通过Add Custom Function来添加，经过整流后的肌电信号如下图紫色曲线所示。</p>
<img src="/2021/12/01/3-Biomechanics/%E8%82%8C%E7%94%B5%E4%BF%A1%E5%8F%B7-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/Untitled5.png" class title="Untitled">
<h3 id="低通滤波-Low-Pass-Filter"><a href="#低通滤波-Low-Pass-Filter" class="headerlink" title="低通滤波(Low Pass Filter)"></a>低通滤波(Low Pass Filter)</h3><p>之后可以采用低通滤波对信号进行平滑，以提取信号的轮廓。在dSPACE中我们一般使用Butterworth低通滤波器，而这种形式滤波器在Signal Analyzer中没有集成，也需要自行定义(Signal Analyzer自带的低通滤波器非Butterworth滤波器)。论文中常用的低通截止频率有6Hz、10Hz、15Hz，阶数常为2阶或4阶。下面右图展示了3种截止频率下的滤波效果。</p>
<img src="/2021/12/01/3-Biomechanics/%E8%82%8C%E7%94%B5%E4%BF%A1%E5%8F%B7-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/Untitled6.png" class title="Untitled">
<h3 id="平滑-Smoothing"><a href="#平滑-Smoothing" class="headerlink" title="平滑(Smoothing)"></a>平滑(Smoothing)</h3><p>采用低通滤波会不可避免的向信号引入延迟，从而有可能导致对肌肉活跃度有错误的解读。比如上图中6Hz滤波的红色曲线，延时已经非常显著了。在后处理阶段，我们可以采用smooth(特指matlab函数)方法来平滑数据，而不进入延迟，但要注意这些方法无法在实时采集中使用。肌电信号常用的平滑方法是滑动均方根滤波：</p>
<script type="math/tex; mode=display">f_{r m s}=\sqrt{\frac{1}{T_{2}-T 1} \int_{T_{1}}^{T_{2}}[f(t)]^{2} \triangle t}</script><p>$T_2 - T_1$表示平滑的时间窗口大小，在运动科学研究中大约是20ms(快速运动)到500ms(缓慢或静态运动)。时间窗口越大，数据越平滑，但也越有可能误解肌电信号变化趋势。下图对比了均方根平滑和低通滤波的效果，可以看出均方根平滑能更准确反应肌电轮廓信息。</p>
<img src="/2021/12/01/3-Biomechanics/%E8%82%8C%E7%94%B5%E4%BF%A1%E5%8F%B7-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/Untitled7.png" class title="Untitled">
<p>上面所使用的均方根平滑也是一个自定义的函数，但Signal Analyzer也提供了多种其他的平滑方法，比如均值平滑、中值平滑、高斯平滑等，多数也有较好的平滑效果，例如窗口为0.1s的高斯平滑(如下所示)。</p>
<img src="/2021/12/01/3-Biomechanics/%E8%82%8C%E7%94%B5%E4%BF%A1%E5%8F%B7-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/Untitled8.png" class title="Untitled">
<hr>
<h2 id="6-功率谱分析"><a href="#6-功率谱分析" class="headerlink" title="6 - 功率谱分析"></a>6 - 功率谱分析</h2><p>在采集和处理数据时，我们需要时刻关注，信号是否反应真实的肌电。上面进行数据处理的过程中，我们基本采用经验和参考来进行滤波，而没有去关注信号的频率特性。本文第三部分部分讨论了诸多的干扰形式，我们也可以根据肌电信号和噪声的特性设计更合适的滤波器来处理数据，得到更真实的肌肉活动信息。</p>
<blockquote>
<p>除了用来设计滤波器外，频谱/功率谱分析还可以评估肌肉的疲劳程度，这将在下一部分予以介绍。</p>
</blockquote>
<img src="/2021/12/01/3-Biomechanics/%E8%82%8C%E7%94%B5%E4%BF%A1%E5%8F%B7-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/Untitled9.png" class title="Untitled">
<p>上图展示高通滤波后(去除直流偏置对于频谱的影响)肌电信号的功率谱，主要信号的频率分布在0-600Hz的范围内，这其中包含了肌电以及所有的噪声。频谱在20-250Hz频段内信号最为集中；在200-500Hz频段内有一个较宽的突起，反应一种稳定分布的信号(这很有可能来自肌电信号)；超过600Hz后分布一个比较稳定的白噪声，并带有几个小尖峰。</p>
<p>为了进一步确定肌电信号和频段，分离肌电信号和各种噪声，可以提取出步态摆动阶段到支撑前期的肌电信号，这段时间我们所研究的肌肉-比目鱼肌-基本处于完全放松状态，所测量的信号完全由各种噪声组成。下图展示了这些噪声的功率谱，其主要分布在低频段，在0-100Hz之间有较大的幅值，并随频率逐渐减少，同时也可以看出高频段的几个尖峰也都来自噪声。两个曲线所夹便是真实肌电信号的部分，分布在50Hz到600Hz之间。</p>
<blockquote>
<p>在这篇博客的<a href="https://www.biomechanist.net/electromyography-basics-of-practical-application/">参考博客</a>中，作者通过肌电传感器上内置惯性传感器的加速度数据来分析来自运动伪影噪声的频谱，其频段主要分布在20Hz到50Hz之间，和我们的结果相类似。</p>
</blockquote>
<img src="/2021/12/01/3-Biomechanics/%E8%82%8C%E7%94%B5%E4%BF%A1%E5%8F%B7-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/Untitled10.png" class title="Untitled">
<p>在频谱分析的基础上，我们可以设计带通滤波器对信号进行滤波，以去除噪声的影响。但注意到噪声和肌电信号在很大频率范围内的频谱是相互叠加的，因此基本不可能将两者完全分开，但我们也有理由相信滤除一些低频和高频的成分是有意义的。一些文献使用低频20Hz、高频500Hz的带通滤波，而且多数肌电传感中已经内置了这样的带通滤波电路(比如我们的Delesys)，但也有一些文献质疑这样会滤除太多的肌电成分。</p>
<p>为了增加对肌电信号和噪声特性的理解，让我们尝试更激进的滤波参数。但注意这一部分的内容并没有更多的文献支撑，仅作为一个开放性的讨论。下图展示使用低通150Hz、高通600Hz的带通滤波后的数据(绿色)，可以发现在肌肉放松阶段的噪声(基线噪声、运动伪影)有了显著的减少，而收缩阶段的肌电信号没有本质改变。</p>
<img src="/2021/12/01/3-Biomechanics/%E8%82%8C%E7%94%B5%E4%BF%A1%E5%8F%B7-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/Untitled11.png" class title="Untitled">
<p>对带通滤波后的信号进一步进行整流和平滑处理，可得到噪声更小、放松阶段信号更平稳的肌电数据，如下右图所示；但同样可以观察到收缩阶段信号峰值有明显衰减，表明一部分有效的肌电信号也被滤波器所滤除。</p>
<img src="/2021/12/01/3-Biomechanics/%E8%82%8C%E7%94%B5%E4%BF%A1%E5%8F%B7-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/Untitled12.png" class title="Untitled">
<hr>
<h2 id="7-数据分析"><a href="#7-数据分析" class="headerlink" title="7 - 数据分析"></a>7 - 数据分析</h2><p>正如本文开始所述，通过肌电信号可以得到关于肌肉的<strong>时机</strong>、<strong>力量</strong>和<strong>疲劳</strong>三种信息，它们分别对应肌电信号的时间(相位)、幅值和中值频率。</p>
<h3 id="肌肉的激活时间"><a href="#肌肉的激活时间" class="headerlink" title="肌肉的激活时间"></a>肌肉的激活时间</h3><p>一般来说，在分析肌肉的激活时间时，一般不关心肌肉的收缩类型(同心\偏心\等距)和收缩程度，而仅关注肌肉合适收缩和放松(开和关)。为了以一种标准化的方式确定肌肉何时被激活，会先采集一组肌肉放松状态时的信号，并确定背景噪声的的均值和方差；当肌电信号超过噪声均值两倍标准差(95%置信度)，并持续一定的时间(通常是10 - 50ms)，认为肌肉激活。这种方法也被称为双阈值方法，因为必须同时超过振幅阈值和时间阈值。</p>
<p>由于人体任何形式的运动都具有协调性变异性，即使在非常标准的运动中，不同周期的表面肌电信号也有非常显著的差异。因此，一般会通过多次重复来描述某一运动模式。为此每个周期被划分为固定数量的段(例如100)，每个段的数据点被平均。之后我们就可以检查肌肉在运动周期的百分之几被激活，以及何时完全放松。</p>
<p><img src="/2021/12/01/3-Biomechanics/%E8%82%8C%E7%94%B5%E4%BF%A1%E5%8F%B7-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/image-20211202161648751.png" alt="image-20211202161648751" style="zoom: 50%;"></p>
<h3 id="肌肉的收缩力"><a href="#肌肉的收缩力" class="headerlink" title="肌肉的收缩力"></a>肌肉的收缩力</h3><p>可以明确的是，表面肌电信号和肌肉产生的力之间有关系，但，这个关系非常复杂，很难通过简单的变换关系的得到。它涉及从神经肌肉的收缩动力学、肌肉骨骼模型、人体关节的运动特性的共同影响，与最大肌肉力、肌肉收缩速度、肌肉长度、羽状角、肌肉肌腱刚度都有关。我们可以推测，当肌电信号的幅值增加时，肌肉中产生的力量或收缩速度也会增加，但这种定性的分析有时可能无法满足定量评估的需求。</p>
<p>多年来这个复杂问题始终没有得到很好的解决，这也是为什么绝大多数的肌肉研究都集中在等距收缩，这种收缩下肌肉力和肌电信号的关系会尽可能小的受到肌肉移动、运动伪影、肌肉串扰的因素的影响。在等距收缩时，表面肌电信号和肌肉力基本成线性关系，线性度因肌肉而异。然而在人体的自然运动中基本不存在等距收缩的过程，毕竟等距收缩不会产生任何形式的运动。如果想由表面肌电信号分析非等距运动的肌肉力特性，必须将分析限制在运动接近等距收缩的时间内。例如选择关节角速度等于零时的左右一小段时间(1%周期)，并评估平均肌肉活跃度。</p>
<p>在不同的实验中，由于受试者肌肉特性、脂肪特性、皮肤特性、电极粘贴位置的不同，基本无法做到测量信号有相同的幅值等级。因此在进行幅度分析时，需要对信号进行归一化，以保证幅值是可以对比的。在实践中经常使用最大主动收缩(maximum voluntary contraction, MVC)的峰值作为归一化标准，肌电信号也就表示为MVC的百分比。但可能存在某些肌肉的MVC非常高，但在特定运动下收缩程度较小，从而使信号整体数值较低。对此也可以采用其他合适的归一化策略，但要确保归一化是有效的。</p>
<h3 id="肌肉疲劳"><a href="#肌肉疲劳" class="headerlink" title="肌肉疲劳"></a>肌肉疲劳</h3><p>个体肌肉疲劳是生物力学分析中的一个重要因素。在没有测量肌电信号时，当肌肉不能保持一定的收缩时，才会被归类为疲劳(这个时间点也被称为疲劳点，point of failure)。然而，肌肉疲劳是一个渐进的过程，我们可以通过肌电信号频率特性来获取肌肉的疲劳信息。</p>
<p><img src="/2021/12/01/3-Biomechanics/%E8%82%8C%E7%94%B5%E4%BF%A1%E5%8F%B7-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/Untitled13.png" alt="Untitled" style="zoom: 25%;"></p>
<p>表面肌电信号的功率谱分布曲线如上所示，这个图仅是一个示意，实际频谱不会如此光滑；另外这个频谱采用的是正常坐标，而上一小节我们绘制的功率谱则是半对数坐标。一般情况下，我们会采用4种特征来刻画肌电信号的功率谱特性：<strong>总功率</strong>、<strong>峰值功率</strong>(频谱的最大值)、<strong>均值频率</strong>(mean frequency,以功率幅值为系数的频率加权平均)，以及<strong>中值频率</strong>(median frequency, 将区域分成两等份的频率)。</p>
<p>当受试者持续执行适当强度、高频的肌肉收缩时，这些频率参数会随时间推移而发生变化。其中均值频率和中值频率会随时间的增加而降低，反应动作电位在肌纤维中的传导速度的下降。下图展示的23分钟行走过程胫骨前肌的肌电信号，并分别对开始和结束2分钟的信号进行功率谱分析。由于该部分实验数据的采集频率仅有500Hz， 我们仅能得到0-250Hz范围内的频谱特性，但依然可以从中得到一些现象。可以看出，后两分钟肌电信号的整体能量有明显的下降，反应在是时域上信号的幅值有明显的降低；尽管并不是非常明显，我们依然可以看出最后两分钟信号的功率分布有向低频方向移动的趋势，通过计算，它们的中值频率分别为177.5Hz和164.9Hz，下降了12.6Hz。</p>
<img src="/2021/12/01/3-Biomechanics/%E8%82%8C%E7%94%B5%E4%BF%A1%E5%8F%B7-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/Untitled14.png" class title="Untitled">
<p>肌肉疲劳研究有两方面应用。首先是识别肌无力问题，以及因此所导致的运动功能障碍和疾病。二是进行力量训练的监测，因训练引起的短期疲劳是肌肉生长的基本要求。</p>
<hr>
<p><strong>Reference</strong></p>
<p><a href="https://www.biomechanist.net/electromyography-basics-of-practical-application/">Electromyography - Basics of Practical Application</a></p>
<p><a href="https://www.youtube.com/watch?v=J7_LEoYuqww">EMG II Electromyography II Muscle electrical activity</a></p>
<p><a href="https://isek.org/resources/">Resources - International Society of Electrophysiology and Kinesiology (ISEK)</a></p>
<p><a href="http://www.seniam.org/">Welcome to SENIAM</a></p>
<p><a href="https://www.noraxon.com/wp-content/uploads/2014/12/ABC-EMG-ISBN.pdf">Konrad, P., 2006. The ABC of EMG: a practical introduction to kinesiological electromyography. Noraxon USA, Inc.</a></p>
<p><a href="https://www.delucafoundation.org/download/bibliography/de-luca/078.pdf">Luca, C.J. de, 1997. The Use of Surface Electromyography in Biomechanics. Journal of Applied Biomechanics 13, 135–163.</a></p>
<p><a href="https://www.delsys.com/downloads/TUTORIAL/a-practicum-on-the-use-of-semg-signals-in-movement-sciences.pdf">Luca, C.J. de, 2008. A Practicum on the Use of sEMG Signals in Movement Sciences. Delsys Inc. </a></p>
<p><a href="https://pdfs.semanticscholar.org/c348/f06416aa03154c40bb82d5b26cef40e5840d.pdf">Wang, J., Tang, L., E Bronlund, J., 2013. Surface EMG Signal Amplification and Filtering. International Journal of Computer Applications 82, 15–22. </a></p>
]]></content>
      <categories>
        <category>biomechanics</category>
      </categories>
      <tags>
        <tag>肌电信号</tag>
      </tags>
  </entry>
  <entry>
    <title>102Lab数据处理软件AIOS</title>
    <url>/2021/10/04/5-Projects/AIOS/</url>
    <content><![CDATA[<img src="/2021/10/04/5-Projects/AIOS/fig1.png" class>
<h2 id="最新版本-v6-15"><a href="#最新版本-v6-15" class="headerlink" title="最新版本 v6.15"></a>最新版本 v6.15</h2><span id="more"></span>
<!-- [下载链接(GitHub)](/download/DPAS-102Lab_v6.15.mlappinstall) -->
<p><a href="/download/DPAS-102Lab_v6.15.mlappinstall">下载链接</a>，拖动到Matlab命令行窗口中即可安装</p>
<h2 id="更新说明"><a href="#更新说明" class="headerlink" title="更新说明"></a>更新说明</h2><h3 id="v6-15"><a href="#v6-15" class="headerlink" title="v6.15"></a>v6.15</h3><ul>
<li>支持图像更多默认参数设置（字体大小、坐标轴粗细等）</li>
<li>支持Figure间跳转</li>
<li>支持点击选择绘图颜色</li>
<li>修复绘制单步曲线的警告</li>
<li>修复绘制方差区域的图例异常</li>
</ul>
<h3 id="v6-11-v6-14"><a href="#v6-11-v6-14" class="headerlink" title="v6.11-v6.14"></a>v6.11-v6.14</h3><ul>
<li>修复多选数据处理时步态划分的问题</li>
<li>修复不同步态长度的数组长度问题</li>
<li>修复多选数据删除</li>
<li>新增支持Group Plot数据反转</li>
<li>新增频响分析功能</li>
<li>新增绘图区域100%填充</li>
<li>新增双纵轴坐标系</li>
<li>优化配色按键布局</li>
<li>优化绘图按键布局</li>
</ul>
<h3 id="v6-10"><a href="#v6-10" class="headerlink" title="v6.10"></a>v6.10</h3><ul>
<li>优化界面配色</li>
<li>新增可视化绘图配色</li>
<li>新增数据处理模式（速度/精度）</li>
<li>新增绘图敞口大小设置</li>
</ul>
<img src="/2021/10/04/5-Projects/AIOS/%E5%9B%BE%E7%89%871.png" class>
<h3 id="v6-8"><a href="#v6-8" class="headerlink" title="v6.8"></a>v6.8</h3><ul>
<li>增加Std特征用于分析稳定性</li>
<li>增加绘制足底压力曲线</li>
<li>增加绘制频响曲线</li>
<li>增加绘制阶跃曲线</li>
</ul>
<h3 id><a href="#" class="headerlink" title></a></h3><h3 id="v6-5"><a href="#v6-5" class="headerlink" title="v6.5"></a>v6.5</h3><ul>
<li>调整步态分割的最小步数</li>
<li>支持一键保存fig，png，eps</li>
<li>修复步态分割Bug</li>
<li>调整每步数据点个数为101</li>
</ul>
<h3 id="v6-4"><a href="#v6-4" class="headerlink" title="v6.4"></a>v6.4</h3><ul>
<li>新增功能：实验数据切分、合并，支持数据多选</li>
<li>新增功能：变量归一化、基线去除</li>
<li>新增功能：Group Plot</li>
<li>增加系统背景配色</li>
<li>优化功能按键分布</li>
</ul>

<h3 id="v5-6"><a href="#v5-6" class="headerlink" title="v5.6"></a>v5.6</h3><ul>
<li>支持一维、二维特征插值与拟合</li>
<li>支持4种显著性分析（T-test、Anova、Mann-Whhitney-Wilcoxon、Kruskal-Wallis）<img src="/2021/10/04/5-Projects/AIOS/fig1.png" class>
<img src="/2021/10/04/5-Projects/AIOS/fig2.png" class>
</li>
</ul>
<h3 id="v5-1"><a href="#v5-1" class="headerlink" title="v5.1"></a>v5.1</h3><ul>
<li>优化显示界面</li>
<li>增加过渡动画</li>
<li>增加更多曲线线型设置</li>
<li>优化色彩排序</li>
<li><p>修复单组柱状图绘制BUG</p>
<img src="/2021/10/04/5-Projects/AIOS/demo2.gif" class>
</li>
</ul>
<h3 id="v4-12"><a href="#v4-12" class="headerlink" title="v4.12"></a>v4.12</h3><ul>
<li>支持绘制SubPlot：选择子图数目，点击<code>NEW SubPlot</code>创建子图；选择子图行、列序号，点击<code>SELECT Sub</code>选中子图进行绘制</li>
</ul>
<img src="/2021/10/04/5-Projects/AIOS/demo1.gif" class>
<h3 id="v4-10"><a href="#v4-10" class="headerlink" title="v4.10"></a>v4.10</h3><ul>
<li>增加对双侧外骨骼的实验数据支持。确保数据中包含变量”state_r”和”state_l”；所有变量名中包含”_r”/“_R”的变量将作为右侧数据进行步态分割；所有变量名中包含”_l”/“_L”的变量将作为右侧数据进行步态分割；其他数据作为右侧数据进行步态分割。</li>
</ul>
<h3 id="v4-9"><a href="#v4-9" class="headerlink" title="v4.9"></a>v4.9</h3><ul>
<li>修复不同分辨率下的显示问题</li>
</ul>
<h3 id="v4-8"><a href="#v4-8" class="headerlink" title="v4.8"></a>v4.8</h3><ul>
<li>重新加入Scone的GRF &amp; Kine数据提取（LOAD界面）</li>
<li>支持Group Bar的误差线绘制（Broup Bar界面）</li>
<li>支持Bar和Group Bar的即时是数据导出（COMP &amp; Broup Bar界面）</li>
<li>支持数据中部分Step的删除，用于剔除错误的Step（LOAD界面）</li>
</ul>
<h3 id="v4-0"><a href="#v4-0" class="headerlink" title="v4.0"></a>v4.0</h3><ul>
<li>优化配色系统，加入othercolor</li>
<li>支持绘制步态变化曲线</li>
<li>支持相图绘制（关节角vs关节力矩）</li>
<li>支持绘制曲线对比与特征柱状图</li>
<li>支持绘制GroupBar（肌电特征）</li>
</ul>
<h3 id="v3-0"><a href="#v3-0" class="headerlink" title="v3.0"></a>v3.0</h3><ul>
<li>全面优化代码结构，降低复杂度</li>
</ul>
<h3 id="v2-0"><a href="#v2-0" class="headerlink" title="v2.0"></a>v2.0</h3><ul>
<li>支持导入Scone数据</li>
<li>支持导入PredSim数据</li>
<li>支持导入OpenSim数据（需配和步态分割信号进行数据处理）</li>
</ul>
<h3 id="V1-0"><a href="#V1-0" class="headerlink" title="V1.0"></a>V1.0</h3><p>基于Matlab App Designer设计了一款实验室数据分析软件AIOS</p>
<img src="/2021/10/04/5-Projects/AIOS/1.png" class title="主界面">
<img src="/2021/10/04/5-Projects/AIOS/2.png" class title="数据加载界面">
<img src="/2021/10/04/5-Projects/AIOS/3.png" class title="绘图界面">
<hr>
<hr>
<h4 id="软件使用介绍"><a href="#软件使用介绍" class="headerlink" title="软件使用介绍"></a>软件使用介绍</h4><h5 id="打开软件"><a href="#打开软件" class="headerlink" title="打开软件"></a>打开软件</h5><p>有两种方式打开AIOS，第一种通过Matlab APP打开，启动速度较快；第二种通过exe文件直接打开，无需依赖。</p>
<p>通过Matlab APP打开：<br><img src="/2021/10/04/5-Projects/AIOS/4.gif" class><br>通过exe文件打开：<br><img src="/2021/10/04/5-Projects/AIOS/5.gif" class></p>
<h4 id="加载数据"><a href="#加载数据" class="headerlink" title="加载数据"></a>加载数据</h4><h5 id="导入实验文件"><a href="#导入实验文件" class="headerlink" title="导入实验文件"></a>导入实验文件</h5><p>软件可导入由dSPACE ControlDesk采集得到的数据，并支持多个数据文件的导入与分析：</p>
<img src="/2021/10/04/5-Projects/AIOS/6.gif" class>
<h5 id="提取数据变量并处理"><a href="#提取数据变量并处理" class="headerlink" title="提取数据变量并处理"></a>提取数据变量并处理</h5><p>从原始数据中提取有用数据变量进行分析</p>
<ul>
<li>支持变量重命名</li>
<li>支持数据一键处理（处理详情待补充），需先提取state变量</li>
<li>支持数据保存</li>
</ul>
<img src="/2021/10/04/5-Projects/AIOS/7.gif" class>
<h4 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h4><h5 id="绘制时间序列曲线"><a href="#绘制时间序列曲线" class="headerlink" title="绘制时间序列曲线"></a>绘制时间序列曲线</h5><ul>
<li>在新建Figure窗口中绘图，方便图像缩放、保存和进一步处理</li>
<li>支持多曲线绘制与窗口清空</li>
</ul>
<img src="/2021/10/04/5-Projects/AIOS/8.gif" class>
<img src="/2021/10/04/5-Projects/AIOS/9.gif" class>
<h5 id="绘制步态周期曲线"><a href="#绘制步态周期曲线" class="headerlink" title="绘制步态周期曲线"></a>绘制步态周期曲线</h5><ul>
<li>支持步态周期逐条曲线、平均曲线、方差区域的绘制</li>
<li>支持多曲线绘制与颜色设置</li>
</ul>
<img src="/2021/10/04/5-Projects/AIOS/10.gif" class>
<img src="/2021/10/04/5-Projects/AIOS/11.gif" class>
<h5 id="绘制步态特征柱状图"><a href="#绘制步态特征柱状图" class="headerlink" title="绘制步态特征柱状图"></a>绘制步态特征柱状图</h5><ul>
<li>支持柱状图数据导入与删除</li>
<li>支持步态特征选择（rms、mean、max、min）</li>
<li>支持bar与error bar切换</li>
<li>支持colormap设置</li>
</ul>
<img src="/2021/10/04/5-Projects/AIOS/12.gif" class>
<hr>
<h2 id="历史版本"><a href="#历史版本" class="headerlink" title="历史版本"></a>历史版本</h2><ul>
<li><a href="/download/AIOS_v1.0.mlappinstall">v1.0版本</a></li>
<li><a href="/download/AIOS_v4.6.mlappinstall">v4.6版本</a></li>
<li><a href="/download/AIOS_v4.8.mlappinstall">v4.8版本</a></li>
<li><a href="/download/AIOS_v4.9.mlappinstall">v4.9版本</a></li>
<li><a href="/download/AIOS_v4.10.mlappinstall">v4.10版本</a></li>
<li><a href="/download/AIOS_v4.12.mlappinstall">v4.12版本</a></li>
<li><a href="/download/AIOS_v5.6.mlappinstall">v5.6版本</a></li>
<li><a href="/download/DPAS_for_102Lab.mlapp">v6.4版本</a></li>
<li><a href="/download/DPAS-102Lab_v6.5.mlappinstall">v6.5版本</a></li>
<li><a href="/download/DPAS-102Lab_v6.6.mlappinstall">v6.6版本</a></li>
<li><a href="/download/DPAS-102Lab_v6.10.mlappinstall">v6.10版本</a></li>
<li><a href="/download/DPAS-102Lab_v6.12.mlappinstall">v6.12版本</a></li>
<li><a href="/download/DPAS-102Lab_v6.15.mlappinstall">v6.15版本</a></li>
</ul>
]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title>PyCosmed数字识别</title>
    <url>/2020/01/20/5-Projects/PyCosmed%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<p>PyCosmed数字识别程序回顾与优化。</p>
<span id="more"></span>
<h3 id="图像预处理"><a href="#图像预处理" class="headerlink" title="图像预处理"></a>图像预处理</h3><p>首先要将截取的图片转为灰度图像，然后绘制灰度直方图，确定二值化阈值<code>150</code>，然后进行二值化：</p>
<img src="/2020/01/20/5-Projects/PyCosmed%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/Figure_1.png" class>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取图像</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_img</span>(<span class="params">index</span>):</span></span><br><span class="line">    img = Image.<span class="built_in">open</span>(<span class="string">&quot;E:\\Python\\PyCosmed\\v3.0\DIGIT2\\&quot;</span>+<span class="built_in">str</span>(index)+<span class="string">&quot;.png&quot;</span>)</span><br><span class="line">    plt.subplot(<span class="number">221</span>)</span><br><span class="line">    plt.imshow(img)</span><br><span class="line">    <span class="keyword">return</span> img</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分析灰度直方图，从而选择合适的二值化阈值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gray_hist</span>(<span class="params">img</span>):</span></span><br><span class="line">    img_arr = np.array(img.convert(<span class="string">&#x27;L&#x27;</span>))    <span class="comment">#  convert - 转换图像格式   L - 八位黑白像素</span></span><br><span class="line">                                            <span class="comment">#  array - image格式转为array数组</span></span><br><span class="line">    plt.subplot(<span class="number">223</span>)</span><br><span class="line">    plt.imshow(img_arr)</span><br><span class="line"></span><br><span class="line">    img_arr = img_arr.flatten()             <span class="comment">#  flatten - 转化为一维数组</span></span><br><span class="line">    plt.subplot(<span class="number">222</span>)</span><br><span class="line">    plt.hist(img_arr,bins=<span class="number">256</span>)              <span class="comment">#  hist - 绘制直方图  bins - 条形数</span></span><br><span class="line">    plt.ylim((<span class="number">0</span>,<span class="number">50</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图像二值化</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarize</span>(<span class="params">img, threshold=threshold</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;二值化&quot;&quot;&quot;</span></span><br><span class="line">    img = img.convert(<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">    table = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        <span class="keyword">if</span> i &lt; threshold:</span><br><span class="line">            table.append(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            table.append(<span class="number">1</span>)</span><br><span class="line">    bin_img = img.point(table, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    plt.subplot(<span class="number">222</span>)</span><br><span class="line">    plt.imshow(bin_img)</span><br><span class="line">    <span class="keyword">return</span> bin_img</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="图像分割"><a href="#图像分割" class="headerlink" title="图像分割"></a>图像分割</h3><p>加入分割宽度机制，避免数字相连情况:</p>
<img src="/2020/01/20/5-Projects/PyCosmed%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/Figure_2.png" class>
<p>分割后的图像集：</p>
<img src="/2020/01/20/5-Projects/PyCosmed%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/Figure_4.png" class>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vertical_cut</span>(<span class="params">img</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;纵向切割&quot;&quot;&quot;</span></span><br><span class="line">    px = <span class="built_in">list</span>(np.<span class="built_in">sum</span>(np.array(img) == <span class="number">0</span>, axis=<span class="number">0</span>))</span><br><span class="line">    py = <span class="built_in">list</span>(np.<span class="built_in">sum</span>(np.array(img) == <span class="number">0</span>, axis=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 列表保存像素累加值大于0的列</span></span><br><span class="line">    x0 = []</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(px)):</span><br><span class="line">        <span class="keyword">if</span> px[x] &gt; <span class="number">0</span>:</span><br><span class="line">            x0.append(x)</span><br><span class="line">    y0 = []</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(py)):</span><br><span class="line">        <span class="keyword">if</span> py[y] &gt; <span class="number">1</span>:</span><br><span class="line">            y0.append(y)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 找出边界</span></span><br><span class="line">    cut_list = [x0[<span class="number">0</span>]]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(x0)):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(x0[i] - x0[i - <span class="number">1</span>]) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">abs</span>(x0[i-<span class="number">1</span>] - cut_list[-<span class="number">1</span>]) &lt; <span class="number">10</span>:</span><br><span class="line">                cut_list.extend([x0[i - <span class="number">1</span>]+<span class="number">1</span>, x0[i]])</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">abs</span>(x0[i-<span class="number">1</span>] - cut_list[-<span class="number">1</span>]) &lt; <span class="number">16</span>:</span><br><span class="line">                cut_list.extend([x0[i-<span class="number">1</span>]+<span class="number">1</span>, x0[i-<span class="number">1</span>]+<span class="number">8</span>])</span><br><span class="line">                cut_list.extend([x0[i-<span class="number">1</span>]+<span class="number">8</span>, x0[i]])</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">abs</span>(x0[i-<span class="number">1</span>] - cut_list[-<span class="number">1</span>]) &lt; <span class="number">24</span>:</span><br><span class="line">                cut_list.extend([x0[i-<span class="number">1</span>]+<span class="number">1</span>, x0[i-<span class="number">1</span>]+<span class="number">8</span>])</span><br><span class="line">                cut_list.extend([x0[i-<span class="number">1</span>]+<span class="number">8</span>, x0[i-<span class="number">1</span>]+<span class="number">16</span>])</span><br><span class="line">                cut_list.extend([x0[i-<span class="number">1</span>]+<span class="number">16</span>, x0[i]])</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">abs</span>(x0[-<span class="number">1</span>] - cut_list[-<span class="number">1</span>]) &lt; <span class="number">10</span>:</span><br><span class="line">        cut_list.append(x0[-<span class="number">1</span>]+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">abs</span>(x0[-<span class="number">1</span>] - cut_list[-<span class="number">1</span>]) &lt; <span class="number">17</span>:</span><br><span class="line">        cut_list.extend([cut_list[-<span class="number">1</span>]+<span class="number">8</span>, cut_list[-<span class="number">1</span>]+<span class="number">8</span>])</span><br><span class="line">        cut_list.append(x0[-<span class="number">1</span>]+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">abs</span>(x0[-<span class="number">1</span>] - cut_list[-<span class="number">1</span>]) &lt; <span class="number">25</span>:</span><br><span class="line">        cut_list.extend([cut_list[-<span class="number">1</span>]+<span class="number">8</span>, cut_list[-<span class="number">1</span>]+<span class="number">8</span>])</span><br><span class="line">        cut_list.extend([cut_list[-<span class="number">1</span>]+<span class="number">8</span>, cut_list[-<span class="number">1</span>]+<span class="number">8</span>])</span><br><span class="line">        cut_list.append(x0[-<span class="number">1</span>]+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    cut_list_y = [y0[<span class="number">0</span>]]</span><br><span class="line">    cut_list_y.append(y0[-<span class="number">1</span>]+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    cut_imgs = []</span><br><span class="line">    <span class="comment"># 切割顺利的话应该是整对</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(cut_list) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cut_list) // <span class="number">2</span>):</span><br><span class="line">            cut_img = img.crop([cut_list[i * <span class="number">2</span>], cut_list_y[<span class="number">0</span>], cut_list[i * <span class="number">2</span> + <span class="number">1</span>], cut_list_y[<span class="number">1</span>]])</span><br><span class="line">            plt.imshow(cut_img)</span><br><span class="line">        <span class="keyword">return</span> cut_imgs</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&#x27;Vertical cut failed.&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<h3 id="计算Hash码"><a href="#计算Hash码" class="headerlink" title="计算Hash码"></a>计算Hash码</h3><p>分割后的图像被统一缩放到<code>8*15</code>的大小，然后计算其Hash码，并提取每个字符的标准Hash码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 标准Hash码</span></span><br><span class="line">hash_vals = &#123;</span><br><span class="line">    <span class="string">&quot;0&quot;</span>: <span class="string">&quot;110000111000000110011001100110000001100000111100001111000011110000111100001111000001100010011001100110011000000111000011&quot;</span>,</span><br><span class="line">    <span class="string">&quot;1&quot;</span>: <span class="string">&quot;111000000000000000000000111110001111100011111000111110001111100011111000111110001111100011111000111110001111100011111000&quot;</span>,</span><br><span class="line">    <span class="string">&quot;2&quot;</span>: <span class="string">&quot;100000111000000111110001111110011111100111111001111110011111000111110011111000111100011111001111100111110000000000000000&quot;</span>,</span><br><span class="line">    <span class="string">&quot;3&quot;</span>: <span class="string">&quot;100000111000000111111000111111001111110011111001110000011100000111111000111111001111110011111100111110000000000110000011&quot;</span>,</span><br><span class="line">    <span class="string">&quot;4&quot;</span>: <span class="string">&quot;111100011111000111100001111000011100100111001001100110011001100100111001000000000000000011111001111110011111100111111001&quot;</span>,</span><br><span class="line">    <span class="string">&quot;5&quot;</span>: <span class="string">&quot;110000001100000010011111100111111001111110011111100000111000000011111000111111001111110011111100111110000000000100000011&quot;</span>,</span><br><span class="line">    <span class="string">&quot;6&quot;</span>: <span class="string">&quot;111110011110000111000111110011111001111110011111000000010000000100011000001111000011110000011100100110001000000111000011&quot;</span>,</span><br><span class="line">    <span class="string">&quot;7&quot;</span>: <span class="string">&quot;000000000000000011111001111110011111100111110011111100111111001111100111111001111100011111001111110011111000111110011111&quot;</span>,</span><br><span class="line">    <span class="string">&quot;8&quot;</span>: <span class="string">&quot;111000111100000110011000100111001001110010001001110000011100000110001000100111000001110000011100100111001000000011000011&quot;</span>, </span><br><span class="line">    <span class="string">&quot;9&quot;</span>: <span class="string">&quot;110000111000000110011001000110000011110000111100000111001001100010000000111010001111100111110001111000111000011110001111&quot;</span>,</span><br><span class="line">    <span class="string">&quot;.&quot;</span>: <span class="string">&quot;111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000000011100000&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hashing</span>(<span class="params">img</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算哈希值&quot;&quot;&quot;</span></span><br><span class="line">    img = img.resize((<span class="number">8</span>, <span class="number">15</span>), Image.LANCZOS)</span><br><span class="line">    px = np.array(img).flatten()</span><br><span class="line">    hash_val = (px &gt; px.mean()).astype(<span class="built_in">int</span>)</span><br><span class="line">    hash_val = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">str</span>(e) <span class="keyword">for</span> e <span class="keyword">in</span> hash_val)</span><br><span class="line">    <span class="keyword">return</span> hash_val</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hamming</span>(<span class="params">hash1, hash2</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算汉明距离&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(hash1) != <span class="built_in">len</span>(hash2):</span><br><span class="line">        print(<span class="string">&#x27;hash1: &#x27;</span>, hash1)</span><br><span class="line">        print(<span class="string">&#x27;hash2: &#x27;</span>, hash2)</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;Undefined for sequences of unequal length&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(i != j <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">zip</span>(hash1, hash2))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recognize</span>(<span class="params">img</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;识别结果&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># img = img.convert(&#x27;L&#x27;)</span></span><br><span class="line">    <span class="comment"># img = binarize(img)</span></span><br><span class="line">    <span class="comment"># chars = vertical_cut(img)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 相近度列表</span></span><br><span class="line">    nearness = &#123;&#125;</span><br><span class="line">    <span class="comment"># expr = &#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># for char in chars:</span></span><br><span class="line">    hash_val = hashing(img)</span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> hash_vals:</span><br><span class="line">        nearness[h] = hamming(hash_val, hash_vals[h])</span><br><span class="line">    expr = <span class="built_in">sorted</span>(nearness.items(), key=<span class="keyword">lambda</span> d: d[<span class="number">1</span>])[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> expr</span><br></pre></td></tr></table></figure>
<h3 id="识别结果"><a href="#识别结果" class="headerlink" title="识别结果"></a>识别结果</h3><p>分割数据集下的识别结果：</p>
<img src="/2020/01/20/5-Projects/PyCosmed%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/Figure_5.png" class>
<p>原始图像下的识别结果：</p>
<img src="/2020/01/20/5-Projects/PyCosmed%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/Figure_6.png" class>
<h3 id="One-More-Thing"><a href="#One-More-Thing" class="headerlink" title="One More Thing"></a>One More Thing</h3><p>另外对分割图像集进行个 主成分分析（PCA），在第一主成分和第二主成分平面上不具有明显的可分性，故没有进一步研究：</p>
<img src="/2020/01/20/5-Projects/PyCosmed%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/Figure_7.png" class>
]]></content>
      <categories>
        <category>工程开发</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Latex常用符号</title>
    <url>/2022/01/02/9-Others/Latex%E5%B8%B8%E7%94%A8%E7%AC%A6%E5%8F%B7/</url>
    <content><![CDATA[<img src="/2022/01/02/9-Others/Latex%E5%B8%B8%E7%94%A8%E7%AC%A6%E5%8F%B7/Latex-Logo.png" class>
<span id="more"></span>
<h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">希腊字母</th>
<th style="text-align:center">Latex代码</th>
<th style="text-align:center">希腊字母</th>
<th style="text-align:center">Latex代码</th>
<th style="text-align:center">希腊字母</th>
<th style="text-align:center">Latex代码</th>
<th style="text-align:center">希腊字母</th>
<th style="text-align:center">Latex代码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\alpha$</td>
<td style="text-align:center">\alpha</td>
<td style="text-align:center">$\beta$</td>
<td style="text-align:center">\beta</td>
<td style="text-align:center">$\gamma$</td>
<td style="text-align:center">\gamma</td>
<td style="text-align:center">$\delta$</td>
<td style="text-align:center">\delta</td>
</tr>
<tr>
<td style="text-align:center">$\epsilon$</td>
<td style="text-align:center">\epsilon</td>
<td style="text-align:center">$\varepsilon$</td>
<td style="text-align:center">\varepsilon</td>
<td style="text-align:center">$\zeta$</td>
<td style="text-align:center">\zeta</td>
<td style="text-align:center">$\eta$</td>
<td style="text-align:center">\eta</td>
</tr>
<tr>
<td style="text-align:center">$\theta$</td>
<td style="text-align:center">\theta</td>
<td style="text-align:center">$\vartheta$</td>
<td style="text-align:center">\vartheta</td>
<td style="text-align:center">$\iota$</td>
<td style="text-align:center">\iota</td>
<td style="text-align:center">$\kappa$</td>
<td style="text-align:center">\kappa</td>
</tr>
<tr>
<td style="text-align:center">$\lambda$</td>
<td style="text-align:center">\lambda</td>
<td style="text-align:center">$\mu$</td>
<td style="text-align:center">\mu</td>
<td style="text-align:center">$\nu$</td>
<td style="text-align:center">\nu</td>
<td style="text-align:center">$\xi$</td>
<td style="text-align:center">\xi</td>
</tr>
<tr>
<td style="text-align:center">$o$</td>
<td style="text-align:center">o</td>
<td style="text-align:center">$\pi$</td>
<td style="text-align:center">\pi</td>
<td style="text-align:center">$\varpi$</td>
<td style="text-align:center">\varpi</td>
<td style="text-align:center">$\rho$</td>
<td style="text-align:center">\rho</td>
</tr>
<tr>
<td style="text-align:center">$\varrho$</td>
<td style="text-align:center">\varrho</td>
<td style="text-align:center">$\sigma$</td>
<td style="text-align:center">\sigma</td>
<td style="text-align:center">$\varsigma$</td>
<td style="text-align:center">\varsigma</td>
<td style="text-align:center">$\tau$</td>
<td style="text-align:center">\tau</td>
</tr>
<tr>
<td style="text-align:center">$\upsilon$</td>
<td style="text-align:center">\upsilon</td>
<td style="text-align:center">$\phi$</td>
<td style="text-align:center">\phi</td>
<td style="text-align:center">$\varphi$</td>
<td style="text-align:center">\varphi</td>
<td style="text-align:center">$\chi$</td>
<td style="text-align:center">\chi</td>
</tr>
<tr>
<td style="text-align:center">$\psi$</td>
<td style="text-align:center">\psi</td>
<td style="text-align:center">$\omega$</td>
<td style="text-align:center">\omega</td>
</tr>
<tr>
<td style="text-align:center">$\Gamma$</td>
<td style="text-align:center">\Gamma</td>
<td style="text-align:center">$\Lambda$</td>
<td style="text-align:center">\Lambda</td>
<td style="text-align:center">$\Sigma$</td>
<td style="text-align:center">\Sigma</td>
<td style="text-align:center">$\Psi$</td>
<td style="text-align:center">\Psi</td>
</tr>
<tr>
<td style="text-align:center">$\Delta$</td>
<td style="text-align:center">\Delta</td>
<td style="text-align:center">$\Xi$</td>
<td style="text-align:center">\Xi</td>
<td style="text-align:center">$\Upsilon$</td>
<td style="text-align:center">\Upsilon</td>
<td style="text-align:center">$\Omega$</td>
<td style="text-align:center">\Omega</td>
</tr>
<tr>
<td style="text-align:center">$\Theta $</td>
<td style="text-align:center">\Theta</td>
<td style="text-align:center">$\Pi$</td>
<td style="text-align:center">\Pi</td>
<td style="text-align:center">$\Phi$</td>
<td style="text-align:center">\Phi</td>
</tr>
</tbody>
</table>
</div>
<h2 id="数学运算符"><a href="#数学运算符" class="headerlink" title="数学运算符"></a>数学运算符</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">数学符号</th>
<th style="text-align:center">Latex代码</th>
<th style="text-align:center">数学符号</th>
<th style="text-align:center">Latex代码</th>
<th style="text-align:center">数学符号</th>
<th style="text-align:center">Latex代码</th>
<th style="text-align:center">数学符号</th>
<th style="text-align:center">Latex代码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$+$</td>
<td style="text-align:center">+</td>
<td style="text-align:center">$-$</td>
<td style="text-align:center">-</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">\times</td>
<td style="text-align:center">$\div$</td>
<td style="text-align:center">\div</td>
</tr>
<tr>
<td style="text-align:center">$\pm$</td>
<td style="text-align:center">\pm</td>
<td style="text-align:center">$\mp$</td>
<td style="text-align:center">\mp</td>
<td style="text-align:center">$\cdot$</td>
<td style="text-align:center">\cdot</td>
<td style="text-align:center">$\setminus$</td>
<td style="text-align:center">\setminus</td>
</tr>
<tr>
<td style="text-align:center">$\oplus$</td>
<td style="text-align:center">\oplus</td>
<td style="text-align:center">$\ominus$</td>
<td style="text-align:center">\ominus</td>
<td style="text-align:center">$\odot$</td>
<td style="text-align:center">\odot</td>
<td style="text-align:center">$\otimes$</td>
<td style="text-align:center">\otimes</td>
</tr>
<tr>
<td style="text-align:center">$\partial$</td>
<td style="text-align:center">\partial</td>
<td style="text-align:center">$\nabla$</td>
<td style="text-align:center">\nabla</td>
<td style="text-align:center">$\infty$</td>
<td style="text-align:center">\infty</td>
<td style="text-align:center">$\lVert$</td>
<td style="text-align:center">\lVert</td>
</tr>
<tr>
<td style="text-align:center">$\sum$</td>
<td style="text-align:center">\sum</td>
<td style="text-align:center">$\prod$</td>
<td style="text-align:center">\prod</td>
<td style="text-align:center">$\coprod$</td>
<td style="text-align:center">\coprod</td>
<td style="text-align:center">$\bigotimes$</td>
<td style="text-align:center">\bigotimes</td>
</tr>
<tr>
<td style="text-align:center">$\int$</td>
<td style="text-align:center">\int</td>
<td style="text-align:center">$\oint$</td>
<td style="text-align:center">\oint</td>
<td style="text-align:center">$\bigcup$</td>
<td style="text-align:center">\bigcup</td>
<td style="text-align:center">$\bigcap$</td>
<td style="text-align:center">\bigcap</td>
</tr>
</tbody>
</table>
</div>
<h2 id="数学关系符"><a href="#数学关系符" class="headerlink" title="数学关系符"></a>数学关系符</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">数学符号</th>
<th style="text-align:center">Latex代码</th>
<th style="text-align:center">数学符号</th>
<th style="text-align:center">Latex代码</th>
<th style="text-align:center">数学符号</th>
<th style="text-align:center">Latex代码</th>
<th style="text-align:center">数学符号</th>
<th style="text-align:center">Latex代码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\le$</td>
<td style="text-align:center">\le</td>
<td style="text-align:center">$\ge$</td>
<td style="text-align:center">\ge</td>
<td style="text-align:center">$\ll$</td>
<td style="text-align:center">\ll</td>
<td style="text-align:center">$\gg$</td>
<td style="text-align:center">\gg</td>
</tr>
<tr>
<td style="text-align:center">$\equiv$</td>
<td style="text-align:center">\equiv</td>
<td style="text-align:center">$\doteq$</td>
<td style="text-align:center">\doteq</td>
<td style="text-align:center">$\ne$</td>
<td style="text-align:center">\ne</td>
<td style="text-align:center">$=$</td>
<td style="text-align:center">=</td>
</tr>
<tr>
<td style="text-align:center">$\sim$</td>
<td style="text-align:center">\sim</td>
<td style="text-align:center">$\approx$</td>
<td style="text-align:center">\approx</td>
<td style="text-align:center">$\simeq$</td>
<td style="text-align:center">\simeq</td>
<td style="text-align:center">$\cong$</td>
<td style="text-align:center">\cong</td>
</tr>
<tr>
<td style="text-align:center">$\subset$</td>
<td style="text-align:center">\subset</td>
<td style="text-align:center">$\supset$</td>
<td style="text-align:center">\supset</td>
<td style="text-align:center">$\subseteq$</td>
<td style="text-align:center">\subseteq</td>
<td style="text-align:center">$\supseteq$</td>
<td style="text-align:center">\supseteq</td>
</tr>
<tr>
<td style="text-align:center">$\in$</td>
<td style="text-align:center">\in</td>
<td style="text-align:center">$\ni$</td>
<td style="text-align:center">\ni</td>
<td style="text-align:center">$\notin$</td>
<td style="text-align:center">\notin</td>
<td style="text-align:center">$\propto$</td>
<td style="text-align:center">\propto</td>
</tr>
<tr>
<td style="text-align:center">$\cup$</td>
<td style="text-align:center">\cup</td>
<td style="text-align:center">$\cap$</td>
<td style="text-align:center">\cap</td>
<td style="text-align:center">$\vee$</td>
<td style="text-align:center">\vee</td>
<td style="text-align:center">$\wedge$</td>
<td style="text-align:center">\wedge</td>
</tr>
<tr>
<td style="text-align:center">$\sqcup$</td>
<td style="text-align:center">\sqcup</td>
<td style="text-align:center">$\sqcap$</td>
<td style="text-align:center">\sqcap</td>
<td style="text-align:center">$\wr$</td>
<td style="text-align:center">\wr</td>
<td style="text-align:center">$\oslash$</td>
<td style="text-align:center">\oslash</td>
</tr>
<tr>
<td style="text-align:center">$\forall$</td>
<td style="text-align:center">\forall</td>
<td style="text-align:center">$\exists$</td>
<td style="text-align:center">\exists</td>
<td style="text-align:center">$\because$</td>
<td style="text-align:center">\because</td>
<td style="text-align:center">$\therefore$</td>
<td style="text-align:center">\therefore</td>
</tr>
</tbody>
</table>
</div>
<h2 id="数学强调符"><a href="#数学强调符" class="headerlink" title="数学强调符"></a>数学强调符</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">数学符号</th>
<th style="text-align:center">Latex代码</th>
<th style="text-align:center">数学符号</th>
<th style="text-align:center">Latex代码</th>
<th style="text-align:center">数学符号</th>
<th style="text-align:center">Latex代码</th>
<th style="text-align:center">数学符号</th>
<th style="text-align:center">Latex代码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\bar{a}$</td>
<td style="text-align:center">\bar{a}</td>
<td style="text-align:center">$\tilde{a}$</td>
<td style="text-align:center">\tilde{a}</td>
<td style="text-align:center">$\hat{a}$</td>
<td style="text-align:center">\hat{a}</td>
<td style="text-align:center">$\check{a}$</td>
<td style="text-align:center">\check{a}</td>
</tr>
<tr>
<td style="text-align:center">$\grave{a}$</td>
<td style="text-align:center">\grave{a}</td>
<td style="text-align:center">$\acute{a}$</td>
<td style="text-align:center">\acute{a}</td>
<td style="text-align:center">$\dot{a}$</td>
<td style="text-align:center">\dot{a}</td>
<td style="text-align:center">$\ddot{a}$</td>
<td style="text-align:center">\ddot{a}</td>
</tr>
<tr>
<td style="text-align:center">$\vec{a}$</td>
<td style="text-align:center">\vec{a}</td>
<td style="text-align:center">$\widetilde{A}$</td>
<td style="text-align:center">\widetilde{A}</td>
<td style="text-align:center">$\widehat{A}$</td>
<td style="text-align:center">\widehat{A}</td>
</tr>
</tbody>
</table>
</div>
<h2 id="其他数学符号"><a href="#其他数学符号" class="headerlink" title="其他数学符号"></a>其他数学符号</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">数学符号</th>
<th style="text-align:center">Latex代码</th>
<th style="text-align:center">数学符号</th>
<th style="text-align:center">Latex代码</th>
<th style="text-align:center">数学符号</th>
<th style="text-align:center">Latex代码</th>
<th style="text-align:center">数学符号</th>
<th style="text-align:center">Latex代码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\dots$</td>
<td style="text-align:center">\dots</td>
<td style="text-align:center">$\cdots$</td>
<td style="text-align:center">\cdots</td>
<td style="text-align:center">$\vdots$</td>
<td style="text-align:center">\vdots</td>
<td style="text-align:center">$\ddots$</td>
<td style="text-align:center">\ddots</td>
</tr>
<tr>
<td style="text-align:center">$\bot$</td>
<td style="text-align:center">\bot</td>
<td style="text-align:center">$\top$</td>
<td style="text-align:center">\top</td>
<td style="text-align:center">$\angle$</td>
<td style="text-align:center">\angle</td>
<td style="text-align:center">$\surd$</td>
<td style="text-align:center">\surd</td>
</tr>
<tr>
<td style="text-align:center">$\circ$</td>
<td style="text-align:center">\circ</td>
<td style="text-align:center">$\bullet$</td>
<td style="text-align:center">\bullet</td>
<td style="text-align:center">$\ast$</td>
<td style="text-align:center">\ast</td>
<td style="text-align:center">$\star$</td>
<td style="text-align:center">\star</td>
</tr>
<tr>
<td style="text-align:center">$\bigtriangleup$</td>
<td style="text-align:center">\bigtriangleup</td>
<td style="text-align:center">$\bigtriangledown$</td>
<td style="text-align:center">\bigtriangledown</td>
<td style="text-align:center">$\triangleleft$</td>
<td style="text-align:center">\triangleleft</td>
<td style="text-align:center">$\triangleright$</td>
<td style="text-align:center">\triangleright</td>
</tr>
<tr>
<td style="text-align:center">$\diamond$</td>
<td style="text-align:center">\diamond</td>
<td style="text-align:center">$\diamondsuit$</td>
<td style="text-align:center">\diamondsuit</td>
<td style="text-align:center">$\heartsuit$</td>
<td style="text-align:center">\heartsuit</td>
<td style="text-align:center">$\Box$</td>
<td style="text-align:center">\Box</td>
</tr>
<tr>
<td style="text-align:center">$\Re$</td>
<td style="text-align:center">\Re</td>
<td style="text-align:center">$\Im$</td>
<td style="text-align:center">\Im</td>
<td style="text-align:center">$\imath$</td>
<td style="text-align:center">\imath</td>
<td style="text-align:center">$\jmath$</td>
<td style="text-align:center">\jmath</td>
</tr>
<tr>
<td style="text-align:center">$\hbar$</td>
<td style="text-align:center">\hbar</td>
<td style="text-align:center">$\ell$</td>
<td style="text-align:center">\ell</td>
<td style="text-align:center">$\wp$</td>
<td style="text-align:center">\wp</td>
<td style="text-align:center">$\aleph$</td>
<td style="text-align:center">\aleph</td>
</tr>
</tbody>
</table>
</div>
<h2 id="箭头"><a href="#箭头" class="headerlink" title="箭头"></a>箭头</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">Latex代码</th>
<th style="text-align:center">符号</th>
<th style="text-align:center">Latex代码</th>
<th style="text-align:center">符号</th>
<th style="text-align:center">Latex代码</th>
<th style="text-align:center">符号</th>
<th style="text-align:center">Latex代码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\leftarrow$</td>
<td style="text-align:center">\leftarrow</td>
<td style="text-align:center">$\to$</td>
<td style="text-align:center">\to</td>
<td style="text-align:center">$\leftrightarrow$</td>
<td style="text-align:center">\leftrightarrow</td>
<td style="text-align:center">$\rightarrow$</td>
<td style="text-align:center">\rightarrow</td>
</tr>
<tr>
<td style="text-align:center">$\Leftarrow$</td>
<td style="text-align:center">\Leftarrow</td>
<td style="text-align:center">$\Rightarrow$</td>
<td style="text-align:center">\Rightarrow</td>
<td style="text-align:center">$\Leftrightarrow$</td>
<td style="text-align:center">\Leftrightarrow</td>
<td style="text-align:center">$\Longrightarrow$</td>
<td style="text-align:center">\Longrightarrow</td>
</tr>
<tr>
<td style="text-align:center">$\uparrow$</td>
<td style="text-align:center">\uparrow</td>
<td style="text-align:center">$\downarrow$</td>
<td style="text-align:center">\downarrow</td>
<td style="text-align:center">$\updownarrow$</td>
<td style="text-align:center">\updownarrow</td>
<td style="text-align:center">$\Uparrow$</td>
<td style="text-align:center">\Uparrow</td>
</tr>
<tr>
<td style="text-align:center">$\mapsto$</td>
<td style="text-align:center">\mapsto</td>
<td style="text-align:center">$\rightharpoonup$</td>
<td style="text-align:center">\rightharpoonup</td>
<td style="text-align:center">$\nearrow$</td>
<td style="text-align:center">\nearrow</td>
<td style="text-align:center">$\searrow$</td>
<td style="text-align:center">\searrow</td>
</tr>
</tbody>
</table>
</div>
<h2 id="数学字母"><a href="#数学字母" class="headerlink" title="数学字母"></a>数学字母</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">实例</th>
<th style="text-align:center">Latex代码</th>
<th style="text-align:center">所需宏包</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\mathrm{ABCD abcd 1234}$</td>
<td style="text-align:center">\mathrm{ABCD abcd 1234}</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">$\mathit{ABCD abcd 1234}$</td>
<td style="text-align:center">\mathit{ABCD abcd 1234}</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">$\mathnormal{ABCD abcd 1234}$</td>
<td style="text-align:center">\mathnormal{ABCD abcd 1234}</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">$\mathcal{ABCD abcd 1234}$</td>
<td style="text-align:center">\mathcal{ABCD abcd 1234}</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">$\mathscr{ABCD abcd 1234}$</td>
<td style="text-align:center">\mathscr{ABCD abcd 1234}</td>
<td style="text-align:center">mathrsfs</td>
</tr>
<tr>
<td style="text-align:center">$\mathfrak{ABCD abcd 1234}$</td>
<td style="text-align:center">\mathfrak{ABCD abcd 1234}</td>
<td style="text-align:center">amsfont or amssymb</td>
</tr>
<tr>
<td style="text-align:center">$\mathbb{ABCD abcd 1234}$</td>
<td style="text-align:center">\mathbb{ABCD abcd 1234}</td>
<td style="text-align:center">amsfonts or amssmb</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>tutorials</category>
      </categories>
      <tags>
        <tag>Latex</tag>
      </tags>
  </entry>
  <entry>
    <title>步态分析 1 - 背景知识</title>
    <url>/2022/03/01/1-Course/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%90/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%901-%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<span id="more"></span>
<p>人体自主运动，都是由大脑、脊髓、周围神经、肌肉、骨骼和关节的复杂过程产生的。在分析步态运动的详细过程之前，有必要对解剖学、生理学和生物力学有一些基础的了解。本部分仅简单介绍解剖学基本术语，其他基础知识请参考博主其他博客。</p>
<h2 id="解剖学基本术语"><a href="#解剖学基本术语" class="headerlink" title="解剖学基本术语"></a>解剖学基本术语</h2><p>解剖学姿态(<em>anatomical position</em>)，用于定义参考平面以及描述人体不同肢体之间的相对位置关系，其中人要站直，两脚平行，双臂置于身体两侧，手心向前。</p>
<img src="/2022/03/01/1-Course/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%90/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%901-%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86/01.png" class title="PS01.png">
<img src="/2022/03/01/1-Course/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%90/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%901-%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86/02.png" class title="未标题-2.png">
<h3 id="方向定义（以身体为中心）"><a href="#方向定义（以身体为中心）" class="headerlink" title="方向定义（以身体为中心）"></a>方向定义（以身体为中心）</h3><ul>
<li><strong>前方(anterior)</strong>：肚脐朝向</li>
<li><strong>后方(posterior)</strong>：臀部朝向</li>
<li><strong>上方(superior)</strong>：头部朝向</li>
<li><strong>下方(inferior)</strong>：足部朝向</li>
<li><strong>左侧(left)</strong>：自明</li>
<li><strong>右侧(right)</strong>：自明</li>
</ul>
<h3 id="肢体相对关系"><a href="#肢体相对关系" class="headerlink" title="肢体相对关系"></a>肢体相对关系</h3><ul>
<li><strong>内侧(medial)</strong>：表示朝向身体中线：大脚趾位于脚的内侧</li>
<li><strong>外侧(lateral)</strong>：表示远离身体中线：小脚趾位于脚的外侧</li>
<li><strong>近端(proximal)</strong>：表示朝向身体的其他部分：肩膀在手臂的近端</li>
<li><strong>末端(diatal)</strong>：表示原理身体的其他部分：手指在手的末端</li>
<li><strong>表层结构(superficial structures)</strong>：指靠近表面</li>
<li><strong>深层结构(deep structures)</strong>：指远离表面</li>
</ul>
<h3 id="参考平面（描述肢体运动）"><a href="#参考平面（描述肢体运动）" class="headerlink" title="参考平面（描述肢体运动）"></a>参考平面（描述肢体运动）</h3><ul>
<li><strong>矢状面(sagittal plane)</strong>：将身体分为左右两部分</li>
<li><strong>前视面(frontal plane)</strong>：将身体分为前后两个部分</li>
<li><strong>横截面(transverse plane)</strong>：将身体分为上下两个部分</li>
</ul>
<h3 id="关节运动"><a href="#关节运动" class="headerlink" title="关节运动"></a>关节运动</h3><ul>
<li><strong>弯曲(Flexion)/伸展(Extension)</strong>：发生在矢状面<ul>
<li>发生在脚踝处的弯曲和伸展称为<strong>背屈(Dorsiflexion)和跖屈(Plantarflexion)</strong></li>
</ul>
</li>
<li><strong>外展(Abduction)和内收(Adduction)</strong>：发生在前视面</li>
<li><strong>内转(Internal/Medial rotation)和外旋(External/Lateral rotation)</strong>：发生在横截面</li>
<li><strong>内翻(Varus)和外翻(Valgus)</strong>：用来描述关节靠近和远离中线的回转角度<ul>
<li>X形腿(<strong>knock leg</strong>)为膝内翻，O形腿(<strong>bow leg</strong>)为膝外翻</li>
</ul>
</li>
<li><strong>足内翻(Inversion)和足外翻(Eversion)</strong>：内翻使得脚底靠近，外翻使得脚底远离中线</li>
<li><strong>旋前(Pronation)和旋后(Supination)</strong>：是围绕前臂或足的长轴的旋转<ul>
<li>双手旋前使得拇指靠拢，旋后使得小指靠拢</li>
</ul>
</li>
</ul>
<h2 id="下肢骨骼与肌肉"><a href="#下肢骨骼与肌肉" class="headerlink" title="下肢骨骼与肌肉"></a>下肢骨骼与肌肉</h2><img src="/2022/03/01/1-Course/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%90/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%901-%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86/03.png" class title="未标题-20.png">]]></content>
      <categories>
        <category>biomechanics</category>
      </categories>
      <tags>
        <tag>步态分析</tag>
      </tags>
  </entry>
  <entry>
    <title>控制理论 01 - 线性代数基础</title>
    <url>/2022/01/01/1-Course/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA_%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<img src="/2022/01/01/1-Course/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA_%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/01.png" class title="Untitled">
<span id="more"></span>
<h2 id="1-线性子空间"><a href="#1-线性子空间" class="headerlink" title="1 - 线性子空间"></a>1 - 线性子空间</h2><ul>
<li>线性组合：$\alpha_1 x_1+\alpha_2 x_2+\dots+\alpha_k x_k,x_i\in F^n,\alpha_i \in F$</li>
<li>线性相关：如果存在$\alpha_1,\dots,\alpha_k \in F$ 不全为零，使得$\alpha_1 x_1 + \dots + \alpha_k x_k=0$，则$x_1,\dots,x_i\in F^n$线性相关；否则线性无关</li>
<li>线性子空间：$span\{x_1,\dots,x_k\}:=\{x=\alpha_1 x_1+\alpha_2 x_2+\dots+\alpha_k x_k,\alpha_i \in F\}$<ul>
<li>线性空间的基：如果$x_1,\dots,x_i\in F^n$线性无关，并且$S=span\{x_1,\dots,x_k\}$，则$\{x_1,\dots,x_k\} \in S$是$S$的一组基</li>
<li>正交基(<strong>垂直向量组</strong>)：如果对于所有的$i \ne j$，有$x_i \cdot x_j=0$，则$x_1,\dots,x_i\in F^n$是相互正交的；如果有$x_i \cdot x_j=\delta_{ij}$，则为标准正交基</li>
<li>正交补：子空间$S\subseteq F^n$的正交补 $S^{\bot}:=\{y\in F^n:y\cdot x=0, \forall x\in S \}$</li>
</ul>
</li>
<li>线性变换：$A:F^n\to F^m$，任意矩阵都可以看作是一个线性变换<ul>
<li>线性变换的零空间/核(kernel or null space)：$KerA=N(A):=\{x\in F^n:Ax=0\}$</li>
<li>线性变换的相空间(image or range of A)：$ImA=R(A):=\{y\in f^m:y=Ax,x\in F^n\}$</li>
<li>相空间与变换矩阵：令$a_i,i=1,2,\dots,n$为矩阵$A\in F^{m\times n}$的列，则$ImA=span\{a_1,a_2,\dots,a_n\}$</li>
</ul>
</li>
<li><p>秩：矩阵$A$的秩的定义为$rank(A)=dim(ImA)$ <strong>不相关向量的个数</strong></p>
<ul>
<li>$rank(A)=rank(A^T)$</li>
<li>行满秩：$A \in F^{m\times n}$，如果$m\le n$，并且$rank(A)=m$</li>
<li>列满秩：$A \in F^{m\times n}$，如果$n\le m$，并且$rank(A)=n$</li>
<li><p>秩不等式：<strong>(矩阵相乘的秩不会增加)</strong> 令$A\in F^{m\times n},B\in F^{n\times k}$，则</p>
<p>$rank(A)+rank(B)-n \le rank(AB)\le min\{rank(A),rank(B) \}$ </p>
</li>
</ul>
</li>
<li>迹：矩阵$A=[a_{ij}]\in C^{n\times n}$的迹$Trace(A):=\sum a_{ii}$<ul>
<li>$Trace(\alpha A)=\alpha Trace(A),\forall \alpha\in C,A\in C^{n\times n}$</li>
<li>$Trace(A+B)=Trace(A)+Trace(B)$</li>
<li>$Trace(AB)=Trace(BA),\forall A\in C^{n\times m},B\in C^{m \times n}$</li>
</ul>
</li>
<li>酉矩阵： $ U^{T}U=I=UU^{T} $  <strong>(行\列向量相互正交的方阵)</strong><ul>
<li>令 $D\in F^{n \times k}$ 使得 $D^TD=I$，则存在$D_\perp\in F^{n\times (n-k)}$，使得$[D,D_\perp]$是一个酉矩阵 <strong>(D是一个酉矩阵的切片)</strong></li>
</ul>
</li>
<li><strong>Sylvester方程：</strong>$AX+XB=C$<ul>
<li>其中$A\in F^{n\times n},B\in F^{m\times m},c\in F^{n\times m}$</li>
<li>当且仅当$\lambda_i(A)+\lambda_j(B)\ne0,\forall i=1,2,\dots,n,\quad j=1,2,\dots,m$，有唯一的解$X\in F^{n\times m}$</li>
</ul>
</li>
<li><strong>Lyapunov方程：$AX+XA^T=C$</strong><ul>
<li>若要有唯一的解$X\in F^{n\times m}$，$A$不能有关于Y轴镜像的特征值</li>
<li>特殊情况：A的所有特征值都在左半平面</li>
</ul>
</li>
</ul>
<h2 id="2-特征值与特征向量"><a href="#2-特征值与特征向量" class="headerlink" title="2 - 特征值与特征向量"></a>2 - 特征值与特征向量</h2><ul>
<li><p>$A\in C^{n\times n}$特征值与特征向量：$\lambda\in C,x\in C^n$，有$Ax=\lambda x$</p>
<ul>
<li>$\lambda$为特征值，$x$为右特征向量<strong>(左特征向量：$y^TA=\lambda y^T$)</strong></li>
<li>特征值：$det(\lambda I-A)$的根</li>
<li>谱半径：$\rho(A):=max|\lambda_i|$</li>
<li><p>约当<strong>标准型</strong>：$A\in C^{n\times n},\exists T$，使得$A=TJT^{-1}$</p>
<script type="math/tex; mode=display">
  J=diag\{J_1,J_2,\dots,J_l\}</script><script type="math/tex; mode=display">
  J_i=diag\{J_{i1},J_{i2},\dots,J_{im_i}\}</script><script type="math/tex; mode=display">
  J_{ij}=
  \begin{bmatrix}
  \lambda_i & 1 & \ & \ & \ \\
  \ & \lambda_i & 1 & \ & \ \\
  \ & \ & \dots & \dots & \ \\
  \ & \ & \ & \lambda_i & 1 \\
  \ & \ & \ & \ & \lambda_i
  \end{bmatrix}</script></li>
<li><p><strong>对角标准型</strong>：当$A\in R^{n\times n}$具有各不相同的特征值时，A具有对角标准型：</p>
<script type="math/tex; mode=display">
  A[x_1,x_2,\dots,x_n]=[x_1,x_2,\dots,x_n]
  \begin{bmatrix}
  \lambda_1 & \ & \ & \ \\
  \ & \lambda_2 & \ & \ \\
  \ & \ & \dots & \ \\
  \ & \ & \ & \lambda_n
  \end{bmatrix}</script></li>
<li><p><strong>谱分解</strong>：$A=\sum \lambda_i x_i y_i^T$，其中$y_i\in C^n$，$[y_1^T,y_2^T,\dots,y_n^T]^T=[x_1,x_2,\dots,x_n]^{-1}$</p>
</li>
<li><strong>实特征值</strong>：$A\in R^{n\times n}$具有实特征值$\lambda\in R$时，相应的特征向量也是实向量$x\in R^n$</li>
<li>$Hermitian$<strong>矩阵的标准型</strong>：当$A$是$Hermitian$矩阵时($A=A^T$，对称矩阵/共轭矩阵)，存在酉矩阵$U$使得$A=U\Lambda U^T$，并且$\Lambda=diag\{\lambda_1,\lambda_2,\dots,\lambda_n\}$是实的</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-矩阵逆公式"><a href="#3-矩阵逆公式" class="headerlink" title="3 - 矩阵逆公式"></a>3 - 矩阵逆公式</h2><ul>
<li><strong>逆矩阵公式1</strong></li>
</ul>
<script type="math/tex; mode=display">
\Delta=A_{22}-A_{21}A_{11}^{-1}A_{12}</script><script type="math/tex; mode=display">
\begin{bmatrix}
A_{11} & A_{12} \\
A_{21} & A_{22}
\end{bmatrix} =
\begin{bmatrix}
I & 0 \\
A_{21}A_{11}^{-1} & I
\end{bmatrix}
\begin{bmatrix}
A_{11} & 0 \\
0 & \Delta
\end{bmatrix}
\begin{bmatrix}
I & A_{11}^{-1}A_{12} \\
0 & I
\end{bmatrix}</script><script type="math/tex; mode=display">
\begin{bmatrix}
A_{11} & A_{12} \\
A_{21} & A_{22}
\end{bmatrix}^{-1} =
\begin{bmatrix}
A_{11}^{-1}+A_{11}^{-1}A_{12}\Delta^{-1}A_{21}A_{11}^{-1} & -A_{11}^{-1}A_{12}\Delta^{-1} \\
-\Delta^{-1}A_{21}A_{11}^{-1} & \Delta^{-1}
\end{bmatrix}</script><ul>
<li><strong>逆矩阵公式2</strong></li>
</ul>
<script type="math/tex; mode=display">
\hat\Delta=A_{11}-A_{12}A_{22}^{-1}A_{21}</script><script type="math/tex; mode=display">
\begin{bmatrix}
A_{11} & A_{12}\\
A_{21} & A_{22}
\end{bmatrix} =
\begin{bmatrix}
I & A_{12}A_{22}^{-1}\\
0 & I
\end{bmatrix}
\begin{bmatrix}
\hat\Delta & 0 \\
0 & A_{22}
\end{bmatrix}
\begin{bmatrix}
I & 0\\
A^{-1}_{22}A_{21} & I
\end{bmatrix}</script><script type="math/tex; mode=display">
\begin{bmatrix}
A_{11} & A_{12}\\
A_{21} & A_{22}
\end{bmatrix}^{-1} =
\begin{bmatrix}
\hat\Delta^{-1} & -\hat\Delta^{-1}A_{12}A_{22}^{-1} \\ -A_{22}^{-1}A_{21}\hat\Delta^{-1} & A_{22}^{-1}+A_{22}^{-1}A_{21}\hat\Delta^{-1}A_{12}A_{22}^{-1}
\end{bmatrix}</script><ul>
<li><strong>逆矩阵公式3</strong></li>
</ul>
<script type="math/tex; mode=display">
\begin{bmatrix}
A_{11} & x\\
y^T & 1
\end{bmatrix}^{-1} =
\begin{bmatrix}
A_{11}^{-1}+A_{11}^{-1}x\Delta^{-1}y^TA_{11}^{-1} & -A_{11}^{-1}x\Delta^{-1}\\
 -\Delta^{-1}y^TA_{11}^{-1} & \Delta^{-1}
\end{bmatrix},\quad\Delta=1-y^TA_{11}^{-1}x</script><script type="math/tex; mode=display">
\begin{aligned}
&{\left[\begin{array}{cc}
A_{11} & 0 \\
A_{21} & A_{22}
\end{array}\right]^{-1}=\left[\begin{array}{cc}
A_{11}^{-1} & 0 \\
-A_{22}^{-1} A_{21} A_{11}^{-1} & A_{22}^{-1}
\end{array}\right],\quad\left[\begin{array}{cc}
I & 0 \\
X & I
\end{array}\right]^{-1}=\left[\begin{array}{cc}
I & 0 \\
-X & I
\end{array}\right]} \\
&{\left[\begin{array}{cc}
A_{11} & A_{12} \\
0 & A_{22}
\end{array}\right]^{-1}=\left[\begin{array}{cc}
A_{11}^{-1} & -A_{11}^{-1} A_{12} A_{22}^{-1} \\
0 & A_{22}^{-1}
\end{array}\right],\quad\left[\begin{array}{cc}
I & X \\
0 & I
\end{array}\right]^{-1}=\left[\begin{array}{cc}
I & -X \\
0 & I
\end{array}\right]}
\end{aligned}</script><ul>
<li><p><strong>逆矩阵公式4</strong></p>
<script type="math/tex; mode=display">
(A_{11}-A_{12}A_{22}^{-1}A_{21})^{-1}=A_{11}^{-1}+A_{11}^{-1}A_{12}(A_{22}-A_{21}A_{11}^{-1}A_{12})^{-1}A_{21}A_{11}^{-1}</script><script type="math/tex; mode=display">
(A_{11}-xy^T)^{-1}=A_{11}^{-1}+\frac{A_{11}^{-1}xy^TA_{11}^{-1}}{1-y^TA_{11}^{-1}x}</script></li>
<li><p><strong>分块矩阵的行列式定理</strong></p>
</li>
</ul>
<script type="math/tex; mode=display">
\operatorname{det} A=\operatorname{det} A_{11} \operatorname{det}\left(A_{22}-A_{21} A_{11}^{-1} A_{12}\right)=\operatorname{det} A_{22} \operatorname{det}\left(A_{11}-A_{12} A_{22}^{-1} A_{21}\right)</script><script type="math/tex; mode=display">
\operatorname{det}\left[\begin{array}{cc}
I_{m} & B \\
-C & I_{n}
\end{array}\right]=\operatorname{det}\left(I_{n}+C B\right)=\operatorname{det}\left(I_{m}+B C\right)</script><script type="math/tex; mode=display">
\operatorname{det}\left(I_{n}+x y^{*}\right)=1+y^{*} x</script><hr>
<h2 id="4-不变子空间"><a href="#4-不变子空间" class="headerlink" title="4 - 不变子空间"></a>4 - 不变子空间</h2><ul>
<li>一个子空间$S\subset C^n$是一个$A$-不变子空间，如果对于每一个$x\in S$，有$Ax\in S$。</li>
<li>特别的，令$\lambda,x$为$A\in C^{n\times n}$的特征值和特征向量，则$S:=span\{x\}$是$A$-不变子空间（$Ax=\lambda x \in S$）</li>
<li>稳定不变子空间：若$A$-不变子空间$S\subset C^n$所有特征值的都具有负实部（稳定不变子空间将用于计算代数黎卡提方程的镇定解）</li>
</ul>
<hr>
<h2 id="5-向量范数与矩阵范数"><a href="#5-向量范数与矩阵范数" class="headerlink" title="5 - 向量范数与矩阵范数"></a>5 - 向量范数与矩阵范数</h2><ul>
<li>范数：令X为一个向量空间，$||\cdot||$为一个范数，如果<ul>
<li>$||x||\ge 0$</li>
<li>$||x||=0\quad if\ and \ only \ if \quad x=0$</li>
<li>$||\alpha x||=|\alpha|\cdot||x||$</li>
<li>$||x+y||\le||x||+||y||$</li>
</ul>
</li>
<li><p>$p$ -范数，$p$-范数诱导的矩阵范数</p>
<script type="math/tex; mode=display">
  \|x\|_{p}:=\left(\sum_{i=1}^{n}\left|x_{i}\right|^{p}\right)^{1 / p}, \text { for } 1 \leq p \leq \infty \\
  \|A\|_{p}:=\sup _{x \neq 0} \frac{\|A x\|_{p}}{\|x\|_{p}}</script></li>
<li><p>特别的，当$p=1,2,\infty$，有</p>
<script type="math/tex; mode=display">
  \|x\|_{1}:=\sum_{i=1}^{n}\left|x_{i}\right|, \quad\|x\|_{2}:=\sqrt{\sum_{i=1}^{n}\left|x_{i}\right|^{2}}, \quad\|x\|_{\infty}:=\max _{1 \leq i \leq n}\left|x_{i}\right|</script><script type="math/tex; mode=display">
  \|A\|_{1}:=\max _{1 \leq i \leq n} \sum_{i=1}^{m}\left|a_{i j}\right| ,\quad
  \|A\|_{2}=\sqrt{\lambda_{\max }\left(A^{*} A\right)},\quad
  \|A\|_{\infty}:=\max _{1 \leq i \leq m} \sum_{j=1}^{n}\left|a_{i j}\right|</script></li>
<li><p>$Frobenius$范数</p>
</li>
</ul>
<script type="math/tex; mode=display">
\|A\|_{F}:=\sqrt{\operatorname{Trace}\left(A^{*} A\right)}=\sqrt{\sum_{i=1}^{m} \sum_{j=1}^{n}\left|a_{i j}\right|^{2}}</script><ul>
<li>范数的性质<ul>
<li>假设$n\ge m$，那么$||x||=||y||$当且仅当有一个酉矩阵$U\in F^{n\times m}$使得$x=Uy$</li>
<li>假设$n=m$，那么$||x^Ty||\le||x^T||\cdot ||y||$，等号的成立条件为$x=\alpha y$或者$y=0$</li>
<li>$||x||\le||y||$当且仅当一个矩阵$\Delta\in F^{n\times m}$，$||\Delta||\le 1$使得$x=\Delta y$</li>
<li>$||Ux||=||x||$，其中$U$为酉矩阵</li>
<li>$||UAV||=||A||,||UAV||_F=||A||_F$，其中$U,V$为酉矩阵</li>
<li>$||AB||\le ||A||\cdot ||B||$，特别的，如果$A$可逆，则有$||A^{-1}||\ge||A||^{-1}$</li>
<li>$||AB||_F\le||A||\cdot||B||_F,||AB||_F\le||B||\cdot||A||_F$</li>
<li>$\rho(A)\le||A||$</li>
</ul>
</li>
</ul>
<hr>
<h2 id="6-奇异值分解"><a href="#6-奇异值分解" class="headerlink" title="6 - 奇异值分解"></a>6 - 奇异值分解</h2><ul>
<li><p>令$A\in F^{m\times n}$，存在酉矩阵$U=[u_1,u_2,\dots,u_m]\in F^{m\times m},V=[v_1,v_2,\dots,v_n]\in F^{n\times n}$，使得</p>
<script type="math/tex; mode=display">
  A=U\Sigma V^T,\quad \Sigma=\begin{bmatrix}
  \Sigma_1 & 0\\
  0 & 0
  \end{bmatrix}</script><p>  其中$\Sigma_1=diag(\sigma_1,\sigma_2,\dots,\sigma_p),\quad\sigma_1\ge\sigma_2\ge\dots\ge\sigma_p$</p>
</li>
<li><p>奇异值分解的特性</p>
<ul>
<li>$Av_i=\sigma_iu_i,\ A^Tu_i=\sigma_iv_i$(奇异值方程)</li>
<li>$A^TAv_i=\sigma^2_iv_i,\ AA^Tu_i=\sigma_i^2u_i$(特征值方程)</li>
</ul>
</li>
<li><p>奇异值分解的解释</p>
<ul>
<li>奇异值是矩阵“大小”的很好度量</li>
<li>奇异向量是矩阵“强弱”输入或输出方向的很好指标</li>
<li>几何上来说，一个矩阵的奇异值就是由下列定义的超椭圆的半轴长，$E:\{y:y=Ax,x\in C^n,||x||=1\}$<br>，因此$v_1$是使得$||y||$对所有$||x||=1$最大的方向，而$v_n$是使得$||y||$对所有$||x||=1$最小的方向</li>
<li><p>$v_1(v_n)$是最高(最低)增益输入方向，$u_1(u_n)$是最高(最低)增益的观测(输出)方向</p>
  <img src="/2022/01/01/1-Course/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA_%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/02.png" class title="Untitled">
</li>
</ul>
</li>
<li><p>奇异值的特性</p>
<ul>
<li>奇异值的另类定义：$\bar{\sigma}(A):=\max _{|x|=1}|A x|,\ \underline{\sigma}(A):=\min _{|x|=1}|A x|$</li>
<li>假设$A,\Delta$为方阵，则有如下定理：<ul>
<li>$|\underline\sigma(A+\Delta)-\underline\sigma(A)|\le\bar\sigma(\Delta)$</li>
<li>$\underline\sigma(A\Delta)\ge\underline\sigma(A)\underline\sigma(\Delta)$</li>
<li>$\bar\sigma(A^{-1})=\frac{1}{\underline\sigma(A)}$，如果$A$是可逆的</li>
<li>对于扰动$\Delta$，当$\bar\sigma(\Delta)\le\underline\sigma(A)$时，$A+\Delta$是非奇异的</li>
</ul>
</li>
<li>令$A\in F^{m\times n}$，并且$\sigma_1\ge\sigma_2\ge\dots\ge\sigma_r&gt;\sigma_{r+1}=\dots=0$，$r\le \min\{m,n\}$，则有<ul>
<li>$rank(A)=r$</li>
<li>$Ker \ A=span\{v_{r+1},v_{r+2},\dots,v_{n}\},\ (Ker \ A)^{\bot}=span\{v_1,v_2,\dots,v_r\}$</li>
<li>$Im \ A=span\{u_1,u_2\dots,u_r\},\ (Im\ A)^\bot=span\{u_{r+1},u_{r+2},\dots,u_{m}\}$</li>
<li>$A$的<strong>dyadic</strong>(双积)展开：$A=\sum_{i=1}^{r}\sigma_iu_iv_i^T=U_r\Sigma_rV_r^T$</li>
<li>$||A||_F^2=\sigma_1^2+\sigma_2^2+\dots+\sigma_r^2,\ \ ||A||=\sigma$</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="7-伪逆"><a href="#7-伪逆" class="headerlink" title="7 - 伪逆"></a>7 - 伪逆</h2><ul>
<li>左逆与右逆：令$A\in F^{m\times n}$，如果$AX=I$，则$X\in F^{n\times m}$是$A$的一个右逆；若$YA=I$，则$Y$是$A$的一个左逆；</li>
<li>左逆与右逆不唯一，A的一个右逆为$X=A^T(AA^T)^{-1}$</li>
<li>伪逆(Moore-Penrose逆) $A^+$:<ul>
<li>$AA^+A=A,\ A^+AA^+=A^+$</li>
<li>$(AA^+)^T=AA^+,\ (A^+A)^T=A^+A$</li>
<li>伪逆是唯一的</li>
</ul>
</li>
<li>伪逆的计算<ul>
<li>$A=BC,\ A^+=C^{T}\left(C C^{T}\right)^{-1}(B^T B)^{-1} B^T$</li>
<li>$A=U\Sigma V^T,\ A^+=V\Sigma^+U^T$</li>
</ul>
</li>
</ul>
<hr>
<h2 id="8-半正定矩阵"><a href="#8-半正定矩阵" class="headerlink" title="8 - 半正定矩阵"></a>8 - 半正定矩阵</h2><ul>
<li>半正定矩阵主要用于分析二次型问题，任何二次型都有$x^TAx=\frac{1}{2}x^TAx+\frac{1}{2}x^TA^Tx=\frac{1}{2}x^T(A+A^T)x$，因此仅分析Hermitian矩阵的正定性</li>
<li>定义：对于$Hermitian$矩阵$A=A^T$，如果对于所有$x\ne0,\ x^TAx&gt;0$，则称$A$是正定的，记为$A&gt;0$；若$x^TAx\ge0$，则为半正定的</li>
<li>$A\in F^{n\times n}$并且$A=A^T\ge0$，则存在$B\in F^{n\times r},\ r\ge rank(A)$使得$A=BB^T$</li>
<li>半正定矩阵的平方根：$A^{1/2}=(A^{1/2})^T$使得$A=A^{1/2}A^{1/2}=(A^{1/2})^2$<ul>
<li>根据谱分解$A=U\Lambda U^T$，则有$A^{1/2}=U\Lambda^{1/2} U^T,\ \Lambda^{1/2}=diag\{\lambda_1^{1/2},\lambda_2^{1/2},\dots,\lambda_n^{1/2}\}$</li>
</ul>
</li>
<li>若$A&gt;0,\ B\ge 0$，则$A&gt;B \ (A-B&gt;0)$当且仅当$\rho(BA^{-1})&lt;1$</li>
</ul>
]]></content>
      <categories>
        <category>control</category>
      </categories>
      <tags>
        <tag>Course</tag>
      </tags>
  </entry>
  <entry>
    <title>步态分析 4 - 步态循环详述 Detail</title>
    <url>/2022/03/01/1-Course/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%90/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%904-%E6%AD%A5%E6%80%81%E5%BE%AA%E7%8E%AF%E8%AF%A6%E8%BF%B0/</url>
    <content><![CDATA[<p>下面将根据步态循环中的典型事件和典型阶段，详细介绍在步态运动中<strong>上肢(upper body)、髋关节(hip)、膝关节(knee)、踝关节(ankle)、足部(feet)，</strong>在<strong>角度、力矩、功率、能量、肌肉活动</strong>方面的经历的过程和变化。</p>
<img src="/2022/03/01/1-Course/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%90/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%904-%E6%AD%A5%E6%80%81%E5%BE%AA%E7%8E%AF%E8%AF%A6%E8%BF%B0/01.png" class title="未标题-8.png">
<span id="more"></span>
<h2 id="初始接触-Initial-Contact"><a href="#初始接触-Initial-Contact" class="headerlink" title="初始接触 - Initial Contact"></a>初始接触 - Initial Contact</h2><h3 id="概括"><a href="#概括" class="headerlink" title="概括"></a><strong>概括</strong></h3><ul>
<li>初始接触(initial contact)是支撑初期/承重反应期(loading response)的开始，通常也被称为<strong>脚跟着地(heelstrike/foot contact)</strong>，通常会存在明显的脚和地面之间的撞击；</li>
<li><strong>此时的地反力几乎竖直向上的(upward)</strong>，在随后的支撑初期/承重加载阶段(loading response)地反力的方向迅速向后移动，这一点可以在图2.8的地反力<strong>蝴蝶图</strong>中观察到；</li>
</ul>
<h3 id="上肢"><a href="#上肢" class="headerlink" title="上肢"></a><strong>上肢</strong></h3><ul>
<li>初始接触时，躯干(trunk)距离前腿(leading leg)一半的步长(stride length)；</li>
<li>在左右方向上，<strong>躯干正穿过横向运动的中线(midline)</strong>，并向前腿(这里是右侧)一侧移动；</li>
<li>躯干处于<strong>扭转状态(twisted</strong>)，<strong>左肩和骨盆的右侧处于前方</strong>，左手也摆至前；</li>
</ul>
<h3 id="髋"><a href="#髋" class="headerlink" title="髋"></a><strong>髋</strong></h3><ul>
<li>髋关节在摆动中期达到<strong>最大弯曲角(flexion, 约$30^\circ$)</strong>，一直到初始接触前几乎不发生变化；</li>
<li>在摆动相后期<strong>腘绳肌(hamstrings)处于激活状态</strong>，防止<strong>膝关节过度伸展(hyperextension)</strong>;</li>
<li><strong>臀大肌(gluteus maximus)</strong>在初始接触时刻开始收缩，带动伸展髋关节，见图2.9；</li>
</ul>
<h3 id="膝"><a href="#膝" class="headerlink" title="膝"></a><strong>膝</strong></h3><ul>
<li>膝关节在摆动相末<strong>迅速伸展变直(straight)</strong>，并在初始接触前开始略微弯曲(flex)，图2.5；</li>
<li>膝关节在摆动相的<strong>伸展通常认为是被动的(passive)</strong>，是重力和大腿带动下自然的摆动；</li>
<li>摆动相末期<strong>腘绳肌(hamstrings)处于激活状态</strong>，防止膝关节过度伸展，但在慢速行走时可能没有该现象；</li>
</ul>
<h3 id="踝足"><a href="#踝足" class="headerlink" title="踝足"></a><strong>踝足</strong></h3><ul>
<li>初始接触时<strong>踝关节角度接近中性位置</strong>，由于胫骨向后，因此足部向前倾斜，只有脚跟着地；</li>
<li>此时足部通常<strong>轻微的旋后(supinated)</strong>，因此大部分人<strong>鞋跟外侧有磨损痕迹(wear pattern)</strong>；</li>
<li><strong>胫骨前肌(tibialis anterior)</strong>在整个摆动相和支撑相早期都是激活状态，为初始接触之后踝关节的跖屈(plantarflexion)做准备(<strong>拮抗收缩，防止脚掌拍击地面</strong>)；</li>
</ul>
<h3 id="力矩与功率："><a href="#力矩与功率：" class="headerlink" title="力矩与功率："></a><strong>力矩与功率</strong>：</h3><ul>
<li><strong>髋关节</strong>存在由<strong>髋关节伸肌(hip extensor)产生的伸展力矩</strong>(如臀大肌、腘绳肌)，在随后髋关节伸展过程，这些<strong>肌肉向心收缩(contract conentrically)并产生能量</strong>，图2.6、2.7、2.9；</li>
<li><strong>膝关节</strong>存在一个由腘绳肌产生的<strong>屈膝力矩(internal flexor moment)</strong>，防止膝关节过度伸展；由于此时腘<strong>伸肌的收缩</strong>、<strong>膝关节的屈膝</strong>，以及来自<strong>韧带(ligament)能量释放</strong>，膝关节在初始接触时展现出一个<strong>功率输出的峰值</strong>，见图2.7；</li>
<li><strong>踝关节</strong>在初始着地之前几乎不存在能量交换，但由于脚跟与地面的撞击(heelstrike)，<strong>大部分动能在碰撞的过程中损失</strong>，少部分被足部组织和鞋低的弹性材料存储。</li>
</ul>
<h2 id="支撑初期-Loading-Response"><a href="#支撑初期-Loading-Response" class="headerlink" title="支撑初期 - Loading Response"></a>支撑初期 - Loading Response</h2><h3 id="概括-1"><a href="#概括-1" class="headerlink" title="概括"></a><strong>概括</strong></h3><ul>
<li>支撑初期/承重反应期是初始接触(IC)和对侧趾尖离地(Opposite Toe Off)之间的<strong>双支撑阶段</strong>，通常占据<strong>步态周期的前10%~12%</strong>；在此期间，踝关节跖屈将整个足部放平在地面上，同时地反力迅速增加；</li>
</ul>
<h3 id="上肢-1"><a href="#上肢-1" class="headerlink" title="上肢"></a><strong>上肢</strong></h3><ul>
<li>躯干在支撑初期<strong>处于竖直最低位置</strong>，比整个循环的平均水平位置低约20mm；而<strong>瞬时前进速度是最大</strong>的，比真个周期的平均速度高10%；左右方向上持续向右脚外侧移动；</li>
<li>手臂到达最前和最后的位置，并开始向相反的方向摆动；</li>
</ul>
<h3 id="髋-1"><a href="#髋-1" class="headerlink" title="髋"></a><strong>髋</strong></h3><ul>
<li>在整个支撑初期，<strong>髋关节的伸肌(臀大肌、腘绳肌)同心收缩(concentric contraction)</strong>；</li>
</ul>
<h3 id="膝-1"><a href="#膝-1" class="headerlink" title="膝"></a><strong>膝</strong></h3><ul>
<li>膝关节在初始接触(IC)时几乎完全伸展，并<strong>在支撑初期开始弯曲(stance phase flexion)</strong>；</li>
<li><strong>股四头肌(quadriceps)离心收缩(eccentric contraction)</strong>，限制膝关节弯曲速度和角度；</li>
</ul>
<h3 id="踝足-1"><a href="#踝足-1" class="headerlink" title="踝足"></a><strong>踝足</strong></h3><ul>
<li><strong>踝关节通过跖屈将足部放平在地面上</strong>，同时伴有一定的足部旋前(pronation)和胫骨内旋(internal rotation)；</li>
<li>跖屈时<strong>胫骨前肌离心收缩</strong>，使脚掌轻轻贴近地面；若胫骨前肌不能产生足够的力矩，则足部会过快跖屈，拍击地面产生可以听见的足拍声(foot slap);</li>
</ul>
<h3 id="力矩与功率"><a href="#力矩与功率" class="headerlink" title="力矩与功率"></a><strong>力矩与功率</strong></h3><ul>
<li>在支撑初期，<strong>髋关节存在伸展力矩并产生能量，膝关节存在一个屈膝力矩并也产生能量</strong>；</li>
<li>地反力的外部跖屈力矩使<strong>踝关节存在一个内部背屈力矩，胫骨前肌离心收缩，并吸收能量</strong>；</li>
</ul>
<hr>
<img src="/2022/03/01/1-Course/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%90/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%904-%E6%AD%A5%E6%80%81%E5%BE%AA%E7%8E%AF%E8%AF%A6%E8%BF%B0/02.png" class title="未标题-9.png">
<h2 id="对侧趾尖离地-Opposite-Toe-Off"><a href="#对侧趾尖离地-Opposite-Toe-Off" class="headerlink" title="对侧趾尖离地  - Opposite Toe Off"></a>对侧<strong>趾尖</strong>离地  - Opposite Toe Off</h2><h3 id="概括-2"><a href="#概括-2" class="headerlink" title="概括"></a><strong>概括</strong></h3><ul>
<li>对侧趾尖离地意味着<strong>双支撑阶段的结束</strong>，标志支撑中期(mid-stance)的开始，此时<strong>脚掌已经完全接触地面(foot flat/forefoot contact)</strong>：对于对侧而言，它标志着支撑相的接触，以及摆动相的开始；</li>
</ul>
<h3 id="上肢-2"><a href="#上肢-2" class="headerlink" title="上肢"></a><strong>上肢</strong></h3><ul>
<li>左肩和左臂由前方开始向后摆，骨盆也向中性位置扭转(twist toward to neutral position)；</li>
<li>由于地反力作用方向，躯干的前进速度有所降低，但高度开始增加，<strong>动能向重力势能转变</strong>；</li>
</ul>
<h3 id="髋-2"><a href="#髋-2" class="headerlink" title="髋"></a><strong>髋</strong></h3><ul>
<li>此时髋关节的弯曲角度约为$25^\circ$，并继续伸展；臀大肌、腘绳肌继续同心收缩；</li>
</ul>
<h3 id="膝-2"><a href="#膝-2" class="headerlink" title="膝"></a><strong>膝</strong></h3><ul>
<li>膝关节继续弯曲，并在<strong>随后的支撑中期达到一个屈膝峰值</strong>；</li>
<li>股四头肌(Quadriceps)先离心在向心收缩(eccentric then concentric)<strong>，使得膝关节具有一定的弹性特性(act like a spring)</strong>，防止垂直方向上力增加过快(preventing the vertical force from building up too rapidly)；</li>
</ul>
<h3 id="踝足-2"><a href="#踝足-2" class="headerlink" title="踝足"></a><strong>踝足</strong></h3><ul>
<li>脚掌完全接触地面，随着胫骨向前移动，<strong>踝关节开始背屈(dorsiflexion)</strong>;</li>
<li>足部旋前(pronation)和胫骨内旋(internal rotation)达到峰值，并开始反转；</li>
<li>胫骨前肌(tibialis anterior)停止活动，<strong>小腿三头肌(triceps surae)开始收缩</strong>;</li>
</ul>
<h3 id="力矩与功率-1"><a href="#力矩与功率-1" class="headerlink" title="力矩与功率"></a><strong>力矩与功率</strong></h3><ul>
<li>髋关节继续维持内部伸展力矩并产生能量；</li>
<li>膝关节处，<strong>地反力矢量位于膝关节后方</strong>，因此产生一个外部屈膝力矩，<strong>股四头肌(quadriceps)的伸膝力矩与之相拮抗</strong>，同时<strong>离心收缩吸收能量(</strong>功率图2.7，K1)；</li>
<li>踝关节处，地反力作用线向前方移动，导致踝关节内部背屈力矩变小，并<strong>开始转变为内部跖屈力矩</strong>，此时踝关节几乎没有能量交换；</li>
</ul>
<hr>
<img src="/2022/03/01/1-Course/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%90/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%904-%E6%AD%A5%E6%80%81%E5%BE%AA%E7%8E%AF%E8%AF%A6%E8%BF%B0/03.png" class title="未标题-10.png">
<h2 id="支撑中期-Mid-stance"><a href="#支撑中期-Mid-stance" class="headerlink" title="支撑中期 - Mid-stance"></a>支撑中期 - Mid-stance</h2><h3 id="概括-3"><a href="#概括-3" class="headerlink" title="概括"></a><strong>概括</strong></h3><ul>
<li><strong>支撑中期在对侧脚趾离地(双支撑阶段结束)之后，到脚跟抬升(toe off)之前</strong>；在过去一些文献中，支撑中期也常被用来描述对侧腿在摆动相经过支撑腿的阶段，也就是这里定义的<strong>双脚贴近(Feet adjacent)</strong>；在示例中，步态中期从7%到32%步态周期；</li>
</ul>
<h3 id="上肢-3"><a href="#上肢-3" class="headerlink" title="上肢"></a><strong>上肢</strong></h3><ul>
<li>支撑中期，<strong>躯干爬升到竖直方向最高点</strong>，随着动能向重力势能转化，向前速度也逐步减慢；</li>
<li><strong>躯干侧向(左右方向)的运动也达到峰值</strong>，重心完全移向右腿，躯干重心距离中线约20mm；</li>
<li>躯干(trunk)和肩胛带(shoulder girdle)的扭转基本消失，双臂也随着双腿而摆动交替；</li>
</ul>
<h3 id="髋-3"><a href="#髋-3" class="headerlink" title="髋"></a><strong>髋</strong></h3><ul>
<li>髋关节在支撑中期<strong>继续伸展(extend)</strong>，但髋关节角度由弯曲姿态(flexed attitude)转变为伸展状态(extended attitude)，在图2.5中髋关节角度逐渐小于零；</li>
<li>在此期间，臀大肌和腘绳肌(gluteus maximus, hamstrings)逐渐停止同心收缩，<strong>髋关节的伸展转为通过重力和惯性来完成(ahieved by interia and gravity)</strong>；</li>
<li>不同于双支撑阶段，支撑中期仅有一侧腿来支撑骨盆(pelvis)，因此<strong>在前视面(frontal plane)上髋关节的外展肌(abdustor)收缩</strong>，如臀中肌和阔筋膜张肌(gluteus medius, tensor fascia lata)，<strong>以维持骨盆的位置与平衡</strong>；</li>
</ul>
<h3 id="膝-3"><a href="#膝-3" class="headerlink" title="膝"></a><strong>膝</strong></h3><ul>
<li>在支撑中期，膝关节先弯曲达到一个峰值，<strong>然后开始转为伸展</strong>，这种伸展主要借助<strong>股四头肌(quadriceps)的同心收缩</strong>；</li>
<li>屈膝峰值发生在步态周期的15%~20%之间，<strong>屈膝的峰值角度依赖于行走速度(sensitive to walking speed)</strong>，当速度很慢时有可能消失，但一般在$10^\circ$到$20^\circ$之间；</li>
</ul>
<h3 id="踝足-3"><a href="#踝足-3" class="headerlink" title="踝足"></a><strong>踝足</strong></h3><ul>
<li>小腿胫骨以踝关节为轴向前旋转，被称为<strong>支撑中期摇杆</strong>(mid-stance rocker/ankle rocker)；</li>
<li>足部始终与地面贴在一起，踝关节角度背屈，<strong>小腿三头肌(triceps surae)离心收缩</strong>；</li>
<li>地反力矢量沿足部向前移动，并在足跟抬起前移动至前足(forefoot)；</li>
</ul>
<h3 id="力矩与功率-2"><a href="#力矩与功率-2" class="headerlink" title="力矩与功率"></a><strong>力矩与功率</strong></h3><ul>
<li>在支撑中期，髋关节伸肌产生的伸展力矩逐渐减小消失，并转为弯曲力矩；</li>
<li>膝关节处，地反力矢量始终在关节后方，产生的外骨骼屈膝力矩由内部伸膝力矩所抵抗，股四头肌收缩(<strong>根据一些文献只有股中间肌Vasti收缩，而股直肌rectus femoris不活跃</strong>)，并随着膝关节伸展产生能量，见图2.7的K2；</li>
<li>踝关节处，随着地反力逐渐向前脚掌移动，踝关节的跖屈力矩逐渐增长，<strong>小腿三头肌(triceps surae)离心收缩并吸收能量</strong>，见图2.7的A1；</li>
</ul>
<hr>
<img src="/2022/03/01/1-Course/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%90/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%904-%E6%AD%A5%E6%80%81%E5%BE%AA%E7%8E%AF%E8%AF%A6%E8%BF%B0/04.png" class title="未标题-11.png">
<h2 id="足跟抬升-Heel-Rise"><a href="#足跟抬升-Heel-Rise" class="headerlink" title="足跟抬升 - Heel Rise"></a>足跟抬升 - Heel Rise</h2><h3 id="概括-4"><a href="#概括-4" class="headerlink" title="概括"></a><strong>概括</strong></h3><ul>
<li>脚后跟开始离开地面，标志支撑中期(Mid-stance)到支撑末期(Ternimal Stance)的转变，发生时间受个体和步速的影响，示例中为步态周期的32%。</li>
</ul>
<h3 id="上肢-4"><a href="#上肢-4" class="headerlink" title="上肢"></a><strong>上肢</strong></h3><ul>
<li>足跟抬升时，<strong>躯干开始由竖直方向上的最高点开始回落</strong>，横向位移也开始减少，<strong>为重心转移回左腿做准备</strong>；</li>
<li>随着右腿向后移动，<strong>骨盆也开始向右侧扭转</strong>，右肩和右臂向前移动；</li>
</ul>
<h3 id="髋-4"><a href="#髋-4" class="headerlink" title="髋"></a><strong>髋</strong></h3><ul>
<li>髋关节继续伸展(extend, 大腿向后运动)，对侧初始着地时伸展角度达到峰值；</li>
<li>前视面上，髋关节外展肌(臀中肌, 阔筋膜张肌)继续收缩以维持骨盆稳定，在<strong>略早于对侧初始着地(OI)时停止收缩</strong>；</li>
</ul>
<h3 id="膝-4"><a href="#膝-4" class="headerlink" title="膝"></a><strong>膝</strong></h3><ul>
<li>膝关节在足跟抬升左右达到伸膝角度的峰值；</li>
<li>在此时，<strong>踝关节的跖屈力矩使得地反力矢量指向膝关节前方，也因此产生了一个外部伸膝力矩，这种效应被称为”踝足跖屈-伸膝耦合”(plantarflexion/knee extension couple)</strong>，在一些病理步态中十分重要；</li>
<li><strong>腓肠肌(gastrocnemius)的收缩</strong>不仅增强了踝关节的跖屈，同时也作为膝关节的屈膝肌肉，<strong>防止膝关节的过度伸展(hyperextension)</strong>；</li>
</ul>
<h3 id="踝足-4"><a href="#踝足-4" class="headerlink" title="踝足"></a><strong>踝足</strong></h3><ul>
<li><strong>踝关节的背屈角度在足跟抬升后达到峰值</strong>，在支撑末期结束前开始转为跖屈；</li>
<li>在<strong>距骨滑车(subtalar joint)面</strong>，胫骨外旋(externally rotate)、足部逐渐旋后(supinate)；</li>
<li>脚趾(toe)依然紧贴于地面，<strong>足与脚趾在跖趾关节(metatarsophalangeal joints, MTP)处弯曲</strong>，并沿着一条横贯前足的斜线-<strong>跖骨斜线(metatarsal break)</strong>；</li>
<li>当足跟抬升时，可以观察到<strong>后足(hindfoot)的内翻(inversion)</strong>；</li>
</ul>
<h3 id="力矩与功率-3"><a href="#力矩与功率-3" class="headerlink" title="力矩与功率"></a><strong>力矩与功率</strong></h3><ul>
<li>足跟抬升后，<strong>髋关节的内屈髋力矩由小逐渐增大</strong>，但这个力矩产生的来源没有清晰的解释，一些文献中将其描述为来自<strong>长收肌(adductor longus)和股直肌(rectus femoris)的收缩</strong>以及<strong>韧带(ligament)的被动拉伸</strong>，也因此导致<strong>能量的吸收与存储</strong>；</li>
<li>膝关节处，股四头肌的收缩在足跟上升之前就已经停止，转而<strong>存在一个屈膝力矩，这个力矩可能由于刚体的被动运动与惯性 —</strong> 此时上肢的前进速度大于胫骨，会使得踝关节背屈(dorsiflexion)，<strong>但小腿三头肌的收缩阻止了背屈</strong>，也因此降低了胫骨向前的运动，而<strong>股骨的向前运动</strong>在膝关节处产生了一个外部伸膝力矩，因此<strong>需要内部屈膝力矩进行抵抗</strong>，但基本没有太多能量交换；</li>
<li>踝关节的内部跖屈力矩逐渐增加(plantarflexion，但原文为dorsiflexion)，<strong>开始只有比目鱼肌(soleus)收缩，之后三小腿头肌共同收缩</strong>；此时踝关节依然在背屈，因此仍在吸收能量；</li>
</ul>
<hr>
<img src="/2022/03/01/1-Course/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%90/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%904-%E6%AD%A5%E6%80%81%E5%BE%AA%E7%8E%AF%E8%AF%A6%E8%BF%B0/05.png" class title="未标题-12.png">
<h2 id="对侧初始接触-Opposite-Initial-Contact"><a href="#对侧初始接触-Opposite-Initial-Contact" class="headerlink" title="对侧初始接触 - Opposite Initial Contact"></a>对侧初始接触 - Opposite Initial Contact</h2><h3 id="概括-5"><a href="#概括-5" class="headerlink" title="概括"></a><strong>概括</strong></h3><ul>
<li>在对称步态(symmetrical gait)中，对侧初始接触几乎是发生在50%的步态周期，它标志着双支撑阶段和预摆动阶段(pre-swing)的开始；此时髋关节开始屈髋(大腿向前)，膝关节屈膝，踝关节跖屈；</li>
<li>足跟抬升(HR)到趾尖离地(HR)的阶段又被描述为terminal rocker，因为在这期间支撑腿绕着前脚向前移动；</li>
<li><strong>推进阶段(push off phase)</strong>也常用来描述这一时期，因为<strong>地反力存在一个较大的峰值</strong>；这一现象既有全身协调下杠杆效应的被动作用，也有来自于关节主动运动的结果；在这一阶段，<strong>踝关节产生了一个极大的输出功率</strong>，但不太清楚这些功率是否用来加速全身前进，还是腿部的摆动；在姿态控制的研究中(posture control)，这种<strong>推进被称为踝关节策略(ankle strategy)</strong>，可以被拉动大腿向前(pulling their leg forward，这里应该是指摆动阶段)的<strong>髋关节策略(hip strategy)</strong>所代替；</li>
</ul>
<h3 id="上肢-5"><a href="#上肢-5" class="headerlink" title="上肢"></a><strong>上肢</strong></h3><ul>
<li>对侧初始接触时，上肢姿态和初始接触(IC)基本相同，但呈反对称，躯干向着左侧扭转，右肩、右臂以及骨盆左侧向前；</li>
</ul>
<h3 id="髋-5"><a href="#髋-5" class="headerlink" title="髋"></a><strong>髋</strong></h3><ul>
<li>在对侧初始接触时，<strong>髋关节的伸展角达到最大(通常为$10^\circ$到$20^\circ$)</strong>，并开始换向屈髋；</li>
<li>长收肌(adductor longus)收缩、韧带被动张力以及重力的共同作用下，此时<strong>屈髋力矩达到峰值，以启动髋关节屈曲</strong>；</li>
</ul>
<h3 id="膝-5"><a href="#膝-5" class="headerlink" title="膝"></a><strong>膝</strong></h3><ul>
<li>对侧初始接触前，膝关节已经开始屈膝；<strong>地反力矢量指向膝关节后方</strong>，并产生外部屈膝力矩；<strong>股直肌离心收缩</strong>，防止屈膝速度过快；</li>
<li>在预摆动阶段，<strong>膝关节与髋关节共同屈曲</strong>，常用<strong>”下拉“(pull off)</strong>这个术语常用来描述；</li>
</ul>
<h3 id="踝足-5"><a href="#踝足-5" class="headerlink" title="踝足"></a><strong>踝足</strong></h3><ul>
<li>从对侧初始接触到趾尖离地，小腿三头肌向心收缩使<strong>踝关节跖屈</strong>；</li>
<li>跖趾关节(MTP Joint)的弯曲使得<strong>足底筋膜(plantar fascia)收紧</strong>；</li>
<li>足部达到最大的旋后角(supination)，后足内翻(inversion)并伴随胫骨外旋，这些特征使得<strong>跗骨间关节(midtarsal joints)锁死，增强了足部承载负荷的稳定性</strong>；</li>
</ul>
<h3 id="力矩与功率-4"><a href="#力矩与功率-4" class="headerlink" title="力矩与功率"></a><strong>力矩与功率</strong></h3><ul>
<li>长收肌(adductor longus)收缩、韧带被动张力以及重力的共同作用下，此时<strong>屈髋力矩达到峰值</strong>；随着运动由伸髋向屈髋转变，髋关节也由支撑末期(Terminal stance)的吸收能量(<strong>图2.7的H2</strong>)，转为预摆动阶段(pre-swing)的产生能量(<strong>图2.7的H3</strong>)；</li>
<li>膝关节处，股直肌离心收缩防止膝关节屈膝过快，同时也吸收能量(图2.7的K3)；</li>
<li>踝关节处，<strong>小腿三头肌收缩产生极高的内部跖屈力矩</strong>，同时踝关节跖屈，并<strong>产生整个步态周期内最高的能量</strong>，<strong>推进身体向前运动并加速肢体进入摆动阶段</strong>；</li>
</ul>
<hr>
<img src="/2022/03/01/1-Course/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%90/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%904-%E6%AD%A5%E6%80%81%E5%BE%AA%E7%8E%AF%E8%AF%A6%E8%BF%B0/06.png" class title="未标题-13.png">
<h2 id="趾尖离地-Toe-Off"><a href="#趾尖离地-Toe-Off" class="headerlink" title="趾尖离地 - Toe Off"></a>趾尖离地 <strong>- Toe Off</strong></h2><h3 id="概括-6"><a href="#概括-6" class="headerlink" title="概括"></a><strong>概括</strong></h3><ul>
<li><strong>趾尖离地</strong>通常发生在步态周期的60%处，并分隔支撑相与摆动相；但在病理步态中，趾尖离地可能不是支撑相结束的标志。</li>
</ul>
<h3 id="上肢-6"><a href="#上肢-6" class="headerlink" title="上肢"></a><strong>上肢</strong></h3><ul>
<li>肩、手臂和躯干的扭转都开始向中性位置恢复，躯干高度增加，并向支撑腿的方向移动；</li>
</ul>
<h3 id="髋-6"><a href="#髋-6" class="headerlink" title="髋"></a><strong>髋</strong></h3><ul>
<li>当足部离开地面后，髋关节在<strong>股直肌和长收肌收缩、重力和韧带被动张力</strong>下，继续弯曲；</li>
</ul>
<h3 id="膝-6"><a href="#膝-6" class="headerlink" title="膝"></a><strong>膝</strong></h3><ul>
<li>在趾尖离地时，膝关节已经屈膝至一半的峰值角度，但在离地前后屈膝的机制不同：在支撑阶段，<strong>地反力矢量指向膝关节后方</strong>，因此产生外部屈膝力矩；在摆动相初期，大腿小腿的摆动类似于<strong>双摆系统(double pendulum)</strong>，当髋关节屈曲时，<strong>小腿由于惯性被甩在后面</strong>，从而导致进一步的屈膝；</li>
<li>在摆动相初期的开始时刻，<strong>股直肌(rectus femoris)可能存在离心收缩，以防止过度屈膝</strong>(prevent excessive knee flexion)；</li>
</ul>
<h3 id="踝足-6"><a href="#踝足-6" class="headerlink" title="踝足"></a><strong>踝足</strong></h3><ul>
<li>踝关节跖屈峰值发生在趾尖离地后不久，离地前<strong>小腿三头肌(triceps surae)停止收缩</strong>，<strong>胫骨前肌(tibialis anterior)开始收缩</strong>，使踝关节在摆动阶段保持中性(neutral)或背屈的姿态(dorsiflexed attitude)；</li>
</ul>
<h3 id="力矩与功率-5"><a href="#力矩与功率-5" class="headerlink" title="力矩与功率"></a><strong>力矩与功率</strong></h3><ul>
<li><strong>股直肌和长收肌收缩、重力和韧带被动张力</strong>，使得趾尖离地时髋关节依然存在屈膝力矩，并随着髋关节屈曲而产生能量；</li>
<li>在预摆动阶段(pre-swing)和摆动初期，<strong>髋关节的屈曲导致了膝关节的屈膝</strong>，股直肌以及股四头肌收缩产生内部伸膝力矩，抵抗并防止膝关节过度弯曲，同时吸收来自大腿传递的动能；</li>
<li>随着地反力的降低，<strong>踝关节的跖屈力矩迅速减少，并在趾尖离地前降低到零</strong>，同时功率也降低至零；</li>
</ul>
<hr>
<img src="/2022/03/01/1-Course/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%90/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%904-%E6%AD%A5%E6%80%81%E5%BE%AA%E7%8E%AF%E8%AF%A6%E8%BF%B0/07.png" class title="未标题-14.png">
<h2 id="双足贴近-Feet-Adjacent"><a href="#双足贴近-Feet-Adjacent" class="headerlink" title="双足贴近 - Feet Adjacent"></a>双<strong>足贴近 - Feet Adjacent</strong></h2><h3 id="概括-7"><a href="#概括-7" class="headerlink" title="概括"></a><strong>概括</strong></h3><ul>
<li>足部贴近标志摆动初期(initial swing)和摆动中期(mid-swing)的转变，此时双脚处于几乎并排的状态；</li>
<li>摆动相一般占据步态周期的40%，而<strong>摆动初期大约占摆动相的一半</strong>，在示例中足部贴近发生在步态周期的77%；</li>
<li>双足靠近也经常被称为<strong>足部间隙(foot clearance)</strong>，摆动初期也被叫做<strong>抬升阶段(lift off)</strong>；</li>
</ul>
<h3 id="上肢-7"><a href="#上肢-7" class="headerlink" title="上肢"></a><strong>上肢</strong></h3><ul>
<li>当两脚贴近时，躯干处于最高位置，横向也处于朝向另一侧支撑腿的最大位移；双臂相互水平，左侧向前摆动，右侧向后；</li>
</ul>
<h3 id="髋-7"><a href="#髋-7" class="headerlink" title="髋"></a><strong>髋</strong></h3><ul>
<li>在<strong>髂腰肌(iliopsoas)和重力</strong>的共同作用下，髋关节已经实现了较大的屈曲；</li>
</ul>
<h3 id="膝-7"><a href="#膝-7" class="headerlink" title="膝"></a><strong>膝</strong></h3><ul>
<li>膝关节在髋关节屈曲的带动下屈膝，<strong>屈膝峰值约在$60^\circ$到$70^\circ$之间</strong>， 到足部贴近时膝关节已经开始伸展；</li>
<li><strong>在快速行走时</strong>，膝关节的弯曲要小于常速行走，以<strong>减小摆动相的时间</strong>(这里应该是绝对时间，而非步态周期百分比)，且通常是<strong>通过股直肌(rectus femoris)和腘绳肌(hamstrings)的协同收缩(co-contraction)来实现(增加关节阻抗)</strong>；</li>
</ul>
<h3 id="踝足-7"><a href="#踝足-7" class="headerlink" title="踝足"></a><strong>踝足</strong></h3><ul>
<li>在摆动前期，踝关节由跖屈姿态迅速背屈，并在足部贴近时接近中性角度；这个过程中胫骨前肌收缩，但不需要太大的力量；</li>
<li><strong>脚趾离地面最近的时刻发生足部贴近</strong>，为了<strong>避免摆动相趾尖与地面的接触(toe clearance/foot clearance)</strong>，需要缩短摆动腿的长度，这一目的通过两种机制来实现：<ul>
<li>1 - 膝关节弯曲</li>
<li>2 - 踝关节背屈</li>
</ul>
</li>
<li>在正常步态中，<strong>脚趾与地面的间隔(clearance)非常小，平均仅有14mm</strong>；</li>
</ul>
<h3 id="力矩与功率-6"><a href="#力矩与功率-6" class="headerlink" title="力矩与功率"></a><strong>力矩与功率</strong></h3><ul>
<li>从对侧初始接触(OI)到双足贴近，<strong>髋关节始终存在屈髋力矩</strong>，在摆动初期<strong>髂腰肌(iliopsoas)代替股直肌(rectus femoris)</strong>并联合重力共同作用，并在髋关节产生功率峰(图2.7的H3)，这个能量用于<strong>加速腿的向前摆动</strong>，并在摆动末期随着腿摆动减速，<strong>将动能传递到躯干</strong>(trunk)；</li>
<li>膝关节处存在伸膝力矩，<strong>股直肌收缩(非股四头肌共同收缩)以防止膝关节过屈</strong>；</li>
<li>踝关节处，由于足部的质量很小，因此力矩和功率都很小；</li>
</ul>
<hr>
<img src="/2022/03/01/1-Course/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%90/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%904-%E6%AD%A5%E6%80%81%E5%BE%AA%E7%8E%AF%E8%AF%A6%E8%BF%B0/08.png" class title="未标题-15.png">
<h2 id="胫骨竖直-Tibia-Vertical"><a href="#胫骨竖直-Tibia-Vertical" class="headerlink" title="胫骨竖直 - Tibia Vertical"></a>胫骨竖直 <strong>- Tibia Vertical</strong></h2><h3 id="概括-8"><a href="#概括-8" class="headerlink" title="概括"></a><strong>概括</strong></h3><ul>
<li><strong>胫骨竖直划分摆动中期(mid-swing)和摆动末期(terminal swing)</strong>，在示例中发生在步态周期86%；<strong>摆动末期也被称为抵达(reach)</strong>；</li>
</ul>
<h3 id="上肢-8"><a href="#上肢-8" class="headerlink" title="上肢"></a><strong>上肢</strong></h3><ul>
<li>躯干已从最高位置回落，同时在侧向上由左侧支撑腿向着中线移动，</li>
<li>右臂位于前方，同时骨盆右侧略微靠前；</li>
</ul>
<h3 id="髋-8"><a href="#髋-8" class="headerlink" title="髋"></a><strong>髋</strong></h3><ul>
<li><strong>胫骨垂直基本标志着髋关节伸展的停止</strong>，在示例中髋关节的最大弯曲角度为$27^\circ$；</li>
<li>在摆动末期，<strong>腘绳肌(hamstrings)的收缩逐渐增强</strong>，在保持髋关节弯曲角度的同时，也防止膝关节伸展过快；</li>
</ul>
<h3 id="膝-8"><a href="#膝-8" class="headerlink" title="膝"></a><strong>膝</strong></h3><ul>
<li>在胫骨竖直时，膝关节处于快速伸展状态，<strong>这种伸膝来自于双摆系统的被动惯性</strong>，此时大腿停止屈曲，而小腿仍保有一定动能，使得胫骨向前旋转；</li>
</ul>
<h3 id="踝足-8"><a href="#踝足-8" class="headerlink" title="踝足"></a><strong>踝足</strong></h3><ul>
<li>趾尖间隙完成后，到胫骨竖直之前，踝关节的运动对步态没有太大影响；</li>
<li>胫骨前肌会继续保持收缩，维持踝关节在中性角度附近，但在初始接触前回增加收缩为足跟着地提前准备；</li>
</ul>
<h3 id="力矩与功率-7"><a href="#力矩与功率-7" class="headerlink" title="力矩与功率"></a><strong>力矩与功率</strong></h3><ul>
<li>在双足贴近后，摆动中期和摆动末期，髋关节存在由<strong>腘绳肌(hamstrings, 主要)和臀大肌(gluteus maximus)产生的伸髋力矩</strong>；</li>
<li>尽管由于髋关节此时基本不发生运动，髋关节基本没有能量交换，<strong>但髋关节的力矩使得能量可以由摆动腿传递给躯干</strong>(来自膝关节的功率K4)，<strong>恢复部分摆动初期由躯干传递给腿部能量</strong>(髋关节H3)<strong>；</strong></li>
<li>由于腘绳肌的离心收缩，膝关节存在逐渐增加的屈膝力矩，<strong>防止被动惯性作用下膝关节的过伸，同时吸收能量</strong>；</li>
<li>此时踝关节处的功率和能量依然可以忽略不计；</li>
</ul>
]]></content>
      <categories>
        <category>biomechanics</category>
      </categories>
      <tags>
        <tag>步态分析</tag>
      </tags>
  </entry>
  <entry>
    <title>步态分析 3 - 步态循环概要 Outline</title>
    <url>/2022/03/01/1-Course/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%90/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%903-%E6%AD%A5%E6%80%81%E5%BE%AA%E7%8E%AF%E6%A6%82%E8%A6%81/</url>
    <content><![CDATA[<p>在详细介绍步态循环的每个阶段之前，先了解一下平地行走步态的整体过程。</p>
<img src="/2022/03/01/1-Course/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%90/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%903-%E6%AD%A5%E6%80%81%E5%BE%AA%E7%8E%AF%E6%A6%82%E8%A6%81/01.png" class title="请打印本图">
<span id="more"></span>
<h2 id="步态循环的运动学、动力学与肌肉活动"><a href="#步态循环的运动学、动力学与肌肉活动" class="headerlink" title="步态循环的运动学、动力学与肌肉活动"></a>步态循环的运动学、动力学与肌肉活动</h2><p>本章所采用数据来自一个健康女性(<strong>22岁，55Kg，步态周期0.88s，步长1.5m，步速1.70m/s</strong>)，其中运动学数据来自<strong>Vicon动作捕捉系统</strong>，地反力来自<strong>Bertec跑台</strong>。图2.4展示了单步态周期内，每间隔40ms的右侧腿位姿。图2.8为Pedotti描述的<strong>地反力蝴蝶图(butterfly diagram)</strong>，其中地反力矢量相互间隔10ms。</p>
<p>在<strong>运动学分析</strong>中，<strong>膝关节角度(knee angle)</strong>定义为股骨(femur)与胫骨(tibia)的夹角，<strong>踝关节角度(ankle angle)</strong>是胫骨与足部任一直线的夹角，并在传统上把站立状态的角度认定为$0^\circ$。<strong>髋关节角度(hip angle)</strong>有两种定义方式：股骨与竖直方向的夹角、股骨与骨盆(pelvis)的夹角，后者是更准确的定义，通常也是把站立姿态的角度定义为$0^\circ$。</p>
<p>在<strong>动力学分析</strong>中，本文关节力矩的计算采<strong>矢量投影法(vector projection)</strong>。相对于更准确的<strong>逆动力学法(inverse dynamics)</strong>，本文采用的方法忽略了关节下方的肢体质量与肢体加减速对关节力矩的影响，但有助于理解关节力矩的形成原因。本文所计算的关节力矩和关节功率均对体重进行了归一化。</p>
<p>图2.9展示了完成正产步态下肢主要<strong>肌肉的典型收缩模式</strong>。需要注意的是这不是唯一可能的模式，人体<strong>肌肉系统的冗余特性(redundancy)</strong>，使得个体可以使用不同的肌肉组合实现相同的步态运动模式。肌肉激活模式不仅有个体差异性，还会受到疲劳、速度变化等的影响。</p>
<img src="/2022/03/01/1-Course/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%90/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%903-%E6%AD%A5%E6%80%81%E5%BE%AA%E7%8E%AF%E6%A6%82%E8%A6%81/02.png" class title="未标题-5.png">
<h2 id="步态循环中各肢段的运动"><a href="#步态循环中各肢段的运动" class="headerlink" title="步态循环中各肢段的运动"></a>步态循环中各肢段的运动</h2><h3 id="上肢-Upper-body"><a href="#上肢-Upper-body" class="headerlink" title="上肢(Upper body)"></a><strong>上肢(Upper body)</strong></h3><ul>
<li>人体上半身在步态循环中向前移动，其中在<strong>双支撑阶段(double support phase)速度最快</strong>，在<strong>支撑相和摆动相的中期(middle if the stance and swing phase)速度最慢；</strong></li>
<li><strong>躯干(trunk)在一个步态周期中上下移动两次</strong>，在双支撑阶段最低，支撑相和摆动相的中期最高，上下移动距离约46mm，图2.4髋关节的位置能够一定程度上反应这种移动；行走时<strong>脊柱肌肉(spinal muscle)</strong>会选择性的收缩，<strong>使得头部的移动小于盆骨</strong>，这对提供一个稳定的视觉平台很重要；</li>
<li><strong>躯干(trunk)在一个步态周期中左右移动一次</strong>，向支撑相一侧<strong>移动并超过</strong>，以获取上肢的支撑，横向的移动距离也接近46mm；</li>
<li>躯干(trunk)整体绕垂直轴旋转，<strong>肩胛带(shoulder girdle)的旋转方向与盆骨(pelvis)的方向相反</strong>，因此手臂的摆动与双腿相位相反(the arms swing out of phase with the legs)；成年男性平地自由行走时平均双肩旋转角度为$7^\circ$，骨盆为$12^\circ$；<strong>行走的流畅性与效率(fluidity and efficiency)一定程度上取决于躯干和手臂的运动</strong>，但在临床步态分析中经常被忽视；</li>
</ul>
<h3 id="髋关节-Hip"><a href="#髋关节-Hip" class="headerlink" title="髋关节(Hip)"></a>髋关节(Hip)</h3><ul>
<li>髋关节在步态周期中弯曲和伸展各一次(flexes and extends)，参考图2.5；</li>
<li>最大弯曲角(peak flexion)在<strong>摆动相中期(middle of the swing phase)</strong>达到；</li>
<li>最大伸展角(peak extension)在<strong>支撑相末期(end of the stance phase)</strong>达到；</li>
</ul>
<h3 id="膝关节-Knee"><a href="#膝关节-Knee" class="headerlink" title="膝关节(Knee)"></a>膝关节(Knee)</h3><ul>
<li><strong>膝关节在每个步态周期经历两个伸展弯曲的过程</strong>，参考图2.5；</li>
<li><strong>阶段一</strong>：膝关节从略早于脚跟着地(Initial Contact)时开始弯曲(flex)，经历支撑前期(loading response)和支撑中期(mid-stance)前些部分，然后在剩余的支撑中期里伸展(extend)，并在支撑中期结束和支撑末期(terminal stance)开始左右达到<strong>最大伸展角</strong>；</li>
<li><strong>阶段二</strong>：随着脚跟抬起(heel rise)，膝关节开始第二次弯曲，从支撑末期(terminal stance)一直持续到摆动相(swing phase knee flexion)，在摆动初期(initial swing)达到<strong>最大弯曲角</strong>，然后膝关节开始第二次伸展，为即将的支撑相做准备；</li>
</ul>
<h3 id="踝关节-Ankle-and-foot"><a href="#踝关节-Ankle-and-foot" class="headerlink" title="踝关节(Ankle and foot)"></a>踝关节(Ankle and foot)</h3><ul>
<li>在初始接触时(initial contact)，踝关节角度通常在跖屈/背屈的<strong>中性位置(neutral position)左右</strong>；脚跟着地后，踝关节先<strong>轻微跖屈(plantarflex)</strong>使足底完全接触地面，然后小腿胫骨(tibia)开始向前移动，导致<strong>踝关节背屈(dorsiflex)；</strong></li>
<li>在<strong>对侧脚跟着地(opposite initial contact)前</strong>，<strong>支撑末期(terminal stance)内</strong>，踝关节达到最大背屈角，开始<strong>转为跖屈(plantarflex)</strong>，足部蹬地产生向前推进<strong>；</strong></li>
<li>在<strong>趾尖离地(toe off)后</strong>，踝关节达到<strong>最大跖屈角</strong>，然后开始迅速背屈至中性角度附近，以保证摆动相期间<strong>前足(forefoot)的离地净高(ground clearance)；</strong></li>
<li>在前视面上(the frontal plane)，<strong>着地时足部轻微内翻(inverted, adducted,  varus)，</strong>在开始的跖屈阶段<strong>旋后(pronate)</strong>，然后在随后的背屈阶段<strong>旋前(supinate)</strong>，并一直维持到支撑相结束，甚至在整个摆动相都保持一定的旋前(supination)</li>
</ul>
]]></content>
      <categories>
        <category>biomechanics</category>
      </categories>
      <tags>
        <tag>步态分析</tag>
      </tags>
  </entry>
  <entry>
    <title>步态分析 2 - 常用术语 Terminology</title>
    <url>/2022/03/01/1-Course/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%90/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%902-%E5%B8%B8%E7%94%A8%E6%9C%AF%E8%AF%AD/</url>
    <content><![CDATA[<p>相比于行走(<strong>Walking</strong>)，步态(<strong>Gait</strong>)一词更侧重于强调行走的方式和风格(manner and style)，而非行走过程本身。在步态分析一书中，作者是用如下语句来描述正常步态运动：</p>
<blockquote>
<p>Normal human walking and running can be defined as ‘a method of locomotion involving the use of legs, alternately, to provide both support and propulsion.’</p>
</blockquote>
<p>本小节主要介绍正常行走步态的基本特征。</p>
<img src="/2022/03/01/1-Course/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%90/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%902-%E5%B8%B8%E7%94%A8%E6%9C%AF%E8%AF%AD/01.png" class title="Untitled">
<span id="more"></span>
<h3 id="步态周期-步态循环-Gait-Cycle"><a href="#步态周期-步态循环-Gait-Cycle" class="headerlink" title="步态周期/步态循环 - Gait Cycle"></a>步态周期/步态循环 - Gait Cycle</h3><p>步态周期定义为连续发生两次重复的步态事件之间的时间间隔。一般采用脚与地面开始接触时刻(initial contact)作为步态周期的开始，经历脚的落下与抬起，直到下一次脚与地面接触。</p>
<p>一个完整的步态周期包含着若干个阶段，每个阶段都有一个或多个<strong>典步态事件</strong>：</p>
<ol>
<li><strong>脚跟初始着地(Initial contact)</strong></li>
<li><strong>对侧趾尖离地(Opposite toe off)</strong></li>
<li><strong>脚跟抬升(Heel rise)</strong></li>
<li><strong>对侧脚跟着地(Opposite initial contact)</strong></li>
<li><strong>趾尖离地(Toe off)</strong></li>
<li><strong>双脚贴近(Feet adjacent)</strong></li>
<li><strong>胫骨竖直(Tibia vertical)</strong></li>
</ol>
<p><strong>七个步态事件</strong>将一个完整的步态周期划分为七个阶段，其中四个阶段中脚与地面相接触，称之为<strong>支撑相(support/contact/stance phase)</strong>：</p>
<ol>
<li><strong>支撑初期/承重反应期(Loading response)</strong></li>
<li><strong>支撑中期(Mid-stance)</strong></li>
<li><strong>支撑末期(Terminal stance)</strong></li>
<li><strong>预摆动阶段/摆动前期(Pre-swing)</strong></li>
</ol>
<p><strong>摆动相(swing phase)</strong>从趾尖离地开始到脚跟着地结束，包含三个阶段：</p>
<ol>
<li><strong>摆动初期(Initial swing)</strong></li>
<li><strong>摆动中期(Mid-swing)</strong></li>
<li><strong>摆动末期(Terminal swing)</strong></li>
</ol>
<h3 id="步态周期的时序-Gait-Cycle-Timing"><a href="#步态周期的时序-Gait-Cycle-Timing" class="headerlink" title="步态周期的时序 - Gait Cycle Timing"></a>步态周期的时序 - Gait Cycle Timing</h3><img src="/2022/03/01/1-Course/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%90/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%902-%E5%B8%B8%E7%94%A8%E6%9C%AF%E8%AF%AD/02.png" class title="Untitled">
<p>上图展示了在一个完整的步态周期内，左右两侧腿步态周期的时序关系。当右侧腿刚足跟着地时，左侧腿依然处于支撑阶段，存在一段两条腿同时处于支撑相的时间，被称为<strong>双支撑阶段(double support/double limb stance)</strong>。在一侧腿处于摆动相时，只有另一侧腿处于支撑相，也称为<strong>单支撑阶段(single support/single limb stance)</strong>。</p>
<p>在每个双支撑阶段，前侧脚刚刚落地，后侧脚即将离开地面，一般用<strong>前腿(leading leg)</strong>和<strong>后腿(trailing leg)</strong>加以区分。前腿处于<strong>支撑初期(loading response)</strong>，或者也被称为<strong>braking double support</strong>, <strong>initial double support</strong>, <strong>weight acceptance</strong>。后腿处于<strong>预摆动阶段(pre-swing)</strong>，亦或<strong>second/terminal/thrusting double support</strong> 或 <strong>weight release</strong>。</p>
<p>因此在每个步态周期中，存在两个双支撑阶段。一般情况下，支撑相约占步态周期的<strong>60%</strong>，摆动相占<strong>40%</strong>，每个双支撑阶段占<strong>10%</strong>。随着速度的增加，摆动相的步态周期占比逐渐增加，支撑相和双支撑阶段占比逐渐减少。当双支撑阶段完全消失时，步态由<strong>行走(walking)</strong>转变为<strong>奔跑(running)</strong>。在奔跑时，存在两条腿均处于摆动相的情况，称为<strong>腾空阶段(flight phase)</strong>。</p>
<h3 id="足部的落点-Foot-Placement"><a href="#足部的落点-Foot-Placement" class="headerlink" title="足部的落点 - Foot Placement"></a>足部的落点 - Foot Placement</h3><img src="/2022/03/01/1-Course/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%90/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%902-%E5%B8%B8%E7%94%A8%E6%9C%AF%E8%AF%AD/03.png" class title="Untitled">
<p>一个完整的<strong>步长(stride length)</strong>包含连续的左右两步步长(<strong>step length</strong>)。在病理步态中，不相等的左右两侧步长(step length)是十分常见的，甚至会出现单侧的步长(step length)为负数的情况。当病理对一侧腿的影响大于另一侧时，人倾向于更多的使用”好“腿，增加”好“腿的支撑阶段，并缩短”坏“腿的支撑相，“好”腿侧的摆动相和步长(step length)都会随之缩短。因此，一侧较短的步长(step length)往往暗示着另一侧腿在单支撑阶段存在一定问题。</p>
<p><strong>行走间距(walking base / stride width / base of support)</strong>指步态过程两脚之间的距离，通常以脚后跟的中点作为测量点。<strong>踵趾步态(tandem gait)</strong>就是一种行走间距接近于零的步态，这种步态模式往往需要较好的运动平衡能力。<strong>外展角(Toe out angle)</strong>指足部中线和前进方向之间夹角。<strong>足外展(外八字脚，toe out)</strong>在正常步态中较为常见，而<strong>足内收(内八，toe in)</strong>相对较少一些。</p>
<h3 id="步频、步速与步态周期时间-Cadence-speed-and-cycle-time"><a href="#步频、步速与步态周期时间-Cadence-speed-and-cycle-time" class="headerlink" title="步频、步速与步态周期时间 - Cadence, speed and cycle time"></a>步频、步速与步态周期时间 - Cadence, speed and cycle time</h3><p><strong>步频(Cadence)</strong>通常指每分钟经历的步数，这里的步是<strong>steps</strong>而非<strong>strides</strong>。因此步频(Cadence)的计算是半周期的，而更常用的是<strong>步态周期时间(cycle time)</strong>：</p>
<script type="math/tex; mode=display">
\text{clcye time (s) = 120 / cadence (steps/min)}</script><p><strong>行走步速(speed of walking)</strong>指在一定时间内全身所移动过的距离：</p>
<script type="math/tex; mode=display">
\text{speed (m/s) = stride length (m) / cycle time (s)}</script><p>在这里的定义是一个标量，需要区别于矢量的速度(velocity)。由于步速同时依赖于步频和步幅，因此步速的改变可以通过改变任意一个变量来实现，但人体通常同时改变两者。在不同个体之间，尤其是与儿童，进行步态参数的比较时，往往需要进行<strong>归一化处理(normalization)</strong>。通常的做法是除以<strong>步长因子(step fator)</strong>，如身高或腿长。</p>
]]></content>
      <categories>
        <category>biomechanics</category>
      </categories>
      <tags>
        <tag>步态分析</tag>
      </tags>
  </entry>
  <entry>
    <title>阻抗控制</title>
    <url>/2020/12/02/9-Others/%E9%98%BB%E6%8A%97%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<p>Hogan的三篇阻抗控制论文算是阻抗领域的经典之作，其最大贡献在于突破了原有的位控、力控的单一性，将位置、力的动态关系作为控制目标，非常适合需要与环境进行交互的控制。</p>
<p>根据个人浅显的理解，对论文进行一点总结。</p>
<img src="/2020/12/02/9-Others/%E9%98%BB%E6%8A%97%E6%8E%A7%E5%88%B6/Interaction.png" class>
<span id="more"></span>
<hr>
<h2 id="Part-I-Theory"><a href="#Part-I-Theory" class="headerlink" title="Part I Theory"></a>Part I Theory</h2><p>当我们谈到interaction的时候，我们主要关注交互过程的运动和力，以及两者的乘积-交互过程的能量流动。在一些情况下，交互过程能量流动可以被近似忽略，而交互控制也因此可以被简化。例如在交互力很小的情况下（例如喷涂），可以采用纯位置控制；在作用力方向上没有位移的情况下（例如焊接），可以采用力位混合控制。在余下大部分的情况下，交互过程往往都伴随着能量的转移，这时候单一的控制量（位置、速度、交互力）就不足以控制交互过程能量流动。</p>
<p>这个问题的一个解决方法是，控制操纵器的动态行为。如果将环境视作为操纵器的扰动，通过调节操纵器对扰动的响应则可实现对于动态行为的控制。这种调节不是通过动态调整控制器的参数（如改变pid的参数），而是通过探索物理交互的本质特性来实现的。</p>
<p><img src="/2020/12/02/9-Others/%E9%98%BB%E6%8A%97%E6%8E%A7%E5%88%B6/Impedance_Example.jpg" width="60%"></p>
<p>借用<a href="https://www.zhihu.com/question/43633361/answer/124417009">知乎邵天兰</a>关于机械臂开门的例子来做一个形象的解释。假定让机械臂去完成开门这个动作，由于门框的轴对门板产生了一定的运动学约束，门板的末端只能按照固定的轨迹进行运动。当采用完全的位置控制时，由于机械的规划轨迹和门的轨迹不可能做到完全一致（定位误差、传感器精度等诸多限制），这些偏差会使得门板和机械臂之间产生巨大的交互力；而若采用完全的力控，门板正常转动时的交互力又很小，很难实现较为准确的开门角度；因此必须要同时考虑位置和力的共同影响，才能较好的实现开门这个动作。实际上这样一个简单又复杂的问题，可以通过在机械臂末端添加一个弹簧来解决，机械臂采用位置控制时，弹簧的柔顺性使得即便存在一定的位置误差也不会产生很大的交互力。而阻抗控制，就是通过控制算法使机械臂表现出这样的弹簧行为。</p>
<h3 id="物理等效性"><a href="#物理等效性" class="headerlink" title="物理等效性"></a>物理等效性</h3><p>操纵器是是物理硬件（机械结构、传感器、驱动器）和软件算法（控制程序）集合而成。一个统一的框架应当将硬件和软件一同纳入其中。在Hogan的观点中，硬件和软件共同作用下的操纵器，在与环境的交互中应当表现正常物理系统应当具有的特性，也就是说，<strong>软件部分所代表的控制器，也应当具有适当的物理特性</strong>：</p>
<blockquote>
<p><strong>It is impossible to devise a controller which will cause a physical system to present an apparent behavior to its environment which is distinguishable from that of a purely physical system. </strong></p>
</blockquote>
<p>这就是阻抗控制最核心的思想，控制器不再是一个完全虚拟的概念，而是可以等效为一定物理模型，具有一定的物理特性。从另一角度来说，控制器不再是任意设计的，而受到一定的物理特性的约束。在此基础上，Hogan进一步对交互过程的两种方式，impedance和admittance，进行进一步阐述。</p>
<h3 id="因果关系"><a href="#因果关系" class="headerlink" title="因果关系"></a>因果关系</h3><p>在任意一个运动的自由度上，瞬时功率都由两项相乘而得：effort（例如力、电压）和flow（例如速度、电流）。任何一个物理系统在任意一个时刻都只能控制着两者中的一个，而不能控制两者全部（Hogan在这里更主要的是强调单自由度-单输入单输出的情况，最优控制问题也并未与此矛盾）。</p>
<p>因此从交互的能量视角出发，物理系统可以看做只存在两种类型：admittance和impedacne，其中admittance接受effort而产生flow，而impedance接受flow而产生effort，这两者有点类似于电学系统中的电阻和电导。但不同于电学系统，admittance和impedance一般是不能互换的，例如是因为速度而产生的摩擦力，而不能说是因为摩擦力而产生了速度。这种非相互转化的特性是因果关系的体现，对于一个确定的物理关系而言，例如$F=ma$，尽管从数学上可以从右到左去表达，但实际物理系统只能从左到右与产生。这种因果关系表明，对于任意一个物理系统，它只能被描述为admittance或impedance中确定的一种特性（这种确定应当是相对的）。</p>
<blockquote>
<p><strong>The most important consequence of dynamic interaction between two physical systems is that one must physically complement the other: Along any degree of freedom, if one is an impedance, the other must be an admittance and vice versa.</strong></p>
</blockquote>
<p>在交互过程中我们希望交互过程可以表现的比较柔顺“compliance”，交互力的变化比较平滑。为实现柔顺交互，进行交互的两个物理系统必须是物理互补的，即其中一个若表现出admittance，另一个则必须为impedance。在非互补的两种情况下，可能会导致非柔顺的交互过程（admittance-admittance），或者物理不可实现（impedance-impedance）。</p>
<p>对于大部分的操纵任务而言，其环境多少会包含惯性约束或运动学限制，这样的环境接收力的输入，然后产生运动响应（当然也可能没有运动），这样的物理特性只能看做是admittance。因此，与这样的环境进行交互时，操纵器必须表现出impedance，才能实现柔顺交互。</p>
<p>接下来进一步讨论如何将impedance和admittance用物理模型和数学方法进行表示。由于Hogan的论文中较多的是文字描述，公式较少，且采用的bond graphs也不为控制领域所熟悉，因此下一部分将主要参考Unified Impedance and Admittance Control以及Modern Robotics - Mechanics, Planning, and Control中的内容进行介绍。</p>
<h2 id="Part-II-Algorithm-and-Implementation"><a href="#Part-II-Algorithm-and-Implementation" class="headerlink" title="Part II Algorithm and Implementation"></a>Part II Algorithm and Implementation</h2><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>考虑一个非常简单的单自由度惯性系统，系统的动力学方程可以表示为如下形式：</p>
<script type="math/tex; mode=display">
m\ddot{x} = F+ F_\mathrm{ext} \quad\quad(1)</script><p>$F_\mathrm{ext}$表示环境提供的交互力，注意这个公式是对于真实系统的建模，对于复杂的交互系统可以建立更加复杂的模型。</p>
<p>无论是impedance control还是admittance control，其控制算法的设计目的都是通过控制操纵器的输出力$F$，使得外部力$F_\mathrm{ext}$与期望位置偏差$e=x-x_0$能够满足一定的关系，或者说外部力在与操纵器进行交互的时候具有一定的物理特性，如下图所示。区别于上面的动力学方程，这种物理特性是虚拟出来的，没有实际物理存在。一般来说，较多的采用二阶模型：</p>
<img src="/2020/12/02/9-Others/%E9%98%BB%E6%8A%97%E6%8E%A7%E5%88%B6/Interaction.png" class>
<script type="math/tex; mode=display">
M_d \ddot{e}+D_d \dot{e}+K_de=F_{\mathrm{ext}} \quad\quad(1)</script><p>式中$M_d$，$D_d$，$K_d$分别表示期望惯性、阻尼、刚度。在这样的关系下，外部力在与操纵器交互的时候，就像是在推动一个有阻尼、弹簧连接的质量块一样。由于这样一个关系是完全虚拟出来的，因此式中的三个参数可以任意调整。其中，刚度参数$K_d$是最重要的，也是最主要调节的参数，它反映操纵器的刚度大小，直接决定操纵器在与环境接触吋是呈现刚性还是柔性。一般来说，减小$K_d$会使机械手与环境的接触力变小，增大则会使机械臂与环境的接触力变大。阻尼参数$D_d$的增大或减小一般不会使接触力的稳定值变化，但可以调节操纵臂与环境交互的动态过程。一般来说，增大$D_d$会使力响应的超调减小，交互力的峰值显著下降，但过大的阻尼会使力响应过程变慢。惯性参数$M_d$一般不需要进行调节，但需要根据任务适当的进行选取。当这三个参数有任意一个的值较大时，我们其称为high impedance；若三个参数都很小时，称为low impedance。</p>
<p>进一步，可以对上式进行Laplace变换：</p>
<script type="math/tex; mode=display">
(M_ds^2+D_ds+K_d)E(s)=F_\mathrm{ext}(s)</script><p>由此可以通过位置扰动到外部力的传递函数来定义impedance：$Z(s)=F_\mathrm{ext}(s)/E(s)$，这样impedance就是一个与频率相关的概念，低频时的响应主要由弹性项决定，而高频时的响应主要由惯性项决定；而admittance就可以定义为impedance的逆：$Y(s)=z^{-1}(s)=X(s)/F(s)$。</p>
<p>一个好的位置控制器应当是high impedanc - low admittance，由于$E(s)=Y(s)F_\mathrm{ext}(s)$，来自外部力的扰动才能较小的影响位置；同理好的力控制应当是low impedance - high admittance，外部位置的扰动对力的影响才会比较小。从这一点来说，无论是位置控制还是力控制，都可以看做是阻抗控制的特例，是阻抗为无穷大和无穷小下的具体实现。</p>
<h3 id="Impedance-Control"><a href="#Impedance-Control" class="headerlink" title="Impedance Control"></a>Impedance Control</h3><p>由于impedance的性质是接受flow而产生effort，因此一个impedance controller应当是以位置信息作为输入，以力的信息（关节力矩）为输出。考虑公式（1）与公式（2），得到如下的impedance控制系统：</p>
<script type="math/tex; mode=display">
F=m\ddot x - \left( M_d \ddot{e}+D_d \dot{e}+K_d e \right) \quad\quad(3)</script><img src="/2020/12/02/9-Others/%E9%98%BB%E6%8A%97%E6%8E%A7%E5%88%B6/1606305246402.png" class>
<p>有时候公式（3）中的加速度，包括$\ddot x$和$\ddot e$，比较难测量，可以通过测量$F_{ext}$来进行简化：</p>
<script type="math/tex; mode=display">
F=\left(\frac{m}{M_d}-1\right) F_{\mathrm{ext}}+m \ddot{x}_{0}-\frac{m}{M_d}\left(D_d \dot{e}+K_d e\right) \quad\quad(4)</script><img src="/2020/12/02/9-Others/%E9%98%BB%E6%8A%97%E6%8E%A7%E5%88%B6/1606306619679.png" class>
<h3 id="Admittance-Control"><a href="#Admittance-Control" class="headerlink" title="Admittance Control"></a>Admittance Control</h3><p>admittance接受effort而产生flow，因此admittance controller应当是以测量的交互力作为输入，以位置指令作为输出。一种简单的实现方法可以通过计算期望的加速度来得到：</p>
<script type="math/tex; mode=display">
M_d \ddot{e}_d+D_d \dot{e}+K_de=F_{\mathrm{ext}}</script><script type="math/tex; mode=display">
\ddot{x}_d =  \ddot{x}_\mathrm{0} +\frac{1}{M_d}(F_{\mathrm{ext}}-D_d \dot{e}-K_d e ) \quad\quad(5)</script><img src="/2020/12/02/9-Others/%E9%98%BB%E6%8A%97%E6%8E%A7%E5%88%B6/1606308814888.png" class>
<hr>
<p>这两种控制方式各有利弊，可以看出impedence control方法可以不用测量交互力的数据，但需要知道系统的动力学模型，这种方法在与环境交互的时候稳定性（柔顺性）比较好的，但无接触时实际上为开环系统，位置控制精度受制于建模精度；admittance control方法不需要进行系统动力学建模，在伺服任务中有较高位置精度，但与同样是admittance的环境交互时柔顺性较差，系统容易不稳定。</p>
<p>在实际的使用中，impedance/admittance control的实现方式远不止上面几种，根据系统的硬件结构、测量数据、反馈信号、工作空间的不同，可以设计各种形式的impedance controller。以机械臂为例，我们可以将机械末端笛卡尔坐标系下的阻抗模型通过雅克比矩阵转化到关节空间下进行实现：</p>
<script type="math/tex; mode=display">
\tau=J^{\mathrm{T}}(\theta)\left(\underbrace{\tilde{\Lambda}(\theta) \ddot{x}+\tilde{\eta}(\theta, \dot{x})}_{\text {arm dynamics compensation }}-\underbrace{(M \ddot{x}+B \dot{x}+K x)}_{f_{\text {ext }}}\right)</script><p>以上就是Impedance Control在控制领域的具体实现。实际上Impedance的概念可以应用到诸多领域，下面一部分将主要介绍Impedance与人体运动。</p>
<h2 id="Part-III-Impedance-and-Human-Movement"><a href="#Part-III-Impedance-and-Human-Movement" class="headerlink" title="Part III - Impedance and Human Movement"></a>Part III - Impedance and Human Movement</h2><p>人体的运动系统是这世界上最神奇的事物之一。在神经肌肉骨骼的共同作用下，人类得以实现无比丰富而复杂的动作，得以使用和制作各种工具，从而由古猿进化为智人，进化为这颗星球上最具智慧的生命。人体的运动千变万化，既有舞蹈那般的优雅流畅，又有雕刻那样准确精细；既有举重那般爆发力量，又可如武术那样灵巧迅捷。千百年来，人们试图去理解人体运动的本质，理解神经系统运动控制的机制，从而实现更加拟人的机器人运动与人类相协同，从而设计更智能的假肢帮助残疾人恢复运动功能。Impedance就是这样一种理解人体运动的方式。</p>
<img src="/2020/12/02/9-Others/%E9%98%BB%E6%8A%97%E6%8E%A7%E5%88%B6/Muscle.png" class>
<p>人体的运动系统由神经-肌肉-骨骼共同构成，神经信号刺激肌肉收缩，肌肉收缩带动骨骼运动。尽管人体的肌肉并不是能量保守的，但却具有很明显的阻抗特性，Hill肌肉模型就是将肌肉表示为收缩单元与串联弹簧与并联弹簧的组合，人体的驱动器-肌肉本身就类似于SEA；而用来表示肌肉收缩动力学的力-长度与力-速度关系，则可以看作是阻抗控制中的刚度参数和阻尼参数。</p>
<p>由于肌肉只能单向驱动一个关节，因此为了实现关节层次的阻抗调节，需要相对立的两块肌肉共同收缩，这在生理学上称为<strong>Cocontraction of antagonistic muscle groups</strong>。想象着你从空中跳跃而下，在接触地面之时你需要保持腿部各关节的肌肉收缩来实现关节刚度的增加，以避免不必要的伤害；再考虑球场上你面对传来的篮球，下意识增加手腕处对立肌肉的收缩，从而能稳稳地接住它。<strong>通过调节关节阻抗来对抗环境的不稳定，是人体生理神经系统的基本准则；而通过学习利用自身或环境的动力学、减少不必要的阻抗和肌肉消耗，是我们适应这个世界基本方式。</strong></p>
<p>当从阻抗的角度去理解人体运动时，能够得到比直观想象更是深刻一些的思考。人体肌肉系统一个特点是具有高度冗余，连接一个关节两侧骨骼的肌肉远远多于驱动该关节所必须的肌肉，甚至存在很多跨越多个关节的肌肉，例如上肢中最简单的肘关节就是由肱肌、肱桡肌、二头肌短头和二头肌长头共同作用。<strong>这种肌肉系统的冗余与复杂性对于阻抗控制来说起到什么作用？</strong></p>
<h3 id="Muscle-Redundancies"><a href="#Muscle-Redundancies" class="headerlink" title="Muscle Redundancies"></a>Muscle Redundancies</h3><img src="/2020/12/02/9-Others/%E9%98%BB%E6%8A%97%E6%8E%A7%E5%88%B6/fig4.png" class>
<p>考虑由大臂、小臂和躯干组成的二连杆模型在平面进行运动的情况，如图(a)所示。将手部视为刚体并忽略腕关节的自由度。为简化分析，将肌肉用弹簧进行描述，弹簧的刚度系数可以由神经信号进行调整。首先研究只有单关节肌肉的情况，图(b)所示。记相对关节角度为$\rho_1$,$\rho_2$，肩关节和肘关节的刚度系数分别为$K_s$,$K_e$，则关节力矩可以表示为如下形式：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{c}
T_{1} \\
T_{2}
\end{array}\right]=\left[\begin{array}{cc}
K_s & 0 \\
0 & K_e
\end{array}\right]\left[\begin{array}{l}
\rho_{1} \\
\rho_{2}
\end{array}\right]</script><p>式中的矩阵称为刚度矩阵，反应关节阻抗特性。由于我们更关心末端执行器-手部，与环境交互时的阻抗特性，因此进一步将上面的阻抗关系变化到笛卡尔坐标下。考虑相对关节角度与绝对关节角度之间的变化关系：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{c}
\rho_{1} \\
\rho_{2}
\end{array}\right]=\left[\begin{array}{rr}
1 & 0 \\
-1 & 1
\end{array}\right]\left[\begin{array}{l}
\theta_{1} \\
\theta_{2}
\end{array}\right] = T\left[\begin{array}{l}
\theta_{1} \\
\theta_{2}
\end{array}\right]=K_\theta \theta</script><p>绝对关节角坐标系下的阻抗关系为：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{c}
T_{1} \\
T_{2}
\end{array}\right]=T^T\left[\begin{array}{cc}
K_s & 0 \\
0 & K_e
\end{array}\right]T\left[\begin{array}{l}
\theta_{1} \\
\theta_{2}
\end{array}\right]
=\left[\begin{array}{cc}
K_s+K_e & -K_e \\
-K_e & K_e
\end{array}\right]\left[\begin{array}{l}
\theta_{1} \\
\theta_{2}
\end{array}\right]</script><p>末端位置到关节角度的雅克比矩阵为：</p>
<script type="math/tex; mode=display">
J=\left[\begin{array}{cc}
-L_{1} \sin \theta_{1} & -L_{2} \sin \theta_{2} \\
L_{1} \cos \theta_{1} & L_{2} \cos \theta_{2}
\end{array}\right]</script><p>关节阻抗到末端阻抗的变换关系为：</p>
<script type="math/tex; mode=display">
\tau=J^TF \Rightarrow  K_\theta d\theta = J^TK_x dx \Rightarrow K_\theta  = J^TK_x J \Rightarrow K_x  = (J^T)^{-1}K_\theta J^{-1}</script><p>假定$L_1=L_2=1$，并令$\Lambda=C_1S_2-S_1C_2$，则有：</p>
<script type="math/tex; mode=display">
K_x = \frac{K_s}{\Lambda^2} \left[\begin{array}{cc}
C_2^2 & S_2C_2\\
S_2C_2 & S_2^2
\end{array}\right]+
 \frac{K_e}{\Lambda^2} \left[\begin{array}{cc}
(C_1+C_2)^2 & (S_1+S_2)(C_1+C_2)\\
(S_1+S_2)(C_1+C_2) & (S_1+S_2)^2
\end{array}\right]</script><p>虽然在相对关节角度坐标系下刚度矩阵是对角的，但在末端笛卡尔坐标系下刚度矩阵一般不再具有对角性。通过调节关节刚度$K_s$和$K_e$，可以实现对末端笛卡尔坐标系下的阻抗调节，且肌肉的冗余度越高，则对于阻抗的调节就越灵活。但由于刚度矩阵有三个自由变量（对称性），因此调节$K_s$和$K_e$无法实现任意形式阻抗模式。考虑当$\theta_1=0, \theta_2=90^{\circ} $时，$\Lambda=1$，$K_x$可以表示为如下形式：</p>
<script type="math/tex; mode=display">
K_x = {K_s} \left[\begin{array}{cc}
0 & 0\\
0 & 1
\end{array}\right]+
{K_e}\left[\begin{array}{cc}
1 & 1\\
1 & 1
\end{array}\right]</script><p>上式表明无论人体如何调整关节的刚度系数或是肌肉的收缩程度，都不可能使末端笛卡尔坐标下的刚度矩阵等于单位矩阵。若进一步用刚度椭圆来表示表示刚度矩阵（长轴和短轴分别代表刚度矩阵的两个特征值，长轴和短轴的方向分别为特征向量的方向），可以看出随着关节刚度的调节，末端笛卡尔坐标系下刚度椭圆的长轴只能够在如下深蓝和深红两条虚线内变化。在这样的阻抗特性下，手臂末端更容易对抗平行于蓝色虚线的扰动，而容易收到垂直于蓝色虚线的扰动的影响；也就是说在这样的阻抗特性下，你会很容易写出丿，却很难写出㇏。</p>
<p><img src="/2020/12/02/9-Others/%E9%98%BB%E6%8A%97%E6%8E%A7%E5%88%B6/Stiffness.png" width="60%"></p>
<p>现在向这个二连杆机构引入双关节肌肉，在双关节肌肉和单关节肌肉的共同作用下，相对关节角度坐标系下的阻抗特性如下：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{c}
T_{1} \\
T_{2}
\end{array}\right]=\left[\begin{array}{cc}
K s+K t & K t \\
K t & K e+K t
\end{array}\right]\left[\begin{array}{l}
\rho_{1} \\
\rho_{2}
\end{array}\right]</script><p>将其变换到末端笛卡尔坐标系下，可得：</p>
<script type="math/tex; mode=display">
K_x = \frac{K_s}{\Lambda^2} \left[\begin{array}{cc}
C_2^2 & S_2C_2\\
S_2C_2 & S_2^2
\end{array}\right]+
 \frac{K_e}{\Lambda^2} \left[\begin{array}{cc}
(C_1+C_2)^2 & (S_1+S_2)(C_1+C_2)\\
(S_1+S_2)(C_1+C_2) & (S_1+S_2)^2
\end{array}\right]+
\frac{K_t}{\Lambda^2} \left[\begin{array}{cc}
C_1^2 & S_1C_1\\
S_1C_1 & S_1^2
\end{array}\right]</script><p>第三个参数$K_t$增加了刚度矩阵的可调节范围，甚至在一定工作空间内可以实现任意形式的阻抗特性。依然考虑$\theta_1=0, \theta_2=90^{\circ} $的情况：</p>
<script type="math/tex; mode=display">
K_x = {K_s} \left[\begin{array}{cc}
0 & 0\\
0 & 1
\end{array}\right]+
{K_e}\left[\begin{array}{cc}
1 & 1\\
1 & 1
\end{array}\right]+
{K_t}\left[\begin{array}{cc}
1 & 0\\
0 & 0
\end{array}\right]</script><p>可以看出只要取$K_s=1, K_e=0, K_t=1$就可以使$K_x$为单位矩阵，甚至当前位姿下，通过调节$K_s, K_e, K_t$几乎可以实现任意形式的刚度矩阵，末端笛卡尔坐标系下可以表现出任意形式的阻抗特性，正如下图所展示的那样。</p>
<p><img src="/2020/12/02/9-Others/%E9%98%BB%E6%8A%97%E6%8E%A7%E5%88%B6/Stiffness2.png" width="60%"></p>
<p><strong>由此，人体肌肉系统的冗余与复杂是有明确意义的，这经过亿万年进化而来的肌肉系统，增加了人体阻抗-尤其是末端阻抗的可调范围，使人类尽可能少的受到自身能力的限制，能够根据需要任意调整与环境交互时的阻抗特性，灵巧的使用各种工具来拓宽其生存边界与层次。</strong></p>
<h3 id="Impedance-Learning"><a href="#Impedance-Learning" class="headerlink" title="Impedance Learning"></a>Impedance Learning</h3><p>而人体的运动控制，可以很自然的看做是对于阻抗特性的学习。还是以手臂二自由度平面运动为例，在2001年的一篇Nature论文The central nervous system stabilizes unstable dynamics by learning optimal impedance中，研究人员通过与交互的机械臂在运动区域内构建了一个扩散力场（如下图所示）：当手臂末端运动偏离预定轨迹时会在$x$方向上受到干扰作用力，且随着偏差加大，作用力也越大，因此具有不稳定的特性。</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
F_{x} \\
F_{y}
\end{array}\right]=\left[\begin{array}{l}
\beta x \\
0
\end{array}\right]</script><p><img src="/2020/12/02/9-Others/%E9%98%BB%E6%8A%97%E6%8E%A7%E5%88%B6/1606907817857.png" width="60%"></p>
<p>研究人员令受试者分别在无力场、有扩散力场的条件下，分别控制手臂末端沿y方向进行运动。在没有力场的作用下，受试者能够实现良好的运动轨迹；在刚施加扩散力场后，受试者的运动变得不稳定，而经过一段时间的学习后，受试者恢复了良好的运动轨迹。研究人员测量了不同受试者在力场作用前后的末端阻抗特性，刚度椭圆无一例外的增加了x方向上的长度，也就是增加了x方向上的刚度系数，使得能够对抗来自x方向上扩散力场的扰动。</p>
<p><img src="/2020/12/02/9-Others/%E9%98%BB%E6%8A%97%E6%8E%A7%E5%88%B6/1606908189253.png" width="60%"></p>
<p>在扩散力场的作用下，人体的神经系统学会了新的阻抗特性来适应环境。类似的例子还有很多，当你骑自行车时，你用双手控制车把使车把表现出阻抗特性，使受到扰动后能恢复车把与前进方向平行；当你使用螺丝刀时，你控制螺丝刀在非法向方向上保持较高的阻抗，使得螺丝刀不会因为扰动而滑落。对于一切稳定和不稳定的环境，人体学习调整自身的肌肉表现适当的阻抗形式使交互过程保持稳定，再学习利用环境和自身的动力学特性使交互的动态过程更有效率。</p>
<p><strong>因此，人体运动控制本质是对阻抗特性的控制，学习环境（外部条件）、位姿（内部状态）与阻抗之间的映射关系，学习刚（admittance）柔（impedance）之间的相互转化，学习鲁棒与最优之间的动态平衡；而最终，促成了人类丰富多彩的世界。</strong></p>
<hr>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>Hogan N. Impedance control: An approach to manipulation: Part I—Theory[J]. 1985.</li>
<li>Hogan N. Impedance control: An approach to manipulation: Part II—Implementation[J]. 1985.</li>
<li>Ott C, Mukherjee R, Nakamura Y. Unified impedance and admittance control[C]//2010 IEEE International Conference on Robotics and Automation. IEEE, 2010: 554-561.</li>
<li>Kevin M.. Lynch, Park F C. Modern Robotics: Mechanics, Planning, and Control[M]. Cambridge University Press, 2017.</li>
<li>Milner T E. Adaptation to destabilizing dynamics by means of muscle cocontraction[J]. Experimental brain research, 2002, 143(4): 406-416.</li>
<li>Burdet E, Osu R, Franklin D W, et al. The central nervous system stabilizes unstable dynamics by learning optimal impedance[J]. Nature, 2001, 414(6862): 446-449.</li>
</ol>
]]></content>
      <categories>
        <category>control</category>
      </categories>
      <tags>
        <tag>阻抗控制</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础 1 - 序列 Sequence Interface</title>
    <url>/2022/05/01/1-Course/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/01-%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<img src="/2022/05/01/1-Course/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/01-%E5%BA%8F%E5%88%97/2.png" class title="Q1的副本.png">
<span id="more"></span>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>序列用于维护数据元素的外部顺序，每个元素按照等级顺序存储在序列中。这里的外部顺序，是指在接口以外定义的，例如排序顺序、优先级顺序等。序列接口是栈和队列的一般化表示。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><img src="/2022/05/01/1-Course/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/01-%E5%BA%8F%E5%88%97/1.png" class title="Untitled">
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><img src="/2022/05/01/1-Course/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/01-%E5%BA%8F%E5%88%97/2.png" class title="Q1的副本.png">
<hr>
<h3 id="数组（Array-Sequence）"><a href="#数组（Array-Sequence）" class="headerlink" title="数组（Array Sequence）"></a>数组（Array Sequence）</h3><ul>
<li>在RAM模型下，机器可以直接访问已知地址，因此<code>get_at</code>和<code>set_at</code>操作需要常数时间O(1)</li>
<li>当时数组长度发生变化时，存储空间需要重新分配，因此需要线性时间O(n)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array_Seq</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span>                     <span class="comment"># O(1)</span></span><br><span class="line">        self.A = []</span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span> <span class="keyword">return</span> self.size     <span class="comment"># O(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span> <span class="keyword">yield</span> <span class="keyword">from</span> self.A   <span class="comment"># O(n)</span></span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">self, X</span>):</span>                     <span class="comment"># O(n)</span></span><br><span class="line">        self.A = [<span class="literal">None</span>] * <span class="built_in">len</span>(X)            <span class="comment"># pretend this builds a static array</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> X:</span><br><span class="line">            self.A[i] = a</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        self.size = <span class="built_in">len</span>(self.A)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_at</span>(<span class="params">self, i</span>):</span> <span class="keyword">return</span> self.A[i]   <span class="comment"># O(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_at</span>(<span class="params">self, i, x</span>):</span> self.A[i] = x   <span class="comment"># O(1)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_at</span>(<span class="params">self, i, x</span>):</span>              <span class="comment"># O(n)</span></span><br><span class="line">        n = <span class="built_in">len</span>(self)</span><br><span class="line">        new_A = [<span class="literal">None</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i-<span class="number">1</span>):</span><br><span class="line">            new_A[k] = self.A[k]</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i-<span class="number">1</span>, n):</span><br><span class="line">            new_A[k+<span class="number">1</span>] = self.A[k]</span><br><span class="line">        new_A[i-<span class="number">1</span>] = x</span><br><span class="line">        self.build(new_A)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete_at</span>(<span class="params">self, i</span>):</span>                 <span class="comment"># O(n)</span></span><br><span class="line">        n = <span class="built_in">len</span>(self)</span><br><span class="line">        x = self.A[i-<span class="number">1</span>]</span><br><span class="line">        new_A = [<span class="literal">None</span>] * (n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i-<span class="number">1</span>):</span><br><span class="line">            new_A[k] = self.A[k]</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i, n):</span><br><span class="line">            new_A[k-<span class="number">1</span>] = self.A[k]</span><br><span class="line">        self.build(new_A)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_first</span>(<span class="params">self, x</span>):</span>  self.insert_at(<span class="number">1</span>, x)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_last</span>(<span class="params">self,  x</span>):</span>  self.insert_at(<span class="built_in">len</span>(self)+<span class="number">1</span>, x)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete_first</span>(<span class="params">self</span>):</span> <span class="keyword">return</span> self.delete_at(<span class="number">1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete_last</span>(<span class="params">self</span>):</span> <span class="keyword">return</span> self.delete_at(<span class="built_in">len</span>(self))</span><br><span class="line">		</span><br><span class="line"><span class="comment"># 备注：程序中的序号是以1为开始的</span></span><br></pre></td></tr></table></figure>
<h3 id="链表（Linked-）"><a href="#链表（Linked-）" class="headerlink" title="链表（Linked ）"></a>链表（Linked ）</h3><ul>
<li>有离散的节点组成，每个节点包括一个数据和一个指向下个节点的地址（指针）</li>
<li>只能通过一个节点一个节点的跳转实现指定的索引，时间复杂度为O(n)</li>
<li>适合于序列的增减操作，尤其是在首尾的增减</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Linked_List_Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.item = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">later_node</span>(<span class="params">self, i</span>):</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">assert</span> self.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> self.<span class="built_in">next</span>.later_node(i-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Linked_list_Seq</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        node = self.head</span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            <span class="keyword">yield</span> node.item</span><br><span class="line">            node = node.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">self, X</span>):</span>                     <span class="comment"># O(n)</span></span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">reversed</span>(X):</span><br><span class="line">            self.insert_first(a)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_at</span>(<span class="params">self, i</span>):</span>                    <span class="comment"># O(i)</span></span><br><span class="line">        node = self.head.later_node(i-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> node.item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_at</span>(<span class="params">self, i, x</span>):</span>                 <span class="comment"># O(i)</span></span><br><span class="line">        node = self.head.later_node(i-<span class="number">1</span>)</span><br><span class="line">        node.item = x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_first</span>(<span class="params">self, x</span>):</span>              <span class="comment"># O(1)</span></span><br><span class="line">        new_node = Linked_List_Node(x)</span><br><span class="line">        new_node.<span class="built_in">next</span> = self.head</span><br><span class="line">        self.head = new_node</span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete_first</span>(<span class="params">self</span>):</span>                 <span class="comment"># O(1)</span></span><br><span class="line">        x = self.head.item</span><br><span class="line">        self.head = self.head.<span class="built_in">next</span></span><br><span class="line">        self.size -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_at</span>(<span class="params">self, i, x</span>):</span>              <span class="comment"># O(i)</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">            self.insert_first(x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            new_node = Linked_List_Node(x)</span><br><span class="line">            pre_node = self.head.later_node(i-<span class="number">1</span>-<span class="number">1</span>)</span><br><span class="line">            new_node.<span class="built_in">next</span> = pre_node.<span class="built_in">next</span></span><br><span class="line">            pre_node.<span class="built_in">next</span> = new_node</span><br><span class="line">            self.size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete_at</span>(<span class="params">self, i</span>):</span>                 <span class="comment"># O(i)</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> self.delete_first()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pre_node = self.head.later_node(i-<span class="number">2</span>)</span><br><span class="line">            x = pre_node.<span class="built_in">next</span>.item</span><br><span class="line">            pre_node.<span class="built_in">next</span> = pre_node.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            self.size -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">                                            <span class="comment"># O(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_last</span>(<span class="params">self, x</span>):</span> self.insert_at(<span class="built_in">len</span>(self)+<span class="number">1</span>, x)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete_last</span>(<span class="params">self</span>):</span> <span class="keyword">return</span> self.delete_at(<span class="built_in">len</span>(self))</span><br></pre></td></tr></table></figure>
<h3 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h3><ul>
<li>通过额外分配一定存储空间（如2倍于所需长度），来实现更快速的元素插入；当数组长度超过最大空间时，依然需要重新分配空间，但插入操作的平摊时间是常数的O(1)</li>
<li>当数组长度远小于分配空间时，占用大量存储空间较为浪费，需要重新分配较小的空间（如小于存储空间1/4时，重新分配1/2空间）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 继承001的静态数组</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dynamic_Array_Seq</span>(<span class="params">Array_Seq</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, r=<span class="number">2</span></span>):</span>                <span class="comment"># O(1)</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.r = r</span><br><span class="line">        self._compute_bnouds()</span><br><span class="line">        self._resize(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span> <span class="keyword">return</span> self.size     <span class="comment"># O(1)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span>                     <span class="comment"># O(n)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self)):</span><br><span class="line">            <span class="keyword">yield</span> self.A[i]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">self, X</span>):</span>                     <span class="comment"># O(n)</span></span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> X:</span><br><span class="line">            self.insert_last(a)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_compute_bnouds</span>(<span class="params">self</span>):</span>              <span class="comment"># O(1)</span></span><br><span class="line">        self.upper = <span class="built_in">len</span>(self.A)</span><br><span class="line">        self.lower = <span class="built_in">len</span>(self.A) // (self.r * self.r)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_resize</span>(<span class="params">self, n</span>):</span>                   <span class="comment"># O(1) / O(n)</span></span><br><span class="line">        <span class="keyword">if</span>(self.lower &lt; n &lt; self.upper):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        m = <span class="built_in">max</span>(n, <span class="number">1</span>) * self.r</span><br><span class="line">        A = [<span class="literal">None</span>] * m</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.size):</span><br><span class="line">            A[i] = self.A[i]</span><br><span class="line">        self.A = A</span><br><span class="line">        self._compute_bnouds()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_last</span>(<span class="params">self, x</span>):</span>               <span class="comment"># O(1)a</span></span><br><span class="line">        self._resize(self.size + <span class="number">1</span>)</span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line">        self.A[self.size-<span class="number">1</span>] = x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete_last</span>(<span class="params">self</span>):</span>                  <span class="comment"># O(1)a</span></span><br><span class="line">        self.A[self.size - <span class="number">1</span>] = <span class="literal">None</span></span><br><span class="line">        self.size -= <span class="number">1</span></span><br><span class="line">        self._resize(self.size)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_at</span>(<span class="params">self, i, x</span>):</span>              <span class="comment"># O(n)</span></span><br><span class="line">        self.insert_last(<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(self.size, i-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            self.A[k] = self.A[k-<span class="number">1</span>]</span><br><span class="line">        self.A[i-<span class="number">1</span>] = x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete_at</span>(<span class="params">self, i</span>):</span>                 <span class="comment"># O(n)</span></span><br><span class="line">        x = self.A[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i, self.size):</span><br><span class="line">            self.A[k-<span class="number">1</span>] = self.A[k]</span><br><span class="line">        self.delete_last()</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">                                            <span class="comment"># O(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_first</span>(<span class="params">self, x</span>):</span> self.insert_at(<span class="number">1</span>, x)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete_first</span>(<span class="params">self</span>):</span> <span class="keyword">return</span> self.delete_at(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="二叉树（AVL树）"><a href="#二叉树（AVL树）" class="headerlink" title="二叉树（AVL树）"></a>二叉树（AVL树）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">height</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="keyword">if</span> A:</span><br><span class="line">        <span class="keyword">return</span> A.height</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Binary_Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">A, x</span>):</span></span><br><span class="line">        A.item = x</span><br><span class="line">        A.left = <span class="literal">None</span></span><br><span class="line">        A.right = <span class="literal">None</span></span><br><span class="line">        A.parent = <span class="literal">None</span></span><br><span class="line">        A.subtree_update()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_update</span>(<span class="params">A</span>):</span></span><br><span class="line">        A.height = <span class="number">1</span> + <span class="built_in">max</span>(height(A.left), height(A.right))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skew</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="keyword">return</span> height(A.right) - height(A.left)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_iter</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.left:</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> A.left.subtree_iter()</span><br><span class="line">        <span class="keyword">yield</span> A</span><br><span class="line">        <span class="keyword">if</span> A.right:</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> A.right.subtree_iter()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_first</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.left:</span><br><span class="line">            <span class="keyword">return</span> A.left.subtree_first()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> A</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_last</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.right:</span><br><span class="line">            <span class="keyword">return</span> A.right.subtree_last()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> A</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">successor</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.right:</span><br><span class="line">            <span class="keyword">return</span> A.right.subtree_first()</span><br><span class="line">        <span class="keyword">while</span> A.parent <span class="keyword">and</span> (A <span class="keyword">is</span> A.parent.right):</span><br><span class="line">            A = A.parent</span><br><span class="line">        <span class="keyword">return</span> A.parent</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predecessor</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.left:</span><br><span class="line">            <span class="keyword">return</span> A.left.subtree_last()</span><br><span class="line">        <span class="keyword">while</span> A.parent <span class="keyword">and</span> (A <span class="keyword">is</span> A.parent.left):</span><br><span class="line">            A = A.parent</span><br><span class="line">        <span class="keyword">return</span> A.parent</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_rotate_right</span>(<span class="params">D</span>):</span></span><br><span class="line">        <span class="keyword">if</span> D.left:</span><br><span class="line">            B, E = D.left, D.right</span><br><span class="line">            A, C = B.left, B.right</span><br><span class="line">            D, B = B, D</span><br><span class="line">            D.item, B.item = B.item, D.item</span><br><span class="line">            B.left, B.right = A, D</span><br><span class="line">            D.left, D.right = C, E</span><br><span class="line">            <span class="keyword">if</span> A:</span><br><span class="line">                A.parent = B</span><br><span class="line">            <span class="keyword">if</span> E:</span><br><span class="line">                E.parent = D</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_rotate_left</span>(<span class="params">B</span>):</span></span><br><span class="line">        <span class="keyword">if</span> B.right:</span><br><span class="line">            A, D = B.left, B.right</span><br><span class="line">            C, E = D.left, D.right</span><br><span class="line">            B, D = D, B</span><br><span class="line">            B.item, D.item = D.item, B.item</span><br><span class="line">            D.left, D.right = B, E</span><br><span class="line">            B.left, B.right = A, C</span><br><span class="line">            <span class="keyword">if</span> A:</span><br><span class="line">                A.parent = B</span><br><span class="line">            <span class="keyword">if</span> E:</span><br><span class="line">                E.parent = D</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rebalance</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.skew == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> A.right.skew() &lt; <span class="number">0</span>:</span><br><span class="line">                A.right.subtree_rotate_right()</span><br><span class="line">            A.subtree_rotate_left()</span><br><span class="line">        <span class="keyword">elif</span> A.skew() == -<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> A.left.skew() &gt; <span class="number">0</span>:</span><br><span class="line">                A.left.subtree_rotate_left()</span><br><span class="line">            A.subtree_rotate_right()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maintain</span>(<span class="params">A</span>):</span></span><br><span class="line">        A.rebalance()</span><br><span class="line">        A.subtree_update()</span><br><span class="line">        <span class="keyword">if</span> A.parent:</span><br><span class="line">            A.parent.maintain()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_insert_before</span>(<span class="params">A, B</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.left:</span><br><span class="line">            A = A.left.subtree_last()</span><br><span class="line">            A.right, B.parent = B, A</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            A.left, B.parent = B, A</span><br><span class="line">        A.maintain()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_insert_after</span>(<span class="params">A, B</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.right:</span><br><span class="line">            A = A.right.subtree_first()</span><br><span class="line">            A.left, B.parent = B, A</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            A.right, B.parent = B, A</span><br><span class="line">        A.maintain()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_delete</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.left <span class="keyword">or</span> A.right:</span><br><span class="line">            <span class="keyword">if</span> A.left:</span><br><span class="line">                B = A.predecessor()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                B = A.successor()</span><br><span class="line">            A.item, B.item = B.item, A.item</span><br><span class="line">            <span class="keyword">return</span> B.subtree_delete()</span><br><span class="line">        <span class="keyword">if</span> A.parent:</span><br><span class="line">            <span class="keyword">if</span> A <span class="keyword">is</span> A.parent.left:</span><br><span class="line">                A.parent.left = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                A.parent.right = <span class="literal">None</span></span><br><span class="line">            A.maintain()</span><br><span class="line">        <span class="keyword">return</span> A</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Binary_Tree</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">T, Node_Type=Binary_Node</span>):</span></span><br><span class="line">        T.root = <span class="literal">None</span></span><br><span class="line">        T.size = <span class="number">0</span></span><br><span class="line">        T.Node_Type = Node_Type</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">T</span>):</span> <span class="keyword">return</span> T.size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">T</span>):</span></span><br><span class="line">        <span class="keyword">if</span> T.root:</span><br><span class="line">            <span class="keyword">for</span> A <span class="keyword">in</span> T.root.subtree_iter():</span><br><span class="line">                <span class="keyword">yield</span> A.item</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Size_Node</span>(<span class="params">Binary_Node</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_update</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().subtree_update()</span><br><span class="line">        A.size = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> A.left:</span><br><span class="line">            A.size += A.left.size</span><br><span class="line">        <span class="keyword">if</span> A.right:</span><br><span class="line">            A.size += A.right.size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_at</span>(<span class="params">A, i</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt;= i:</span><br><span class="line">            <span class="keyword">if</span> A.left:</span><br><span class="line">                L_size = A.left.size</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                L_size = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; L_size:</span><br><span class="line">                <span class="keyword">return</span> A.left.subtree_at(i)</span><br><span class="line">            <span class="keyword">elif</span> i &gt; L_size:</span><br><span class="line">                <span class="keyword">return</span> A.right.subtree_at(i - L_size - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> A</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Seq_Binary_Tree</span>(<span class="params">Binary_Tree</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(Size_Node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">self, X</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">build_subtree</span>(<span class="params">X, i, j</span>):</span></span><br><span class="line">            c = (i + j) // <span class="number">2</span></span><br><span class="line">            root = self.Node_Type(X[c])</span><br><span class="line">            <span class="keyword">if</span> i &lt; c:</span><br><span class="line">                root.left = build_subtree(X, i, c - <span class="number">1</span>)</span><br><span class="line">                root.left.parent = root</span><br><span class="line">            <span class="keyword">if</span> c &lt; j:</span><br><span class="line">                root.right = build_subtree(X, c + <span class="number">1</span>, j)</span><br><span class="line">                root.right.parent = root</span><br><span class="line">            root.subtree_update()</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        self.root = build_subtree(X, <span class="number">0</span>, <span class="built_in">len</span>(X) - <span class="number">1</span>)</span><br><span class="line">        self.size = self.root.size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_at</span>(<span class="params">self, i</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.root:</span><br><span class="line">            <span class="keyword">return</span> self.root.subtree_at(i).item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_at</span>(<span class="params">self, i, x</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.root:</span><br><span class="line">            self.root.subtree_at(i).item = x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_at</span>(<span class="params">self, i, x</span>):</span></span><br><span class="line">        new_node = self.Node_Type(x)</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> self.root:</span><br><span class="line">                node = self.root.subtree_first()</span><br><span class="line">                node.subtree_insert_before(new_node)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.root = new_node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node = self.root.subtree_at(i - <span class="number">1</span>)</span><br><span class="line">            node.subtree_insert_after(new_node)</span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete_at</span>(<span class="params">self, i</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.root:</span><br><span class="line">            node = self.root.subtree_at(i)</span><br><span class="line">            ext = node.subtree_delete()</span><br><span class="line">            <span class="keyword">if</span> ext.parent <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                self.root = <span class="literal">None</span></span><br><span class="line">            self.size -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> ext.item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_first</span>(<span class="params">self, x</span>):</span> self.insert_at(<span class="number">0</span>, x)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete_first</span>(<span class="params">self, x</span>):</span> <span class="keyword">return</span> self.delete_at(<span class="number">0</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_last</span>(<span class="params">self, x</span>):</span> self.insert_at(<span class="built_in">len</span>(self), x)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete_last</span>(<span class="params">self</span>):</span> <span class="keyword">return</span> self.delete_at(<span class="built_in">len</span>(self)-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>course</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础 2 - 集合 Set Interface</title>
    <url>/2022/05/01/1-Course/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/02-%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<img src="/2022/05/01/1-Course/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/02-%E9%9B%86%E5%90%88/2.png" class title="Snipaste_2022-09-06_20-49-53的副本.png">
<span id="more"></span>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>集合用于维护数据的内部属性，通常每个项目都具有唯一的键值(key)。集合接口是字典和数据库的一般化表示。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><img src="/2022/05/01/1-Course/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/02-%E9%9B%86%E5%90%88/1.png" class title="Untitled">
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><img src="/2022/05/01/1-Course/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/02-%E9%9B%86%E5%90%88/2.png" class title="Snipaste_2022-09-06_20-49-53的副本.png">
<hr>
<h3 id="数组（Array）"><a href="#数组（Array）" class="headerlink" title="数组（Array）"></a>数组（Array）</h3><ul>
<li>面向序列的数据结构在集合上的应用</li>
<li>只能一个一个元素的查询再操作，效率较低</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Set_from_Seq</span>(<span class="params">seq</span>):</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">set_from_seq</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span> self.S = seq()</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span> <span class="keyword">return</span> <span class="built_in">len</span>(self.S)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span> <span class="keyword">yield</span> <span class="keyword">from</span> self.S</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">self, A</span>):</span></span><br><span class="line">            self.S.build(A)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, x</span>):</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.S)):</span><br><span class="line">                <span class="keyword">if</span> self.S.get_at(i+<span class="number">1</span>).key == x.key:</span><br><span class="line">                    self.S.set_at(i+<span class="number">1</span>, x)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            self.S.insert_last(x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self, k</span>):</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.S)):</span><br><span class="line">                <span class="keyword">if</span> self.S.get_at(i+<span class="number">1</span>).key == k:</span><br><span class="line">                    <span class="keyword">return</span> self.S.delete_at(i+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, k</span>):</span></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> self:</span><br><span class="line">                <span class="keyword">if</span> x.key == k:</span><br><span class="line">                    <span class="keyword">return</span> x</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find_min</span>(<span class="params">self</span>):</span></span><br><span class="line">            out = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> self:</span><br><span class="line">                <span class="keyword">if</span> (out <span class="keyword">is</span> <span class="literal">None</span>) <span class="keyword">or</span> (x.key &lt; out .key):</span><br><span class="line">                    out = x</span><br><span class="line">            <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find_max</span>(<span class="params">self</span>):</span></span><br><span class="line">            out = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> self:</span><br><span class="line">                <span class="keyword">if</span> (out <span class="keyword">is</span> <span class="literal">None</span>) <span class="keyword">or</span> (x.key &gt; out.key):</span><br><span class="line">                    out = x</span><br><span class="line">            <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find_next</span>(<span class="params">self, k</span>):</span></span><br><span class="line">            out = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> self:</span><br><span class="line">                <span class="keyword">if</span> x.key &gt; k:</span><br><span class="line">                    <span class="keyword">if</span> (out <span class="keyword">is</span> <span class="literal">None</span>) <span class="keyword">or</span> (x.key &lt; out.key):</span><br><span class="line">                        out = x</span><br><span class="line">            <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find_prev</span>(<span class="params">self, k</span>):</span></span><br><span class="line">            out = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> self:</span><br><span class="line">                <span class="keyword">if</span> x.key &lt; k:</span><br><span class="line">                    <span class="keyword">if</span> (out <span class="keyword">is</span> <span class="literal">None</span>) <span class="keyword">or</span> (x.key &gt; out.key):</span><br><span class="line">                        out = x</span><br><span class="line">            <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">iter_ord</span>(<span class="params">self</span>):</span></span><br><span class="line">            x = self.find_min()</span><br><span class="line">            <span class="keyword">while</span> x:</span><br><span class="line">                <span class="keyword">yield</span> x</span><br><span class="line">                x = self.find_next(x.key)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> set_from_seq</span><br></pre></td></tr></table></figure>
<h3 id="排序数组（Sorted-Array）"><a href="#排序数组（Sorted-Array）" class="headerlink" title="排序数组（Sorted Array）"></a>排序数组（Sorted Array）</h3><ul>
<li>构建数组时根据键值排序，查找时根据排序定位（二分查找）</li>
<li>插入和删除操作效率较低（需要重新分配空间）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Set_Item</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.index = <span class="literal">None</span></span><br><span class="line">        self.key = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sorted_Array_Set</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span>     self.A = Array_Seq()    <span class="comment"># O(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span> <span class="keyword">return</span> <span class="built_in">len</span>(self.A)           <span class="comment"># O(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span> <span class="keyword">yield</span> <span class="keyword">from</span> self.A           <span class="comment"># O(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">iter_order</span>(<span class="params">self</span>):</span> <span class="keyword">yield</span> <span class="keyword">from</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">self, X</span>):</span></span><br><span class="line">        self.A.build(X)</span><br><span class="line">        self._sort()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_sort</span>(<span class="params">self</span>):</span>    <span class="comment"># bubble sort</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(self.A)):</span><br><span class="line">            j = i</span><br><span class="line">            <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> self.A.get_at(j).key &lt; self.A.get_at(j-<span class="number">1</span>).key:</span><br><span class="line">                temp = self.A.get_at(j-<span class="number">1</span>)</span><br><span class="line">                self.A.set_at(j-<span class="number">1</span>, self.A.get_at(j))</span><br><span class="line">                self.A.set_at(j, temp)</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_binary_search</span>(<span class="params">self, k, i, j</span>):</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= j:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        m = (i + j)//<span class="number">2</span></span><br><span class="line">        x = self.A.get_at(m)</span><br><span class="line">        <span class="keyword">if</span> x.key &gt; k:</span><br><span class="line">            <span class="keyword">return</span> self._binary_search(k, i, m-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> x.key &lt; k:</span><br><span class="line">            <span class="keyword">return</span> self._binary_search(k, m+<span class="number">1</span>, j)</span><br><span class="line">        <span class="keyword">return</span> m</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_min</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.A) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.A.get_at(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_max</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.A) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.A.get_at(<span class="built_in">len</span>(self.A)-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, k</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.A) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        i = self._binary_search(k, <span class="number">0</span>, <span class="built_in">len</span>(self.A)-<span class="number">1</span>)</span><br><span class="line">        x = self.A.get_at(i)</span><br><span class="line">        <span class="keyword">if</span> x.key == k:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_next</span>(<span class="params">self, k</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.A) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        i = self._binary_search(k, <span class="number">0</span>, <span class="built_in">len</span>(self.A)-<span class="number">1</span>)</span><br><span class="line">        x = self.A.get_at(i)</span><br><span class="line">        <span class="keyword">if</span> x.key &gt; k:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        <span class="keyword">if</span> i+<span class="number">1</span> &lt; <span class="built_in">len</span>(self.A):</span><br><span class="line">            <span class="keyword">return</span> self.A.get_at(i+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_prev</span>(<span class="params">self, k</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.A) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        i = self._binary_search(k, <span class="number">0</span>, <span class="built_in">len</span>(self.A)-<span class="number">1</span>)</span><br><span class="line">        x = self.A.get_at(i)</span><br><span class="line">        <span class="keyword">if</span> x.key &lt; k:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.A.get_at(i-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.A) == <span class="number">0</span>:</span><br><span class="line">            self.A.insert_first(x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i = self._binary_search(x.key, <span class="number">0</span>, <span class="built_in">len</span>(self.A)-<span class="number">1</span>)</span><br><span class="line">            k = self.A.get_at(i).key</span><br><span class="line">            <span class="keyword">if</span> k == x.key:</span><br><span class="line">                self.A.set_at(i, x)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> k &gt; x.key:</span><br><span class="line">                self.A.insert_at(i+<span class="number">1</span>, x)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.A.insert_at(i+<span class="number">2</span>, x)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self, k</span>):</span></span><br><span class="line">        i = self._binary_search(k, <span class="number">0</span>, <span class="built_in">len</span>(self.A)-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> self.A.get_at(i).key == k:</span><br><span class="line">            <span class="keyword">return</span> self.A.delete_at(i+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="直接寻址表（Direct-Access-Arrays）"><a href="#直接寻址表（Direct-Access-Arrays）" class="headerlink" title="直接寻址表（Direct Access Arrays）"></a>直接寻址表（Direct Access Arrays）</h3><ul>
<li>将元素的键值映射到计算机的内存地址，直接地址来访问键值</li>
<li>该数据结构用空间换取快速的查询时间，但在键值取值范围较大时浪费存储空间，同时<code>find_prev</code>和<code>find_next</code>等操作效率较低</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DirectAccessArray</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, u</span>):</span> self.A = [<span class="literal">None</span>] * u</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, k</span>):</span> <span class="keyword">return</span> self.A[k]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, x</span>):</span> self.A[x.key] = x</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self, k</span>):</span> self.A[k] = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_next</span>(<span class="params">self, k</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, <span class="built_in">len</span>(self.A)):</span><br><span class="line">            <span class="keyword">if</span> self.A[i] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> self.A[i]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_max</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.A)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> self.A[i] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> self.A[i]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete_max</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.A)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> self.A[i] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                x = self.A[i]</span><br><span class="line">                self.A[i] = <span class="literal">None</span></span><br><span class="line">                <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<h3 id="哈希表（Hashing）"><a href="#哈希表（Hashing）" class="headerlink" title="哈希表（Hashing）"></a>哈希表（Hashing）</h3><ul>
<li>将元素的键值映射一个更小的空间上，再映射到直接访问数组</li>
<li>前一个映射函数称为哈希函数，这个更小的空间称为哈希表</li>
<li>当两个键值映射到相同的哈希值时，会发生冲突（collide），此时可以将冲突存储在直接访问数组的其他地方（开放寻址，open addressing），或另找一些地方来存储（链接，chaining）</li>
<li>通用哈希函数：</li>
</ul>
<script type="math/tex; mode=display">
\mathcal{H}(m, p)=\left\{h_{a b}(k)=(((a k+b) \bmod p) \bmod m) \quad a, b \in\{0, \ldots, p-1\} \text { and } a \neq 0\right\}</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hash_Table_Set</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, r=<span class="number">200</span></span>):</span></span><br><span class="line">        self.chain_set = Set_from_Seq(Linked_list_Seq)</span><br><span class="line">        self.A = []</span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line">        self.r = r</span><br><span class="line">        self.p = <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span></span><br><span class="line">        self.a = random.randint(<span class="number">1</span>, self.p - <span class="number">1</span>)</span><br><span class="line">        self._compute_bounds()</span><br><span class="line">        self._resize(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span> <span class="keyword">return</span> self.size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> X <span class="keyword">in</span> self.A:</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> X</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">self, X</span>):</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> X:</span><br><span class="line">            self.insert(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_hash</span>(<span class="params">self, k, m</span>):</span></span><br><span class="line">        <span class="keyword">return</span> ((self.a * k) % self.p) % m</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_compute_bounds</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.upper = <span class="built_in">len</span>(self.A)</span><br><span class="line">        self.lower = <span class="built_in">len</span>(self.A) * <span class="number">100</span>*<span class="number">100</span> // (self.r * self.r)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_resize</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="keyword">if</span> (self.lower &gt;= n) <span class="keyword">or</span> (n &gt;= self.upper):</span><br><span class="line">            f = self.r // <span class="number">100</span></span><br><span class="line">            <span class="keyword">if</span> self.r % <span class="number">100</span>:</span><br><span class="line">                f += <span class="number">1</span></span><br><span class="line">            m = <span class="built_in">max</span>(n, <span class="number">1</span>) * f</span><br><span class="line">            A = [self.chain_set() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> self:</span><br><span class="line">                h = self._hash(x.key, m)</span><br><span class="line">                A[h].insert(x)</span><br><span class="line">            self.A = A</span><br><span class="line">            self._compute_bounds()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, k</span>):</span></span><br><span class="line">        h = self._hash(k, <span class="built_in">len</span>(self.A))</span><br><span class="line">        <span class="keyword">return</span> self.A[h].find(k)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self._resize(self.size + <span class="number">1</span>)</span><br><span class="line">        h = self._hash(x.key, <span class="built_in">len</span>(self.A))</span><br><span class="line">        added = self.A[h].insert(x)</span><br><span class="line">        <span class="keyword">if</span> added:</span><br><span class="line">            self.size += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> added</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self, k</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self) &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        h = self._hash(k, <span class="built_in">len</span>(self.A))</span><br><span class="line">        x = self.A[h].delete(k)</span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.size -= <span class="number">1</span></span><br><span class="line">            self._resize(self.size)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_min</span>(<span class="params">self</span>):</span></span><br><span class="line">        out = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> self:</span><br><span class="line">            <span class="keyword">if</span> (out <span class="keyword">is</span> <span class="literal">None</span>) <span class="keyword">or</span> (x.key &lt; out.key):</span><br><span class="line">                out = x</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_max</span>(<span class="params">self</span>):</span></span><br><span class="line">        out = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> self:</span><br><span class="line">            <span class="keyword">if</span> (out <span class="keyword">is</span> <span class="literal">None</span>) <span class="keyword">or</span> (x.key &gt; out.key):</span><br><span class="line">                out = x</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_next</span>(<span class="params">self, k</span>):</span></span><br><span class="line">        out = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> self:</span><br><span class="line">            <span class="keyword">if</span> x.key &gt; k:</span><br><span class="line">                <span class="keyword">if</span> (out <span class="keyword">is</span> <span class="literal">None</span>) <span class="keyword">or</span> (x.key &lt; out.key):</span><br><span class="line">                    out = x</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_prev</span>(<span class="params">self, k</span>):</span></span><br><span class="line">        out = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> self:</span><br><span class="line">            <span class="keyword">if</span> x.key &lt; k:</span><br><span class="line">                <span class="keyword">if</span> (out <span class="keyword">is</span> <span class="literal">None</span>) <span class="keyword">or</span> (x.key &gt; out.key):</span><br><span class="line">                    out = x</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">iter_order</span>(<span class="params">self</span>):</span></span><br><span class="line">        x = self.find_min()</span><br><span class="line">        <span class="keyword">while</span> x:</span><br><span class="line">            <span class="keyword">yield</span> x</span><br><span class="line">            x = self.find_next(x.key)</span><br></pre></td></tr></table></figure>
<h3 id="二叉树（AVL树）"><a href="#二叉树（AVL树）" class="headerlink" title="二叉树（AVL树）"></a>二叉树（AVL树）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">height</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="keyword">if</span> A:</span><br><span class="line">        <span class="keyword">return</span> A.height</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Binary_Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">A, x</span>):</span></span><br><span class="line">        A.item = x</span><br><span class="line">        A.left = <span class="literal">None</span></span><br><span class="line">        A.right = <span class="literal">None</span></span><br><span class="line">        A.parent = <span class="literal">None</span></span><br><span class="line">        A.subtree_update()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_update</span>(<span class="params">A</span>):</span></span><br><span class="line">        A.height = <span class="number">1</span> + <span class="built_in">max</span>(height(A.left), height(A.right))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skew</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="keyword">return</span> height(A.right) - height(A.left)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_iter</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.left:</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> A.left.subtree_iter()</span><br><span class="line">        <span class="keyword">yield</span> A</span><br><span class="line">        <span class="keyword">if</span> A.right:</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> A.right.subtree_iter()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_first</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.left:</span><br><span class="line">            <span class="keyword">return</span> A.left.subtree_first()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> A</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_last</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.right:</span><br><span class="line">            <span class="keyword">return</span> A.right.subtree_last()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> A</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">successor</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.right:</span><br><span class="line">            <span class="keyword">return</span> A.right.subtree_first()</span><br><span class="line">        <span class="keyword">while</span> A.parent <span class="keyword">and</span> (A <span class="keyword">is</span> A.parent.right):</span><br><span class="line">            A = A.parent</span><br><span class="line">        <span class="keyword">return</span> A.parent</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predecessor</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.left:</span><br><span class="line">            <span class="keyword">return</span> A.left.subtree_last()</span><br><span class="line">        <span class="keyword">while</span> A.parent <span class="keyword">and</span> (A <span class="keyword">is</span> A.parent.left):</span><br><span class="line">            A = A.parent</span><br><span class="line">        <span class="keyword">return</span> A.parent</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_rotate_right</span>(<span class="params">D</span>):</span></span><br><span class="line">        <span class="keyword">if</span> D.left:</span><br><span class="line">            B, E = D.left, D.right</span><br><span class="line">            A, C = B.left, B.right</span><br><span class="line">            D, B = B, D</span><br><span class="line">            D.item, B.item = B.item, D.item</span><br><span class="line">            B.left, B.right = A, D</span><br><span class="line">            D.left, D.right = C, E</span><br><span class="line">            <span class="keyword">if</span> A:</span><br><span class="line">                A.parent = B</span><br><span class="line">            <span class="keyword">if</span> E:</span><br><span class="line">                E.parent = D</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_rotate_left</span>(<span class="params">B</span>):</span></span><br><span class="line">        <span class="keyword">if</span> B.right:</span><br><span class="line">            A, D = B.left, B.right</span><br><span class="line">            C, E = D.left, D.right</span><br><span class="line">            B, D = D, B</span><br><span class="line">            B.item, D.item = D.item, B.item</span><br><span class="line">            D.left, D.right = B, E</span><br><span class="line">            B.left, B.right = A, C</span><br><span class="line">            <span class="keyword">if</span> A:</span><br><span class="line">                A.parent = B</span><br><span class="line">            <span class="keyword">if</span> E:</span><br><span class="line">                E.parent = D</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rebalance</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.skew == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> A.right.skew() &lt; <span class="number">0</span>:</span><br><span class="line">                A.right.subtree_rotate_right()</span><br><span class="line">            A.subtree_rotate_left()</span><br><span class="line">        <span class="keyword">elif</span> A.skew() == -<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> A.left.skew() &gt; <span class="number">0</span>:</span><br><span class="line">                A.left.subtree_rotate_left()</span><br><span class="line">            A.subtree_rotate_right()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maintain</span>(<span class="params">A</span>):</span></span><br><span class="line">        A.rebalance()</span><br><span class="line">        A.subtree_update()</span><br><span class="line">        <span class="keyword">if</span> A.parent:</span><br><span class="line">            A.parent.maintain()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_insert_before</span>(<span class="params">A, B</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.left:</span><br><span class="line">            A = A.left.subtree_last()</span><br><span class="line">            A.right, B.parent = B, A</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            A.left, B.parent = B, A</span><br><span class="line">        A.maintain()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_insert_after</span>(<span class="params">A, B</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.right:</span><br><span class="line">            A = A.right.subtree_first()</span><br><span class="line">            A.left, B.parent = B, A</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            A.right, B.parent = B, A</span><br><span class="line">        A.maintain()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_delete</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.left <span class="keyword">or</span> A.right:</span><br><span class="line">            <span class="keyword">if</span> A.left:</span><br><span class="line">                B = A.predecessor()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                B = A.successor()</span><br><span class="line">            A.item, B.item = B.item, A.item</span><br><span class="line">            <span class="keyword">return</span> B.subtree_delete()</span><br><span class="line">        <span class="keyword">if</span> A.parent:</span><br><span class="line">            <span class="keyword">if</span> A <span class="keyword">is</span> A.parent.left:</span><br><span class="line">                A.parent.left = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                A.parent.right = <span class="literal">None</span></span><br><span class="line">            A.maintain()</span><br><span class="line">        <span class="keyword">return</span> A</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BST_Node</span>(<span class="params">Binary_Node</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_find</span>(<span class="params">A, k</span>):</span></span><br><span class="line">        <span class="keyword">if</span> k &lt; A.item.key:</span><br><span class="line">            <span class="keyword">if</span> A.left:</span><br><span class="line">                <span class="keyword">return</span> A.left.subtree_find(k)</span><br><span class="line">        <span class="keyword">elif</span> k &gt; A.item.key:</span><br><span class="line">            <span class="keyword">if</span> A.right:</span><br><span class="line">                <span class="keyword">return</span> A.right.subtree_find(k)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> A</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_find_next</span>(<span class="params">A, k</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.item &lt;= k:</span><br><span class="line">            <span class="keyword">if</span> A.right:</span><br><span class="line">                <span class="keyword">return</span> A.right.subtree_find_next(k)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">elif</span> A.left:</span><br><span class="line">            B = A.left.subtree_find_next(k)</span><br><span class="line">            <span class="keyword">if</span> B:</span><br><span class="line">                <span class="keyword">return</span> B</span><br><span class="line">        <span class="keyword">return</span> A</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_find_prev</span>(<span class="params">A, k</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.item &gt;= k:</span><br><span class="line">            <span class="keyword">if</span> A.left:</span><br><span class="line">                <span class="keyword">return</span> A.left.subtree_find_prev(k)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">elif</span> A.right:</span><br><span class="line">            B = A.right.subtree_find_prev(k)</span><br><span class="line">            <span class="keyword">if</span> B:</span><br><span class="line">                <span class="keyword">return</span> B</span><br><span class="line">        <span class="keyword">return</span> A</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_insert</span>(<span class="params">A, B</span>):</span></span><br><span class="line">        <span class="keyword">if</span> B.item &lt; A.item:</span><br><span class="line">            <span class="keyword">if</span> A.left:</span><br><span class="line">                A.left.subtree_insert(B)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                A.subtree_insert_before(B)</span><br><span class="line">        <span class="keyword">elif</span> B.item &gt; A.item:</span><br><span class="line">            <span class="keyword">if</span> A.right:</span><br><span class="line">                A.right.subtree_insert(B)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                A.subtree_insert_after(B)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            A.item = B.item</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Binary_Tree</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">T, Node_Type=Binary_Node</span>):</span></span><br><span class="line">        T.root = <span class="literal">None</span></span><br><span class="line">        T.size = <span class="number">0</span></span><br><span class="line">        T.Node_Type = Node_Type</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">T</span>):</span> <span class="keyword">return</span> T.size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">T</span>):</span></span><br><span class="line">        <span class="keyword">if</span> T.root:</span><br><span class="line">            <span class="keyword">for</span> A <span class="keyword">in</span> T.root.subtree_iter():</span><br><span class="line">                <span class="keyword">yield</span> A.item</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Set_Binary_Set</span>(<span class="params">Binary_Tree</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(BST_Node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">iter_order</span>(<span class="params">self</span>):</span> <span class="keyword">yield</span> <span class="keyword">from</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">self, X</span>):</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> X:</span><br><span class="line">            self.insert(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_min</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.root:</span><br><span class="line">            <span class="keyword">return</span> self.root.subtree_first().item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_max</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.root:</span><br><span class="line">            <span class="keyword">return</span> self.root.subtree_last().item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, k</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.root:</span><br><span class="line">            node = self.root.subtree_find(k)</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                <span class="keyword">return</span> node.item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_next</span>(<span class="params">self, k</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.root:</span><br><span class="line">            node = self.root.subtree_find_next(k)</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                <span class="keyword">return</span> node.item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_prev</span>(<span class="params">self, k</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.root:</span><br><span class="line">            node = self.root.subtree_find_prev(k)</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                <span class="keyword">return</span> node.item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        new_node = self.Node_Type(x)</span><br><span class="line">        <span class="keyword">if</span> self.root:</span><br><span class="line">            self.root.subtree_insert(new_node)</span><br><span class="line">            <span class="keyword">if</span> new_node.parent <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.root = new_node</span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self, k</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.root:</span><br><span class="line">            node = self.root.subtree_find(k)</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                ext = node.subtree_delete()</span><br><span class="line">                <span class="keyword">if</span> ext.parent <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    self.root = <span class="literal">None</span></span><br><span class="line">                self.size -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> ext.item</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>course</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>步态分析 5 - 步态的六大因素 Determinants</title>
    <url>/2022/03/01/1-Course/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%90/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%905-%E6%AD%A5%E6%80%81%E7%9A%84%E5%85%AD%E5%A4%A7%E5%9B%A0%E7%B4%A0/</url>
    <content><![CDATA[<p>人体的步态是复杂的，分析其内部产生机制，有助于理解人体的运动行为。Saunders等人在1953年基于<strong>最小化重心波动(minimize the excursions of the center if gravity)</strong>的原则，提出了<strong>步态过程的基本原则/决定因素(determinants of gait)</strong>，并在之后的60多年里得到了普遍接受，<strong>尽管现在很多研究表明最小重心波动不一定是能量消耗最小的行走模式(如倒立摆模型)</strong>，但这些原则依然十分具有启发性，下面将对其核心主旨进行介绍。</p>
<img src="/2022/03/01/1-Course/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%90/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%905-%E6%AD%A5%E6%80%81%E7%9A%84%E5%85%AD%E5%A4%A7%E5%9B%A0%E7%B4%A0/01.png" class title="未标题-16.png">
<span id="more"></span>
<aside>
💡 因素1、2、3考虑通过调整支撑腿的长度，来减少躯干和重心的波动；
</aside>

<h3 id="1-膝关节机制-Knee-Flexion-in-Stance-Phase"><a href="#1-膝关节机制-Knee-Flexion-in-Stance-Phase" class="headerlink" title="1 - 膝关节机制(Knee Flexion in Stance Phase)"></a>1 - 膝关节机制(Knee Flexion in Stance Phase)</h3><p>若膝关节角度保持不变时，在支撑相由于髋关节的弯曲和伸展，整条腿类似一根杆绕踝关节发生旋转，髋关节的位置会上下运动；当膝关节随着髋关节角度变化而屈膝时，髋关节以及躯干重心的波动会变小，但也会使得躯干的平均高度有所降低；</p>
<h3 id="2-踝关节机制-Ankle-Mechanism"><a href="#2-踝关节机制-Ankle-Mechanism" class="headerlink" title="2 - 踝关节机制(Ankle Mechanism)"></a>2 - 踝关节机制(Ankle Mechanism)</h3><p>膝关节机制用于缩短腿长，而踝足机制用于增加有效腿长；在初始接触时，脚跟先接触地面，通过增加腿的有效长度，延长了支撑相的有效时间；</p>
<h3 id="3-足部机制-Foot-Mechanism"><a href="#3-足部机制-Foot-Mechanism" class="headerlink" title="3 - 足部机制(Foot Mechanism)"></a>3 - 足部机制(Foot Mechanism)</h3><p>类似踝关节机制，在支撑末期到预摆动期足跟抬升，整个支撑腿围绕前足旋转，通过踝关节跖屈增加了腿部的有效长度；</p>
<h3 id="4-骨盆旋转-Pelvic-rotation"><a href="#4-骨盆旋转-Pelvic-rotation" class="headerlink" title="4 - 骨盆旋转(Pelvic rotation)"></a>4 - 骨盆旋转(Pelvic rotation)</h3><p>在支撑相时，若膝关节角度保持不变时，则<strong>髋关节的弯曲与伸展会导致躯干重心上下波动</strong>，且髋关节运动范围越大则躯干重心的上下波动越大；但<strong>髋关节的弯曲伸展是实现身体向前移动</strong>的必要条件，屈髋、伸髋的角度范围与步长(stride length)密切相关；</p>
<p><strong>骨盆旋转机</strong>制利用两髋之间的距离，将骨盆绕垂直轴旋转，<strong>使得一部分的步长来自于两髋之间横向距离</strong>，同时<strong>减小了相同步长下髋关节的弯曲角度</strong>，降低了躯干的上下波动；</p>
<img src="/2022/03/01/1-Course/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%90/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%905-%E6%AD%A5%E6%80%81%E7%9A%84%E5%85%AD%E5%A4%A7%E5%9B%A0%E7%B4%A0/02.png" class title="未标题-17.png">
<h3 id="5-骨盆倾斜-Pelvic-Obliquity"><a href="#5-骨盆倾斜-Pelvic-Obliquity" class="headerlink" title="5 - 骨盆倾斜(Pelvic Obliquity)"></a>5 - 骨盆倾斜(Pelvic Obliquity)</h3><p>躯干的高度由两髋的平均高度缩决定，当支撑侧髋关节的高度随着弯曲伸展而波动，骨盆倾斜机制通过在前视面(frontal plane)上旋转骨盆，降低另一侧(摆动侧)的竖直高度，从而降低躯干的上下波动；</p>
<img src="/2022/03/01/1-Course/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%90/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%905-%E6%AD%A5%E6%80%81%E7%9A%84%E5%85%AD%E5%A4%A7%E5%9B%A0%E7%B4%A0/03.png" class title="未标题-18.png">
<aside>
💡 前五条机制都与躯干或重心在垂直方向上的波动有关，第六条因素则是关于躯干在侧向上的移动；

</aside>

<h3 id="6-身体侧向位移-Lateral-Displacement-of-Body"><a href="#6-身体侧向位移-Lateral-Displacement-of-Body" class="headerlink" title="6 - 身体侧向位移(Lateral Displacement of Body)"></a>6 - 身体侧向位移(Lateral Displacement of Body)</h3><p>在支撑相时，躯干会横向移动到支撑侧足部的上方，以实现身体重力的支撑；当双脚的间距较大时，行走时身体需要左右倾斜移动来维持侧向平衡，这需要较多肌肉收缩与能量传递转化；</p>
<p>横向机制通过缩小双脚间距，也就是<strong>行走基础(walking base)</strong>，来<strong>减少横向的运动和横向平衡的能量消耗</strong>。</p>
<img src="/2022/03/01/1-Course/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%90/%E6%AD%A5%E6%80%81%E5%88%86%E6%9E%905-%E6%AD%A5%E6%80%81%E7%9A%84%E5%85%AD%E5%A4%A7%E5%9B%A0%E7%B4%A0/04.png" class title="未标题-19.png">
<aside>
💡 步态的六项机制通常同时发生在运动中，综合生成一个更为平滑的重心运动轨迹和更低的能量消耗；一些文献中认为这些因素使得躯干垂直位移降低50%，水平位移降低30%；

</aside>]]></content>
      <categories>
        <category>biomechanics</category>
      </categories>
      <tags>
        <tag>步态分析</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础 6 - 动态规划 Dynamic Programming</title>
    <url>/2022/05/01/1-Course/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/06-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<img src="/2022/05/01/1-Course/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/06-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/0.png" class>
<span id="more"></span>
<p>将一个复杂的问题，转化为可以递归的子问题，尽可能减少解的可能空间，然后进行局部暴力破解。</p>
<h3 id="DP的特性与步骤（SRTBOT）"><a href="#DP的特性与步骤（SRTBOT）" class="headerlink" title="DP的特性与步骤（SRTBOT）"></a>DP的特性与步骤（SRTBOT）</h3><ul>
<li><strong>定义子问题</strong>（subproblem）<ul>
<li>使用词汇语句来描述子问题</li>
<li>通常采用输入的子集：前缀、后缀、子串</li>
<li>通常会采用额外的辅助变量对子问题进行扩充</li>
</ul>
</li>
<li><strong>关联性</strong>（Relate）<ul>
<li>子问题的求解通过递归来实现，$x(i)=f(x(j),\ \dots)$</li>
</ul>
</li>
<li><strong>拓扑顺序</strong>（Topological Order）<ul>
<li>问题的求解时单向递进的，不存在循环的回路</li>
</ul>
</li>
<li><strong>基本案列</strong>（Basic Cases）<ul>
<li>不存在关联性的初始状态的解</li>
</ul>
</li>
<li><strong>原始问题</strong>（Original Problem）<ul>
<li>展示如何由子问题求解原始问题</li>
</ul>
</li>
<li><p><strong>时间分析</strong>（Time Analysis）</p>
<ul>
<li><p>求解原始问题所需求解的所有子问题时间总和</p>
<script type="math/tex; mode=display">
\sum_{x\in X}work(x),\ or |X|\cdot O(W)\quad if \ work(x)=O(W)</script></li>
</ul>
</li>
</ul>
<hr>
<h3 id="Trick-1-增加记忆-斐波那契数"><a href="#Trick-1-增加记忆-斐波那契数" class="headerlink" title="Trick 1: 增加记忆 - 斐波那契数"></a>Trick 1: 增加记忆 - 斐波那契数</h3><aside>
💡 通过存储子问题的解，提高递归求解的效率

</aside>

<p><strong>问题</strong>：计算第n个斐波那契数$F_n$</p>
<p><strong>DP求解</strong>：</p>
<ul>
<li>子问题：计算第i个斐波那契数$F(i),\ i\in\{1, 2, \dots, n\}$</li>
<li>关联性：$F(i)=F(i-1)+F(i-2)$</li>
<li>拓扑顺序：递增 i</li>
<li>基本案例：$F(0)=0,\ F(1)=1$</li>
<li>原始问题：$F_n = F(n)$</li>
<li>时间分析：</li>
</ul>
<script type="math/tex; mode=display">
T(n)=T(n-1)+T(n-2)+O(1)\to T = n\cdot O(1) = O(n)\ (by\ memo)</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">n</span>):</span></span><br><span class="line">    memo = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">F</span>(<span class="params">i</span>):</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> memo:</span><br><span class="line">            memo[i] = F(i - <span class="number">1</span>) + F(i - <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> memo[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> F(n)</span><br></pre></td></tr></table></figure>
<h3 id="Trick-2-局部暴力破解-保龄球问题"><a href="#Trick-2-局部暴力破解-保龄球问题" class="headerlink" title="Trick 2: 局部暴力破解 - 保龄球问题"></a>Trick 2: 局部暴力破解 - 保龄球问题</h3><aside>
💡 局部遍历问题所有可能解，通过子问题递归减少解集空间

</aside>

<p><strong>问题</strong>：在一组给定带标签的保龄球数列，计算最大得分</p>
<ul>
<li>每次可以击中一个或相邻两个保龄球，也可以选择不击球（结束）</li>
<li>击中一个得该球分数，击中相邻讲个得两球得分乘积</li>
<li>测试案例：$[-1,1,1,1,9,9,3,-3,-5,2,2]$</li>
</ul>
<p><strong>DP求解</strong>：</p>
<ul>
<li>子问题：求解输入的子序列的最大得分<code>B(i) = Max Score of Input v[i:n]</code></li>
<li>关联性（局部暴力破解）：<code>B(i) = max&#123;B(i+1), B(i+1)+v[i], B(i+2)+v[i]*v[i+1]&#125;</code></li>
<li>拓扑顺序：递减 i <code>(for i = n, n-1, 0)</code></li>
<li>基本案例：<code>B(n) = B(n+1) = 0</code></li>
<li>原始问题：<code>B(0)</code></li>
<li>时间分析：<code>Time = O(n) subproblems * O(1) work on each = O(n)</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bowl</span>(<span class="params">v</span>):</span></span><br><span class="line">    memo = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">B</span>(<span class="params">i</span>):</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(v)-<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> memo:</span><br><span class="line">            memo[i] = <span class="built_in">max</span>(B(i+<span class="number">1</span>), B(i+<span class="number">1</span>)+v[i], B(i+<span class="number">2</span>)+v[i]*v[i+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> memo[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> B(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Trick-3-通过子序列构造子问题-最长相同子序列（Longest-Common-Subsequence-LCS）"><a href="#Trick-3-通过子序列构造子问题-最长相同子序列（Longest-Common-Subsequence-LCS）" class="headerlink" title="Trick 3: 通过子序列构造子问题 - 最长相同子序列（Longest Common Subsequence, LCS）"></a>Trick 3: 通过子序列构造子问题 - 最长相同子序列（Longest Common Subsequence, LCS）</h3><aside>
💡 通过输入的子序列（前缀、后缀、子串）构造子问题，再进行局部破解

</aside>

<p><strong>问题</strong>：给定两个字符串，找出两个字符串最长的公共部分</p>
<ul>
<li>测试案例：<code>A = hieroglyphology, B = michaelangelo</code></li>
<li>解集：<code>hello, heglo, iello, ieglo</code></li>
</ul>
<p><strong>DP求解</strong>：</p>
<ul>
<li>子问题：<code>x(i,j) = Longest Common Subsequence of A[i:n] and B[j:n]</code></li>
<li>关联性（局部暴力破解）:</li>
</ul>
<script type="math/tex; mode=display">
x(i, j)= \begin{cases}x(i+1, j+1)+1 & \text { if } A[i]=B[j] \\ \max \{x(i+1, j), x(i, j+1)\} & \text { otherwise }\end{cases}</script><ul>
<li>拓扑顺序：递减 i + j；先递减 i，然后递减 j</li>
<li>基本案例：<code>x(i,|B|) = x(|A|,j) = 0</code></li>
<li>原始问题：<code>x(0,0)</code></li>
<li>时间分析：<code>Time = O(|A|+1)*O(|B|+1) subproblems * O(1) work on each = O(|A|*|B|)</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lcs</span>(<span class="params">A, B</span>):</span></span><br><span class="line">    a, b = <span class="built_in">len</span>(A), <span class="built_in">len</span>(B)</span><br><span class="line">    x = [[<span class="number">0</span>]*(b+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(a+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(a)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(b)):</span><br><span class="line">            <span class="keyword">if</span> A[i] == B[j]:</span><br><span class="line">                x[i][j] = x[i+<span class="number">1</span>][j+<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                x[i][j] = <span class="built_in">max</span>(x[i+<span class="number">1</span>][j], x[i][j+<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> x[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h3 id="Trick-4-增加问题约束-最长递增子序列（Longest-Increasing-Subsequence-LIS）"><a href="#Trick-4-增加问题约束-最长递增子序列（Longest-Increasing-Subsequence-LIS）" class="headerlink" title="Trick 4: 增加问题约束 - 最长递增子序列（Longest Increasing Subsequence, LIS）"></a>Trick 4: 增加问题约束 - 最长递增子序列（Longest Increasing Subsequence, LIS）</h3><aside>
💡 通过增加额外的约束条件修改原问题，降低子问题的解空间维度，提高局部暴力破解的效率

</aside>

<p><strong>问题</strong>：给定一个字符串，找出最长的严格递增的子串</p>
<ul>
<li>测试案例：<code>A = carbohydrate</code></li>
<li>解集：<code>abort</code></li>
</ul>
<p><strong>DP求解</strong>：</p>
<ul>
<li>子问题：<strong><em>包含首个元素</em></strong>的最长递增子序列<br><code>x(i) = Longest Increasing Subsequence of A[i:n] that include A[i]</code></li>
<li>关联性（局部暴力破解）:</li>
</ul>
<script type="math/tex; mode=display">
x(i)=\max \{1+x(j)|i<j<| A \mid, A[j]>A[i]\} \cup\{1\}</script><ul>
<li>拓扑顺序：递减 i</li>
<li>基本案例：<code>x(n) = 1</code></li>
<li>原始问题：<code>max(x(i)| 0 &lt;= i &lt;= |A|)</code></li>
<li>时间分析：<code>Time = O(|A|) subproblems * O(log|A|) each by AVL Tree = O(|A|log|A|)</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lis</span>(<span class="params">A</span>):</span></span><br><span class="line">    a = <span class="built_in">len</span>(A)</span><br><span class="line">    x = [<span class="number">1</span>] * a</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(a)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, a):</span><br><span class="line">            <span class="keyword">if</span> A[j] &gt; A[i]:</span><br><span class="line">                x[i] = <span class="built_in">max</span>(x[i], <span class="number">1</span> + x[j])</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(x)</span><br></pre></td></tr></table></figure>
<h3 id="Trick-5-子问题扩张-括号化算数运算（Arithmetic-Parenthesization）"><a href="#Trick-5-子问题扩张-括号化算数运算（Arithmetic-Parenthesization）" class="headerlink" title="Trick 5: 子问题扩张 - 括号化算数运算（Arithmetic Parenthesization）"></a>Trick 5: 子问题扩张 - 括号化算数运算（Arithmetic Parenthesization）</h3><aside>
💡 将原问题扩张为几个**相关联的、并列的**子问题，对每个子问题采用局部暴力破解

</aside>

<p><strong>问题</strong>：给定一个算数表达式$a_0 <em>_1 a_1 </em>_2 a_2 \cdots *_{n-1} a_{n-1}$，通过添加括号使运算结果最大化</p>
<ul>
<li>$*_i \in\{+, \times\}$，$a_i$为正、负整数</li>
<li>测试案例：$7+(-4) \times 3+(-5)$</li>
<li>解集：$((7)+((-4) \times((3)+(-5))))=15$</li>
</ul>
<p><strong>DP求解</strong>：</p>
<ul>
<li>子问题：求解输入的子序列的<strong>最大和最小</strong>运算结果<ul>
<li><code>x(i,j,opt) = opt value of subsquence</code> $a_i<em>_{i+1}\cdots</em>_{j-1}a_{j-1}$</li>
<li><code>0 ≤ i &lt; j ≤ n, opt in &#123;max, min&#125;</code></li>
</ul>
</li>
<li>关联性（局部暴力破解）：</li>
</ul>
<script type="math/tex; mode=display">
\left.x(i, j, \text { opt })=\operatorname{opt}\left\{x\left(i, k, \text { opt }^{\prime}\right) *_k x\left(k, j, \text { opt }^{\prime \prime}\right)\right) \mid i<k<j ; \text { opt }^{\prime}, \mathrm{opt}^{\prime \prime} \in\{\min , \max \}\right\}</script><ul>
<li>拓扑顺序：递增 j - i</li>
<li>基本案例：<code>x(i,i+1,opt) = A[i]</code></li>
<li>原始问题：<code>x(0,n,max)</code></li>
<li>时间分析：<code>Time = O(n^2) subproblems * O(n) work on each = O(n^3)</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ap</span>(<span class="params">A, O</span>):</span></span><br><span class="line">    a = <span class="built_in">len</span>(A)</span><br><span class="line">    a_max = [[<span class="number">0</span>] * (a) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(a)]</span><br><span class="line">    a_min = [[<span class="number">0</span>] * (a) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(a)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxmin_subseq</span>(<span class="params">i, k, j, opt</span>):</span></span><br><span class="line">        <span class="keyword">if</span> O[k] == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            a = [x*y <span class="keyword">for</span> x <span class="keyword">in</span> [a_max[i][k], a_min[i][k]] </span><br><span class="line">                 <span class="keyword">for</span> y <span class="keyword">in</span> [a_max[k+<span class="number">1</span>][j], a_min[k+<span class="number">1</span>][j]]]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            a = [x+y <span class="keyword">for</span> x <span class="keyword">in</span> [a_max[i][k], a_min[i][k]] </span><br><span class="line">                 <span class="keyword">for</span> y <span class="keyword">in</span> [a_max[k+<span class="number">1</span>][j], a_min[k+<span class="number">1</span>][j]]]</span><br><span class="line">        <span class="keyword">if</span> opt == <span class="string">&quot;max&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(a_max[i][j], <span class="built_in">max</span>(a))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>(a_min[i][j], <span class="built_in">min</span>(a))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(a)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, a):</span><br><span class="line">            <span class="keyword">if</span> j == i:</span><br><span class="line">                a_max[i][i] = A[i]</span><br><span class="line">                a_min[i][i] = A[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i, j):</span><br><span class="line">                    a_max[i][j] = maxmin_subseq(i, k, j, <span class="string">&quot;max&quot;</span>)</span><br><span class="line">                    a_min[i][j] = maxmin_subseq(i, k, j, <span class="string">&quot;min&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a_max[<span class="number">0</span>][<span class="built_in">len</span>(A)-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>course</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础 5 - 优先队列与二叉堆 Binary Heap</title>
    <url>/2022/05/01/1-Course/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/05-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E5%A0%86/</url>
    <content><![CDATA[<img src="/2022/05/01/1-Course/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/05-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E5%A0%86/0.png" class>
<span id="more"></span>
<h3 id="优先队列（Priority-Queue）"><a href="#优先队列（Priority-Queue）" class="headerlink" title="优先队列（Priority Queue）"></a>优先队列（Priority Queue）</h3><p><strong>特性</strong>：用于维护一组元素构成的集合，key=priority，能够快速/移除获取最重要的元素</p>
<ul>
<li>计算机操作系统的作业调度，在任务队列中选择最高优先级的任务执行</li>
<li>离散事件的时间系统模拟，事件必须按照时间发生的顺序进行模拟</li>
</ul>
<p><strong>接口</strong>：</p>
<img src="/2022/05/01/1-Course/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/05-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E5%A0%86/1.png" class title="Untitled">
<p><strong>优先队列排序</strong>：</p>
<ul>
<li>任意的优先队列数据结构都可以转化为一种排序算法：<ul>
<li>build(A)，按照输入顺序构建数据结构</li>
<li>重复执行delete_min()/delete_max()以确定排序顺序</li>
</ul>
</li>
<li>许多排序算法可以被看做一种优先队列</li>
</ul>
<img src="/2022/05/01/1-Course/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/05-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E5%A0%86/2.png" class title="Untitled">
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.A = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.A.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete_max</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.A) &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.A.pop()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sort</span>(<span class="params">Queue, A</span>):</span></span><br><span class="line">        pq = Queue()</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> A:</span><br><span class="line">            pq.insert(x)</span><br><span class="line">        out = [pq.delete_max() <span class="keyword">for</span> _ <span class="keyword">in</span> A]</span><br><span class="line">        out.reverse()</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PQ_Array</span>(<span class="params">PriorityQueue</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete_max</span>(<span class="params">self</span>):</span></span><br><span class="line">        n, A, m = <span class="built_in">len</span>(self.A), self.A, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> A[m].key &lt; A[i].key:</span><br><span class="line">                m = i</span><br><span class="line">        A[m], A[n] = A[n], A[m]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().delete_max()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PQ_SortedArray</span>(<span class="params">PriorityQueue</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, *args</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().insert(*args)</span><br><span class="line">        i, A = <span class="built_in">len</span>(self.A)-<span class="number">1</span>, self.A</span><br><span class="line">        <span class="keyword">while</span> <span class="number">0</span> &lt; i <span class="keyword">and</span> A[i+<span class="number">1</span>].key &lt; A[i].key:</span><br><span class="line">            A[i+<span class="number">1</span>], A[i] = A[i], A[i+<span class="number">1</span>]</span><br><span class="line">            i -= <span class="number">1</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h3><ul>
<li>结合AVL树和动态数组的数据结构，既有AVL的快速排序，有动态数组的直接存取</li>
<li>在AVL树的基础上，所有节点为左对齐的，因此可以使用数组表示一个树的数据结构</li>
</ul>
<img src="/2022/05/01/1-Course/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/05-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E5%A0%86/3.png" class title="Untitled">
<h3 id="二叉堆的特性"><a href="#二叉堆的特性" class="headerlink" title="二叉堆的特性"></a>二叉堆的特性</h3><ul>
<li><strong>直接索引</strong>：每个节点的父节点，和左右子节点，都可以由计算的序号通过数组索引</li>
</ul>
<script type="math/tex; mode=display">
\operatorname{left}(i)=2 i+1, \ \operatorname{right}(i) =2 i+2, \ \operatorname{parent}(i) =\left\lfloor\frac{i-1}{2}\right\rfloor</script><ul>
<li><strong>最大堆特性</strong>：每个节点的优先级都高于其子节点，进一步高于其子树的所有节点</li>
</ul>
<script type="math/tex; mode=display">
Q[i] \geq Q[j],\quad \text { for } j \in\{\operatorname{left}(i), \operatorname{right}(i)\}</script><ul>
<li><strong>堆的插入</strong>（<strong>上浮</strong>）：<ul>
<li>将新元素插入到数组末尾(最右叶节点)</li>
<li>从该节点开始，若子节点优先级高于父节点，则交换数组中两个元素位置，并递归</li>
</ul>
</li>
<li><strong>堆的删除</strong>（<strong>下沉</strong>）：<ul>
<li>将根节点和最右子节点交换(数组首尾元素交换)，并删除数组末尾元素</li>
<li>从根节点开始，若父节点优先级小于子节点，则交换父节点与优先级最高的子节点，并递归</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, A</span>):</span></span><br><span class="line">        self.A = []</span><br><span class="line">        self.n = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.A.append(x)</span><br><span class="line">        self.n += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete_max</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.A) &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.A.pop()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sort</span>(<span class="params">Queue, A</span>):</span></span><br><span class="line">        pq = Queue(A)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> A:</span><br><span class="line">            pq.insert(x)</span><br><span class="line">        out = [pq.delete_max() <span class="keyword">for</span> _ <span class="keyword">in</span> A]</span><br><span class="line">        out.reverse()</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PQ_Heap</span>(<span class="params">PriorityQueue</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, *args</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().insert(*args)</span><br><span class="line">        n, A = self.n, self.A</span><br><span class="line">        self.max_heapify_up(A, n, n-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete_max</span>(<span class="params">self</span>):</span></span><br><span class="line">        n, A = self.n, self.A</span><br><span class="line">        A[<span class="number">0</span>], A[n-<span class="number">1</span>] = A[n-<span class="number">1</span>], A[<span class="number">0</span>]</span><br><span class="line">        self.max_heapify_down(A, n-<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().delete_max()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parent</span>(<span class="params">self, i</span>):</span></span><br><span class="line">        p = (i - <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> p <span class="keyword">if</span> <span class="number">0</span> &lt; i <span class="keyword">else</span> i</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">left</span>(<span class="params">self, i, n</span>):</span></span><br><span class="line">        l = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> l <span class="keyword">if</span> l &lt; n <span class="keyword">else</span> i</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">right</span>(<span class="params">self, i, n</span>):</span></span><br><span class="line">        r = <span class="number">2</span> * i + <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> r <span class="keyword">if</span> r &lt; n <span class="keyword">else</span> i</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">max_heapify_up</span>(<span class="params">self, A, n, c</span>):</span></span><br><span class="line">        p = self.parent(c)</span><br><span class="line">        <span class="keyword">if</span> A[p].key &lt; A[c].key:</span><br><span class="line">            A[c], A[p] = A[p], A[c]</span><br><span class="line">            self.max_heapify_up(A, n, p)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">max_heapify_down</span>(<span class="params">self, A, n, p</span>):</span></span><br><span class="line">        l, r = self.left(p, n), self.right(p, n)</span><br><span class="line">        <span class="keyword">if</span> A[r].key &lt; A[l].key:</span><br><span class="line">            c = l</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            c = r</span><br><span class="line">        <span class="keyword">if</span> A[p].key &lt; A[c].key:</span><br><span class="line">            A[c], A[p] = A[p], A[c]</span><br><span class="line">            self.max_heapify_down(A, n, c)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>course</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础 4 - 二叉树 Binary Tree</title>
    <url>/2022/05/01/1-Course/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/04-%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<img src="/2022/05/01/1-Course/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/04-%E4%BA%8C%E5%8F%89%E6%A0%91/0.png" class>
<span id="more"></span>
<aside>
💡 非常重要的基础数据结构，在多种任务上有平均最好的性能
</aside>


<h3 id="二叉树基本要点"><a href="#二叉树基本要点" class="headerlink" title="二叉树基本要点"></a>二叉树基本要点</h3><ul>
<li><strong>组成</strong>：<ul>
<li>一个表示该节点的数据项</li>
<li>三个指针，分别指向父节点，以及左、右两个子节点</li>
</ul>
</li>
<li><strong>概念</strong>：<ul>
<li><strong>根节点</strong>（root）：唯一缺少父节点的节点</li>
<li><strong>叶节点</strong>（left）：没有子节点的节点</li>
<li><strong>节点祖先</strong>（ancestors）：由根节点到达某个节点所经过的一系列节点</li>
<li><strong>节点深度</strong>（depth）：由根节点到达某个节点的路径长度</li>
<li><strong>树高度</strong>（height）：所有节点的最大深度</li>
</ul>
</li>
<li><strong>遍历顺序</strong>（Traversal Order）：<ul>
<li>每个节点的左子树节点的访问顺序早于该节点</li>
<li>每个节点的左子树节点的访问顺序晚于该节点</li>
</ul>
</li>
<li><strong>接口实现</strong>：<ul>
<li>遍历顺序关联序列顺序，用于实现序列（Sequence Interface）</li>
<li>遍历顺序关联排序顺序，用于实现集合（Set Interface）</li>
</ul>
</li>
<li><strong>平衡二叉树 - AVL Tree</strong><ul>
<li><strong>倾斜度</strong>（skew）：节点右子树高度减去节点左子树的高度</li>
<li><strong>高度平衡</strong>（AVL特性）：节点/所有节点的倾斜度属于集合[-1, 0, 1]</li>
<li><strong>旋转：</strong>在保持遍历顺序的同时，通过变换节点的父子关系，减小树的高度</li>
<li><strong>高度</strong>：<em>h</em> = log<em>n</em></li>
</ul>
</li>
<li><strong>效率性</strong>：<ul>
<li>二叉树所有操作的时间复杂度均为O(<em>h</em>)，进一步平衡二叉树为O(log<em>n</em>)</li>
</ul>
</li>
</ul>
<h3 id="二叉树的操作"><a href="#二叉树的操作" class="headerlink" title="二叉树的操作"></a>二叉树的操作</h3><ul>
<li>基础元素：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Binary_Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">A, x</span>):</span></span><br><span class="line">        A.item = x</span><br><span class="line">        A.left = <span class="literal">None</span></span><br><span class="line">        A.right = <span class="literal">None</span></span><br><span class="line">        A.parent = <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<ul>
<li>遍历访问（迭代）：<ul>
<li>如果该节点含有左节点，遍历访问该节点的左节点</li>
<li>输出该节点数据</li>
<li>如果该节点含有右节点，遍历访问该节点的右节点</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subtree_iter</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">if</span> self.left:</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> self.left.subtree_iter()</span><br><span class="line">    <span class="keyword">yield</span> self</span><br><span class="line">    <span class="keyword">if</span> self.right:</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> self.right.subtree_iter()</span><br></pre></td></tr></table></figure>
<ul>
<li>查找子树最首/最尾的遍历节点（遍历）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subtree_first</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="keyword">if</span> A.left:</span><br><span class="line">        <span class="keyword">return</span> A.left.subtree_first()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> A</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subtree_last</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="keyword">if</span> A.right:</span><br><span class="line">        <span class="keyword">return</span> A.right.subtree_last()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure>
<ul>
<li>查找下一个/上一个遍历节点<ul>
<li>如果该节点存在右节点，则下一个节点为右子树的首节点</li>
<li>如果该节点不存在右节点，则下一个节点为左分支上的祖先节点</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">successor</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="keyword">if</span> A.right:</span><br><span class="line">        <span class="keyword">return</span> A.right.subtree_first()</span><br><span class="line">    <span class="keyword">while</span> A.parent <span class="keyword">and</span> (A <span class="keyword">is</span> A.parent.right):</span><br><span class="line">        A = A.parent</span><br><span class="line">    <span class="keyword">return</span> A.parent</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predecessor</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="keyword">if</span> A.left:</span><br><span class="line">        <span class="keyword">return</span> A.left.subtree_last()</span><br><span class="line">    <span class="keyword">while</span> A.parent <span class="keyword">and</span> (A <span class="keyword">is</span> A.parent.left):</span><br><span class="line">        A = A.parent</span><br><span class="line">    <span class="keyword">return</span> A.parent</span><br></pre></td></tr></table></figure>
<ul>
<li>旋转节点</li>
</ul>
<img src="/2022/05/01/1-Course/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/04-%E4%BA%8C%E5%8F%89%E6%A0%91/2.png" class title="Untitled">
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subtre_rotate_right</span>(<span class="params">D</span>):</span></span><br><span class="line">    <span class="keyword">if</span> D.left:</span><br><span class="line">        B, E = D.left, D.right</span><br><span class="line">        A, C = B.left, B.right</span><br><span class="line">        D, B = B, D</span><br><span class="line">        D.item, B.item = B.item, D.item</span><br><span class="line">        B.left, B.right = A, D</span><br><span class="line">        D.left, D.right = C, E</span><br><span class="line">        <span class="keyword">if</span> A:</span><br><span class="line">            A.parent = B</span><br><span class="line">        <span class="keyword">if</span> E:</span><br><span class="line">            E.parent = D</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subtree_rotate_left</span>(<span class="params">B</span>):</span></span><br><span class="line">    <span class="keyword">if</span> B.right:</span><br><span class="line">        A, D = B.left, B.right</span><br><span class="line">        C, E = D.left, D.right</span><br><span class="line">        B, D = D, B</span><br><span class="line">        B.item, D.item = D.item, B.item</span><br><span class="line">        D.left, D.right = B, E</span><br><span class="line">        B.left, B.right = A, C</span><br><span class="line">        <span class="keyword">if</span> A:</span><br><span class="line">            A.parent = B</span><br><span class="line">        <span class="keyword">if</span> E:</span><br><span class="line">            E.parent = D</span><br></pre></td></tr></table></figure>
<ul>
<li><p>AVL树平衡</p>
<ul>
<li><p>Case 1: 该节点skew为2，且该节点的右子节点skew为0或1，将该节点左旋</p>
  <img src="/2022/05/01/1-Course/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/04-%E4%BA%8C%E5%8F%89%E6%A0%91/3.png" class title="Untitled">
</li>
<li><p>Case 2: 该节点skew为2，且该节点的右子节点skew为-1，将该节点的右子节点右旋，再将该节点左旋</p>
  <img src="/2022/05/01/1-Course/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/04-%E4%BA%8C%E5%8F%89%E6%A0%91/4.png" class title="Untitled">
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">height</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="keyword">if</span> A:</span><br><span class="line">        <span class="keyword">return</span> A.height</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">######</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subtree_update</span>(<span class="params">A</span>):</span></span><br><span class="line">    A.height = <span class="number">1</span> + <span class="built_in">max</span>(height(A.left), height(A.right))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">skew</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="keyword">return</span> height(A.right) - height(A.left)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rebalance</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="keyword">if</span> A.skew == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">if</span> A.right.skew() &lt; <span class="number">0</span>:</span><br><span class="line">            A.right.subtre_rotate_right()</span><br><span class="line">        A.subtree_rotate_left()</span><br><span class="line">    <span class="keyword">elif</span> A.skew() == -<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">if</span> A.left.skew() &gt; <span class="number">0</span>:</span><br><span class="line">            A.left.subtree_rotate_left()</span><br><span class="line">        A.subtre_rotate_right()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maintain</span>(<span class="params">A</span>):</span></span><br><span class="line">        A.rebalance()</span><br><span class="line">      A.subtree_update()</span><br><span class="line">      <span class="keyword">if</span> A.parent:</span><br><span class="line">          A.parent.maintain()</span><br></pre></td></tr></table></figure>
<ul>
<li>插入 - 以在节点之前插入为例<ul>
<li>若该节点不存在左子节点，插入位置为该节点的左子节点</li>
<li>若该节点存在左子节点，插入位置为左子树最末节点的右子节点</li>
<li>重新平衡二叉树</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subtree_insert_before</span>(<span class="params">A, B</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.left:</span><br><span class="line">            A = A.left.subtree_last()</span><br><span class="line">            A.right, B.parent = B, A</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            A.left, B.parent = B, A</span><br><span class="line">        A.maintain()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_insert_after</span>(<span class="params">A, B</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.right:</span><br><span class="line">            A = A.right.subtree_first()</span><br><span class="line">            A.left, B.parent = B, A</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            A.right, B.parent = B, A</span><br><span class="line">        A.maintain()</span><br></pre></td></tr></table></figure>
<ul>
<li><p>删除()</p>
<ul>
<li>若该节点为叶节点，则直接删除</li>
<li><p>若该节点非叶节点，则将该节点和其前一个/后一个遍历节点交换后删除（一定是叶节点）</p>
<img src="/2022/05/01/1-Course/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/04-%E4%BA%8C%E5%8F%89%E6%A0%91/5.png" class title="Untitled">
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subtree_delete</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="keyword">if</span> A.left <span class="keyword">or</span> A.right:</span><br><span class="line">        <span class="keyword">if</span> A.left:</span><br><span class="line">            B = A.predecessor()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            B = A.successor()</span><br><span class="line">        A.item, B.item = B.item, A.item</span><br><span class="line">        <span class="keyword">return</span> B.subtree_delete()</span><br><span class="line">    <span class="keyword">if</span> A.parent:</span><br><span class="line">        <span class="keyword">if</span> A <span class="keyword">is</span> A.parent.left:</span><br><span class="line">            A.parent.left = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            A.parent.right = <span class="literal">None</span></span><br><span class="line">        A.maintain()</span><br><span class="line">    <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure>
<h3 id="AVL平衡的完整实现"><a href="#AVL平衡的完整实现" class="headerlink" title="AVL平衡的完整实现"></a>AVL平衡的完整实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">height</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="keyword">if</span> A:</span><br><span class="line">        <span class="keyword">return</span> A.height</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Binary_Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">A, x</span>):</span></span><br><span class="line">        A.item = x</span><br><span class="line">        A.left = <span class="literal">None</span></span><br><span class="line">        A.right = <span class="literal">None</span></span><br><span class="line">        A.parent = <span class="literal">None</span></span><br><span class="line">        A.subtree_update()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_update</span>(<span class="params">A</span>):</span></span><br><span class="line">        A.height = <span class="number">1</span> + <span class="built_in">max</span>(height(A.left), height(A.right))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skew</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="keyword">return</span> height(A.right) - height(A.left)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_iter</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.left:</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> A.left.subtree_iter()</span><br><span class="line">        <span class="keyword">yield</span> A</span><br><span class="line">        <span class="keyword">if</span> A.right:</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> A.right.subtree_iter()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_first</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.left:</span><br><span class="line">            <span class="keyword">return</span> A.left.subtree_first()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> A</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_last</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.right:</span><br><span class="line">            <span class="keyword">return</span> A.right.subtree_last()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> A</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">successor</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.right:</span><br><span class="line">            <span class="keyword">return</span> A.right.subtree_first()</span><br><span class="line">        <span class="keyword">while</span> A.parent <span class="keyword">and</span> (A <span class="keyword">is</span> A.parent.right):</span><br><span class="line">            A = A.parent</span><br><span class="line">        <span class="keyword">return</span> A.parent</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predecessor</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.left:</span><br><span class="line">            <span class="keyword">return</span> A.left.subtree_last()</span><br><span class="line">        <span class="keyword">while</span> A.parent <span class="keyword">and</span> (A <span class="keyword">is</span> A.parent.left):</span><br><span class="line">            A = A.parent</span><br><span class="line">        <span class="keyword">return</span> A.parent</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtre_rotate_right</span>(<span class="params">D</span>):</span></span><br><span class="line">        <span class="keyword">if</span> D.left:</span><br><span class="line">            B, E = D.left, D.right</span><br><span class="line">            A, C = B.left, B.right</span><br><span class="line">            D, B = B, D</span><br><span class="line">            D.item, B.item = B.item, D.item</span><br><span class="line">            B.left, B.right = A, D</span><br><span class="line">            D.left, D.right = C, E</span><br><span class="line">            <span class="keyword">if</span> A:</span><br><span class="line">                A.parent = B</span><br><span class="line">            <span class="keyword">if</span> E:</span><br><span class="line">                E.parent = D</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_rotate_left</span>(<span class="params">B</span>):</span></span><br><span class="line">        <span class="keyword">if</span> B.right:</span><br><span class="line">            A, D = B.left, B.right</span><br><span class="line">            C, E = D.left, D.right</span><br><span class="line">            B, D = D, B</span><br><span class="line">            B.item, D.item = D.item, B.item</span><br><span class="line">            D.left, D.right = B, E</span><br><span class="line">            B.left, B.right = A, C</span><br><span class="line">            <span class="keyword">if</span> A:</span><br><span class="line">                A.parent = B</span><br><span class="line">            <span class="keyword">if</span> E:</span><br><span class="line">                E.parent = D</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rebalance</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.skew == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> A.right.skew() &lt; <span class="number">0</span>:</span><br><span class="line">                A.right.subtre_rotate_right()</span><br><span class="line">            A.subtree_rotate_left()</span><br><span class="line">        <span class="keyword">elif</span> A.skew() == -<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> A.left.skew() &gt; <span class="number">0</span>:</span><br><span class="line">                A.left.subtree_rotate_left()</span><br><span class="line">            A.subtre_rotate_right()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maintain</span>(<span class="params">A</span>):</span></span><br><span class="line">        A.rebalance()</span><br><span class="line">        A.subtree_update()</span><br><span class="line">        <span class="keyword">if</span> A.parent:</span><br><span class="line">            A.parent.maintain()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_insert_before</span>(<span class="params">A, B</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.left:</span><br><span class="line">            A = A.left.subtree_last()</span><br><span class="line">            A.right, B.parent = B, A</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            A.left, B.parent = B, A</span><br><span class="line">        A.maintain()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_insert_after</span>(<span class="params">A, B</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.right:</span><br><span class="line">            A = A.right.subtree_first()</span><br><span class="line">            A.left, B.parent = B, A</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            A.right, B.parent = B, A</span><br><span class="line">        A.maintain()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_delete</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.left <span class="keyword">or</span> A.right:</span><br><span class="line">            <span class="keyword">if</span> A.left:</span><br><span class="line">                B = A.predecessor()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                B = A.successor()</span><br><span class="line">            A.item, B.item = B.item, A.item</span><br><span class="line">            <span class="keyword">return</span> B.subtree_delete()</span><br><span class="line">        <span class="keyword">if</span> A.parent:</span><br><span class="line">            <span class="keyword">if</span> A <span class="keyword">is</span> A.parent.left:</span><br><span class="line">                A.parent.left = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                A.parent.right = <span class="literal">None</span></span><br><span class="line">            A.maintain()</span><br><span class="line">        <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure>
<h3 id="面向集合接口的二叉树"><a href="#面向集合接口的二叉树" class="headerlink" title="面向集合接口的二叉树"></a>面向集合接口的二叉树</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">height</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="keyword">if</span> A:</span><br><span class="line">        <span class="keyword">return</span> A.height</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Binary_Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">A, x</span>):</span></span><br><span class="line">        A.item = x</span><br><span class="line">        A.left = <span class="literal">None</span></span><br><span class="line">        A.right = <span class="literal">None</span></span><br><span class="line">        A.parent = <span class="literal">None</span></span><br><span class="line">        A.subtree_update()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_update</span>(<span class="params">A</span>):</span></span><br><span class="line">        A.height = <span class="number">1</span> + <span class="built_in">max</span>(height(A.left), height(A.right))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skew</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="keyword">return</span> height(A.right) - height(A.left)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_iter</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.left:</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> A.left.subtree_iter()</span><br><span class="line">        <span class="keyword">yield</span> A</span><br><span class="line">        <span class="keyword">if</span> A.right:</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> A.right.subtree_iter()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_first</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.left:</span><br><span class="line">            <span class="keyword">return</span> A.left.subtree_first()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> A</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_last</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.right:</span><br><span class="line">            <span class="keyword">return</span> A.right.subtree_last()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> A</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">successor</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.right:</span><br><span class="line">            <span class="keyword">return</span> A.right.subtree_first()</span><br><span class="line">        <span class="keyword">while</span> A.parent <span class="keyword">and</span> (A <span class="keyword">is</span> A.parent.right):</span><br><span class="line">            A = A.parent</span><br><span class="line">        <span class="keyword">return</span> A.parent</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predecessor</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.left:</span><br><span class="line">            <span class="keyword">return</span> A.left.subtree_last()</span><br><span class="line">        <span class="keyword">while</span> A.parent <span class="keyword">and</span> (A <span class="keyword">is</span> A.parent.left):</span><br><span class="line">            A = A.parent</span><br><span class="line">        <span class="keyword">return</span> A.parent</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_rotate_right</span>(<span class="params">D</span>):</span></span><br><span class="line">        <span class="keyword">if</span> D.left:</span><br><span class="line">            B, E = D.left, D.right</span><br><span class="line">            A, C = B.left, B.right</span><br><span class="line">            D, B = B, D</span><br><span class="line">            D.item, B.item = B.item, D.item</span><br><span class="line">            B.left, B.right = A, D</span><br><span class="line">            D.left, D.right = C, E</span><br><span class="line">            <span class="keyword">if</span> A:</span><br><span class="line">                A.parent = B</span><br><span class="line">            <span class="keyword">if</span> E:</span><br><span class="line">                E.parent = D</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_rotate_left</span>(<span class="params">B</span>):</span></span><br><span class="line">        <span class="keyword">if</span> B.right:</span><br><span class="line">            A, D = B.left, B.right</span><br><span class="line">            C, E = D.left, D.right</span><br><span class="line">            B, D = D, B</span><br><span class="line">            B.item, D.item = D.item, B.item</span><br><span class="line">            D.left, D.right = B, E</span><br><span class="line">            B.left, B.right = A, C</span><br><span class="line">            <span class="keyword">if</span> A:</span><br><span class="line">                A.parent = B</span><br><span class="line">            <span class="keyword">if</span> E:</span><br><span class="line">                E.parent = D</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rebalance</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.skew == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> A.right.skew() &lt; <span class="number">0</span>:</span><br><span class="line">                A.right.subtree_rotate_right()</span><br><span class="line">            A.subtree_rotate_left()</span><br><span class="line">        <span class="keyword">elif</span> A.skew() == -<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> A.left.skew() &gt; <span class="number">0</span>:</span><br><span class="line">                A.left.subtree_rotate_left()</span><br><span class="line">            A.subtree_rotate_right()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maintain</span>(<span class="params">A</span>):</span></span><br><span class="line">        A.rebalance()</span><br><span class="line">        A.subtree_update()</span><br><span class="line">        <span class="keyword">if</span> A.parent:</span><br><span class="line">            A.parent.maintain()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_insert_before</span>(<span class="params">A, B</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.left:</span><br><span class="line">            A = A.left.subtree_last()</span><br><span class="line">            A.right, B.parent = B, A</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            A.left, B.parent = B, A</span><br><span class="line">        A.maintain()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_insert_after</span>(<span class="params">A, B</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.right:</span><br><span class="line">            A = A.right.subtree_first()</span><br><span class="line">            A.left, B.parent = B, A</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            A.right, B.parent = B, A</span><br><span class="line">        A.maintain()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_delete</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.left <span class="keyword">or</span> A.right:</span><br><span class="line">            <span class="keyword">if</span> A.left:</span><br><span class="line">                B = A.predecessor()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                B = A.successor()</span><br><span class="line">            A.item, B.item = B.item, A.item</span><br><span class="line">            <span class="keyword">return</span> B.subtree_delete()</span><br><span class="line">        <span class="keyword">if</span> A.parent:</span><br><span class="line">            <span class="keyword">if</span> A <span class="keyword">is</span> A.parent.left:</span><br><span class="line">                A.parent.left = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                A.parent.right = <span class="literal">None</span></span><br><span class="line">            A.maintain()</span><br><span class="line">        <span class="keyword">return</span> A</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BST_Node</span>(<span class="params">Binary_Node</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_find</span>(<span class="params">A, k</span>):</span></span><br><span class="line">        <span class="keyword">if</span> k &lt; A.item.key:</span><br><span class="line">            <span class="keyword">if</span> A.left:</span><br><span class="line">                <span class="keyword">return</span> A.left.subtree_find(k)</span><br><span class="line">        <span class="keyword">elif</span> k &gt; A.item.key:</span><br><span class="line">            <span class="keyword">if</span> A.right:</span><br><span class="line">                <span class="keyword">return</span> A.right.subtree_find(k)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> A</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_find_next</span>(<span class="params">A, k</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.item &lt;= k:</span><br><span class="line">            <span class="keyword">if</span> A.right:</span><br><span class="line">                <span class="keyword">return</span> A.right.subtree_find_next(k)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">elif</span> A.left:</span><br><span class="line">            B = A.left.subtree_find_next(k)</span><br><span class="line">            <span class="keyword">if</span> B:</span><br><span class="line">                <span class="keyword">return</span> B</span><br><span class="line">        <span class="keyword">return</span> A</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_find_prev</span>(<span class="params">A, k</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.item &gt;= k:</span><br><span class="line">            <span class="keyword">if</span> A.left:</span><br><span class="line">                <span class="keyword">return</span> A.left.subtree_find_prev(k)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">elif</span> A.right:</span><br><span class="line">            B = A.right.subtree_find_prev(k)</span><br><span class="line">            <span class="keyword">if</span> B:</span><br><span class="line">                <span class="keyword">return</span> B</span><br><span class="line">        <span class="keyword">return</span> A</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_insert</span>(<span class="params">A, B</span>):</span></span><br><span class="line">        <span class="keyword">if</span> B.item &lt; A.item:</span><br><span class="line">            <span class="keyword">if</span> A.left:</span><br><span class="line">                A.left.subtree_insert(B)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                A.subtree_insert_before(B)</span><br><span class="line">        <span class="keyword">elif</span> B.item &gt; A.item:</span><br><span class="line">            <span class="keyword">if</span> A.right:</span><br><span class="line">                A.right.subtree_insert(B)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                A.subtree_insert_after(B)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            A.item = B.item</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Binary_Tree</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">T, Node_Type=Binary_Node</span>):</span></span><br><span class="line">        T.root = <span class="literal">None</span></span><br><span class="line">        T.size = <span class="number">0</span></span><br><span class="line">        T.Node_Type = Node_Type</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">T</span>):</span> <span class="keyword">return</span> T.size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">T</span>):</span></span><br><span class="line">        <span class="keyword">if</span> T.root:</span><br><span class="line">            <span class="keyword">for</span> A <span class="keyword">in</span> T.root.subtree_iter():</span><br><span class="line">                <span class="keyword">yield</span> A.item</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Set_Binary_Set</span>(<span class="params">Binary_Tree</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(BST_Node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">iter_order</span>(<span class="params">self</span>):</span> <span class="keyword">yield</span> <span class="keyword">from</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">self, X</span>):</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> X:</span><br><span class="line">            self.insert(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_min</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.root:</span><br><span class="line">            <span class="keyword">return</span> self.root.subtree_first().item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_max</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.root:</span><br><span class="line">            <span class="keyword">return</span> self.root.subtree_last().item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, k</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.root:</span><br><span class="line">            node = self.root.subtree_find(k)</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                <span class="keyword">return</span> node.item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_next</span>(<span class="params">self, k</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.root:</span><br><span class="line">            node = self.root.subtree_find_next(k)</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                <span class="keyword">return</span> node.item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_prev</span>(<span class="params">self, k</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.root:</span><br><span class="line">            node = self.root.subtree_find_prev(k)</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                <span class="keyword">return</span> node.item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        new_node = self.Node_Type(x)</span><br><span class="line">        <span class="keyword">if</span> self.root:</span><br><span class="line">            self.root.subtree_insert(new_node)</span><br><span class="line">            <span class="keyword">if</span> new_node.parent <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.root = new_node</span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self, k</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.root:</span><br><span class="line">            node = self.root.subtree_find(k)</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                ext = node.subtree_delete()</span><br><span class="line">                <span class="keyword">if</span> ext.parent <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    self.root = <span class="literal">None</span></span><br><span class="line">                self.size -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> ext.item</span><br></pre></td></tr></table></figure>
<h3 id="面向序列接口的二叉树"><a href="#面向序列接口的二叉树" class="headerlink" title="面向序列接口的二叉树"></a>面向序列接口的二叉树</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">height</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="keyword">if</span> A:</span><br><span class="line">        <span class="keyword">return</span> A.height</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Binary_Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">A, x</span>):</span></span><br><span class="line">        A.item = x</span><br><span class="line">        A.left = <span class="literal">None</span></span><br><span class="line">        A.right = <span class="literal">None</span></span><br><span class="line">        A.parent = <span class="literal">None</span></span><br><span class="line">        A.subtree_update()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_update</span>(<span class="params">A</span>):</span></span><br><span class="line">        A.height = <span class="number">1</span> + <span class="built_in">max</span>(height(A.left), height(A.right))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skew</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="keyword">return</span> height(A.right) - height(A.left)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_iter</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.left:</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> A.left.subtree_iter()</span><br><span class="line">        <span class="keyword">yield</span> A</span><br><span class="line">        <span class="keyword">if</span> A.right:</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> A.right.subtree_iter()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_first</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.left:</span><br><span class="line">            <span class="keyword">return</span> A.left.subtree_first()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> A</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_last</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.right:</span><br><span class="line">            <span class="keyword">return</span> A.right.subtree_last()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> A</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">successor</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.right:</span><br><span class="line">            <span class="keyword">return</span> A.right.subtree_first()</span><br><span class="line">        <span class="keyword">while</span> A.parent <span class="keyword">and</span> (A <span class="keyword">is</span> A.parent.right):</span><br><span class="line">            A = A.parent</span><br><span class="line">        <span class="keyword">return</span> A.parent</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predecessor</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.left:</span><br><span class="line">            <span class="keyword">return</span> A.left.subtree_last()</span><br><span class="line">        <span class="keyword">while</span> A.parent <span class="keyword">and</span> (A <span class="keyword">is</span> A.parent.left):</span><br><span class="line">            A = A.parent</span><br><span class="line">        <span class="keyword">return</span> A.parent</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_rotate_right</span>(<span class="params">D</span>):</span></span><br><span class="line">        <span class="keyword">if</span> D.left:</span><br><span class="line">            B, E = D.left, D.right</span><br><span class="line">            A, C = B.left, B.right</span><br><span class="line">            D, B = B, D</span><br><span class="line">            D.item, B.item = B.item, D.item</span><br><span class="line">            B.left, B.right = A, D</span><br><span class="line">            D.left, D.right = C, E</span><br><span class="line">            <span class="keyword">if</span> A:</span><br><span class="line">                A.parent = B</span><br><span class="line">            <span class="keyword">if</span> E:</span><br><span class="line">                E.parent = D</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_rotate_left</span>(<span class="params">B</span>):</span></span><br><span class="line">        <span class="keyword">if</span> B.right:</span><br><span class="line">            A, D = B.left, B.right</span><br><span class="line">            C, E = D.left, D.right</span><br><span class="line">            B, D = D, B</span><br><span class="line">            B.item, D.item = D.item, B.item</span><br><span class="line">            D.left, D.right = B, E</span><br><span class="line">            B.left, B.right = A, C</span><br><span class="line">            <span class="keyword">if</span> A:</span><br><span class="line">                A.parent = B</span><br><span class="line">            <span class="keyword">if</span> E:</span><br><span class="line">                E.parent = D</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rebalance</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.skew == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> A.right.skew() &lt; <span class="number">0</span>:</span><br><span class="line">                A.right.subtree_rotate_right()</span><br><span class="line">            A.subtree_rotate_left()</span><br><span class="line">        <span class="keyword">elif</span> A.skew() == -<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> A.left.skew() &gt; <span class="number">0</span>:</span><br><span class="line">                A.left.subtree_rotate_left()</span><br><span class="line">            A.subtree_rotate_right()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maintain</span>(<span class="params">A</span>):</span></span><br><span class="line">        A.rebalance()</span><br><span class="line">        A.subtree_update()</span><br><span class="line">        <span class="keyword">if</span> A.parent:</span><br><span class="line">            A.parent.maintain()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_insert_before</span>(<span class="params">A, B</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.left:</span><br><span class="line">            A = A.left.subtree_last()</span><br><span class="line">            A.right, B.parent = B, A</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            A.left, B.parent = B, A</span><br><span class="line">        A.maintain()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_insert_after</span>(<span class="params">A, B</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.right:</span><br><span class="line">            A = A.right.subtree_first()</span><br><span class="line">            A.left, B.parent = B, A</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            A.right, B.parent = B, A</span><br><span class="line">        A.maintain()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_delete</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A.left <span class="keyword">or</span> A.right:</span><br><span class="line">            <span class="keyword">if</span> A.left:</span><br><span class="line">                B = A.predecessor()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                B = A.successor()</span><br><span class="line">            A.item, B.item = B.item, A.item</span><br><span class="line">            <span class="keyword">return</span> B.subtree_delete()</span><br><span class="line">        <span class="keyword">if</span> A.parent:</span><br><span class="line">            <span class="keyword">if</span> A <span class="keyword">is</span> A.parent.left:</span><br><span class="line">                A.parent.left = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                A.parent.right = <span class="literal">None</span></span><br><span class="line">            A.maintain()</span><br><span class="line">        <span class="keyword">return</span> A</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Binary_Tree</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">T, Node_Type=Binary_Node</span>):</span></span><br><span class="line">        T.root = <span class="literal">None</span></span><br><span class="line">        T.size = <span class="number">0</span></span><br><span class="line">        T.Node_Type = Node_Type</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">T</span>):</span> <span class="keyword">return</span> T.size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">T</span>):</span></span><br><span class="line">        <span class="keyword">if</span> T.root:</span><br><span class="line">            <span class="keyword">for</span> A <span class="keyword">in</span> T.root.subtree_iter():</span><br><span class="line">                <span class="keyword">yield</span> A.item</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Size_Node</span>(<span class="params">Binary_Node</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_update</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().subtree_update()</span><br><span class="line">        A.size = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> A.left:</span><br><span class="line">            A.size += A.left.size</span><br><span class="line">        <span class="keyword">if</span> A.right:</span><br><span class="line">            A.size += A.right.size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtree_at</span>(<span class="params">A, i</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt;= i:</span><br><span class="line">            <span class="keyword">if</span> A.left:</span><br><span class="line">                L_size = A.left.size</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                L_size = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; L_size:</span><br><span class="line">                <span class="keyword">return</span> A.left.subtree_at(i)</span><br><span class="line">            <span class="keyword">elif</span> i &gt; L_size:</span><br><span class="line">                <span class="keyword">return</span> A.right.subtree_at(i - L_size - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> A</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Seq_Binary_Tree</span>(<span class="params">Binary_Tree</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(Size_Node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">self, X</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">build_subtree</span>(<span class="params">X, i, j</span>):</span></span><br><span class="line">            c = (i + j) // <span class="number">2</span></span><br><span class="line">            root = self.Node_Type(X[c])</span><br><span class="line">            <span class="keyword">if</span> i &lt; c:</span><br><span class="line">                root.left = build_subtree(X, i, c - <span class="number">1</span>)</span><br><span class="line">                root.left.parent = root</span><br><span class="line">            <span class="keyword">if</span> c &lt; j:</span><br><span class="line">                root.right = build_subtree(X, c + <span class="number">1</span>, j)</span><br><span class="line">                root.right.parent = root</span><br><span class="line">            root.subtree_update()</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        self.root = build_subtree(X, <span class="number">0</span>, <span class="built_in">len</span>(X) - <span class="number">1</span>)</span><br><span class="line">        self.size = self.root.size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_at</span>(<span class="params">self, i</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.root:</span><br><span class="line">            <span class="keyword">return</span> self.root.subtree_at(i).item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_at</span>(<span class="params">self, i, x</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.root:</span><br><span class="line">            self.root.subtree_at(i).item = x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_at</span>(<span class="params">self, i, x</span>):</span></span><br><span class="line">        new_node = self.Node_Type(x)</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> self.root:</span><br><span class="line">                node = self.root.subtree_first()</span><br><span class="line">                node.subtree_insert_before(new_node)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.root = new_node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node = self.root.subtree_at(i - <span class="number">1</span>)</span><br><span class="line">            node.subtree_insert_after(new_node)</span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete_at</span>(<span class="params">self, i</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.root:</span><br><span class="line">            node = self.root.subtree_at(i)</span><br><span class="line">            ext = node.subtree_delete()</span><br><span class="line">            <span class="keyword">if</span> ext.parent <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                self.root = <span class="literal">None</span></span><br><span class="line">            self.size -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> ext.item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_first</span>(<span class="params">self, x</span>):</span> self.insert_at(<span class="number">0</span>, x)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete_first</span>(<span class="params">self, x</span>):</span> <span class="keyword">return</span> self.delete_at(<span class="number">0</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_last</span>(<span class="params">self, x</span>):</span> self.insert_at(<span class="built_in">len</span>(self), x)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete_last</span>(<span class="params">self</span>):</span> <span class="keyword">return</span> self.delete_at(<span class="built_in">len</span>(self)-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>course</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>人体解剖学 2 - 关节学基础</title>
    <url>/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E5%85%B3%E8%8A%82%E5%AD%A6/</url>
    <content><![CDATA[<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E5%85%B3%E8%8A%82%E5%AD%A6/01.png" class title="01.png">
<span id="more"></span>
<h2 id="关节学总论"><a href="#关节学总论" class="headerlink" title="关节学总论"></a>关节学总论</h2><h3 id="骨的连接方式"><a href="#骨的连接方式" class="headerlink" title="骨的连接方式"></a>骨的连接方式</h3><p>骨与骨之间籍<strong>纤维结缔组织</strong>、<strong>软骨</strong>或<strong>骨</strong>相连，形成骨连结。按连结的不同方式，可分为直接连结和间接连结两大类。</p>
<ul>
<li><strong>直接连结</strong><br>  骨与骨之间借助<strong>韧带</strong>(纤维结缔组织)、<strong>软骨</strong>或<strong>骨性结合</strong>进行连接，两骨之间没有间隙，较牢固，不活动或少许活动。这种连结可分为<strong>纤维连结</strong>、<strong>软骨连结</strong>和<strong>骨性结合</strong>三类。</li>
<li><strong>间接连结</strong><br>  借<strong>助结缔组织囊</strong>进行连接，两骨之间有间隙，活动度较大，又称为<strong>关节连接。关节</strong>是骨连结的最高分化形式，关节的相对骨面互相分离，之间为充以滑液的腔隙，其周围借结缔组织相连结，因而通常具有较大的活动性。</li>
</ul>
<h3 id="关节的基本构造"><a href="#关节的基本构造" class="headerlink" title="关节的基本构造"></a>关节的基本构造</h3><p>关节的基本构造包括<strong>关节面</strong>、<strong>关节囊</strong>和<strong>关节腔</strong>：<br><img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E5%85%B3%E8%8A%82%E5%AD%A6/02.png" class title="02.png"></p>
<ul>
<li><strong>关节面</strong>是参与组成关节的各相关骨的接触面。每一关节至少包括两个关节面，一般为一凸一凹，凸者称为<strong>关节头</strong>，凹者称为<strong>关节窝</strong>。关节面上终生被覆有<strong>关节软骨</strong>。关节软骨多数由透明软骨构成，少数为纤维软骨，其厚薄因不同的关节和年龄而异，通常为2～7mm。关节软骨不仅使粗糙不平的关节面变为光滑，同时在运动时可减少关节面的磨擦，缓冲震荡和冲击。</li>
<li><strong>关节囊</strong>是由纤维结缔组织膜构成的囊，附着于关节的周围，并与骨膜融合续连，它包围关节，封闭关节腔。可分为内外两层。<br>关节囊外层为<strong>纤维膜</strong>，厚而坚韧，由致密结缔组织构成，含有丰富的血管和神经。纤维膜的厚薄通常与关节的功能有关，如下肢关节的负重较大，相对稳固，其关节囊的纤维膜则坚韧而紧张。而上肢关节运动灵活，则纤维膜薄而松弛。纤维膜的有些部分，还可明显增厚形成韧带，以增强关节的稳固，限制其过度运动。<br>关节囊内层为<strong>滑膜</strong>，由薄而柔润的疏松结缔组织膜构成，衬贴于纤维膜的内面，其边缘附着于关节软骨的周缘，包被着关节内除关节软骨、关节唇和关节盘以外的所有结构。滑膜表面有时形成许多小突起，称为滑膜绒毛，多见于关节囊附着部的附近。滑膜富含血管网，能产生<strong>滑液</strong>。滑液是透明的蛋白样液体，呈弱碱性，它为关节内提供了液态环境，不仅能增加润滑，而且也是关节软骨、半月板等新陈代谢的重要媒介。</li>
<li><strong>关节腔</strong>为关节囊滑膜层和关节面共同围成的密闭腔隙，腔内含有少量滑液，关节腔内呈负压，对维持关节的稳固有一定作用。</li>
</ul>
<h3 id="关节的辅助结构"><a href="#关节的辅助结构" class="headerlink" title="关节的辅助结构"></a>关节的辅助结构</h3><p>关节除了具备上述的关节面、关节囊、关节腔三项基本结构外，一些关节为适应其功能还形成了特殊的辅助结构，这些辅助结构对于增加关节的灵活性或稳固性都有重要作用。</p>
<ul>
<li><strong>韧带</strong>：韧带是连于相邻两骨之间的<strong>致密结缔组织纤维束</strong>，有加强关节的稳固或限制其过度运动的作用。位于关节囊外的称<strong>囊外韧带；</strong>位于关节囊内的称<strong>囊内韧带</strong>，有滑膜包裹，如膝关节内的交叉韧带等。</li>
<li><strong>关节盘和关节唇</strong>：关节盘和关节唇是关节内两种不同形态的<strong>纤维软骨</strong>。<strong>关节盘</strong>位于构成关节骨的关节面之间，其周缘附着于关节囊，将关节腔分成两部。关节盘多呈圆盘状，中部稍薄，周缘略厚。有的关节盘呈半月形，称<strong>关节半月板</strong>。关节盘可<strong>调整关节面</strong>使其更为适配，<strong>减少</strong>外力对关节的<strong>冲击和震荡</strong>。此外，分隔而成的两个腔可增加关节运动的形式和范围。<strong>关节唇</strong>是附着于关节窝周缘的<strong>纤维软骨环</strong>，它<strong>加深关节窝</strong>，增大关节面，如髋臼唇等，增加了关节的稳固性。</li>
<li><strong>滑膜襞和滑膜囊</strong>：有些关节囊的滑膜表面积大于纤维层，滑膜重叠卷折并突入关节腔形成滑膜襞(bi)。有时此襞内含脂肪，则形成<strong>滑膜脂垫</strong>。在关节运动时，关节腔的形状、容积、压力发生改变，滑膜脂垫可<strong>起调节或填充作用</strong>。滑膜襞和滑膜脂垫在关节腔内扩大了滑膜的面积，有利于滑液的分泌和吸收。有时滑膜也可从关节囊纤维膜的薄弱或缺如处作囊状膨出，充填于肌腱与骨面之间，形成滑膜囊，它可<strong>减少</strong>肌肉活动时与骨面之间的<strong>磨擦</strong>。</li>
</ul>
<h2 id="躯干骨的连接"><a href="#躯干骨的连接" class="headerlink" title="躯干骨的连接"></a>躯干骨的连接</h2><p>躯干骨的连接包括椎骨间的连接形成<strong>脊柱</strong>和由胸椎、肋骨和胸骨连接构成的<strong>胸廓</strong>。脊柱由躯干骨的<strong>24块椎骨</strong>、<strong>1块骶骨</strong>和<strong>1块尾骨</strong>籍骨连结形成，构成人体的中轴，上端承载颅，下端连接肢带骨。胸廓由<strong>12块胸椎</strong>、<strong>12对肋</strong>及<strong>胸骨</strong>连接而成。</p>
<h3 id="脊柱"><a href="#脊柱" class="headerlink" title="脊柱"></a>脊柱</h3><p>脊柱由各椎骨之间籍<strong>韧带</strong>、<strong>关节</strong>和<strong>间盘</strong>相连，可分为椎体间连结和椎弓间连结。<br><img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E5%85%B3%E8%8A%82%E5%AD%A6/03.png" class title="03.png"></p>
<ul>
<li>椎体间的连结：椎体之间籍<strong>椎间盘</strong>及<strong>前、后纵韧带</strong>相连。<ul>
<li><strong>椎间盘</strong>是连结相邻两个椎体的<strong>纤维软骨盘</strong>(第1及第2颈椎之间除外)，成人有23个椎间盘。椎间盘由两部分构成，中央部为<strong>髓核</strong>，是柔软而富有弹性的胶状物质，为胚胎时脊索的残留物。周围部为<strong>纤维环</strong>，由多层纤维软骨环按同心圆排列组成，牢固连结各椎体上、下面，保护髓核并限制髓核向周围膨出。椎间盘既坚韧，又富弹性，承受压力时被压缩，除去压力后又复原，具有“<strong>弹性垫</strong>”的作用，可<strong>缓冲</strong>外力对脊柱的<strong>震动</strong>，也可<strong>增加</strong>脊柱的<strong>运动幅度</strong>。23个椎间盘的厚薄各不相同，中胸部较薄，颈部较厚，而腰部最厚，所以颈、腰椎的活动度较大。颈腰部的椎间盘前厚后薄，胸部的则与此相反。其厚薄和大小可随年龄而有差异。当纤维环破裂时，髓核容易向后外侧脱出，突入椎管或椎间孔，压迫相邻的脊髓或神经根引起牵涉性痛，临床称为<strong>椎间盘脱出症</strong>。</li>
<li><strong>前纵韧带</strong>是椎体前面延伸的一束坚固的纤维束，宽而坚韧，上自枕骨大孔前缘，下达第1或第2骶椎椎体。其纵行的纤维<strong>牢固地附着</strong>于椎体和椎间盘，有防止脊柱过度后伸和椎间盘向前脱出的作用。</li>
<li><strong>后纵韧带</strong>位于椎管内椎体的后面，窄而坚韧。起自枢椎并与覆盖枢椎椎体的覆膜相续，下达骶骨。与椎间盘纤维环及椎体上下缘紧密连结，而与椎体结合较为疏松，有限制脊柱过度前屈的作用。</li>
</ul>
</li>
<li>椎弓间的连结：包括椎弓板、棘突、横突间的<strong>韧带连结</strong>和上、下关节突间的<strong>滑膜关节</strong>。<ul>
<li><strong>黄韧带</strong>位于椎管内，为连结相邻两椎弓板间的韧带，由黄色的弹性纤维构成。黄韧带协助围成椎管，并有限制脊柱过度前屈的作用。</li>
<li><strong>棘间韧带</strong>连结相邻棘突间的薄层纤维，附着于棘突根部到棘突尖。向前与黄韧带、向后与棘上韧带相移行。</li>
<li><strong>棘上韧带</strong>是连结胸、腰、骶椎各棘突尖之间的纵行韧带，前方与棘间韧带相融合，有限制脊柱前屈的作用。而在颈部，从颈椎棘突尖向后扩展成三角形板状的弹性膜层，称为<strong>项韧带</strong>。项韧带常被认为是棘上韧带和颈椎棘突间韧带的延续，向上附着于枕外隆凸及枕外嵴，向下达第7颈椎棘突并续于棘上韧带，是颈部肌肉附着的双层致密弹性纤维隔。</li>
<li>横突间韧带位于相邻椎骨横突间的纤维索，部分与横突间肌混合。</li>
<li>关节突关节由相邻椎骨的上、下关节突的关节面构成，属平面关节，只能作轻微滑动。</li>
</ul>
</li>
<li><strong>脊柱的整体观</strong><ul>
<li>脊柱的整体观：脊柱的功能是支持躯干和保护脊髓。成年男性脊柱长约70cm，女性的略短，约60cm。其长度可因姿势不同而略有差异，静卧比站立时可长出2～3cm，这是由于站立时椎间盘被压缩所致。椎间盘的总厚度约为脊柱全长的1/4。老年可因椎间盘胶原成分改变而变薄，骨质疏松而致椎体加宽和高度减小，以及脊柱肌肉动力学下降致胸曲和颈曲的凸度增加，这些变化都直接导致老年脊柱的长度减小。</li>
<li><strong>脊柱前面观</strong>：从前面观察脊柱，自第2颈椎到第3骶椎的<strong>椎体宽度</strong>，自上而下随负载增加而<strong>逐渐加宽</strong>，到<strong>第2骶椎为最宽</strong>。骶骨耳状面以下，由于重力经髂骨传到下肢骨，椎体已无承重意义，体积也逐渐缩小。从前面观察脊柱，正常人的脊柱有轻度侧屈，惯用右手的人，脊柱上部略凸向右侧，下部则代偿性地略凸向左侧。</li>
<li><strong>脊柱后面观</strong>：从后面观察脊柱，可见所有<strong>椎骨棘突连贯形成纵嵴</strong>，位于背部正中线上。<strong>颈椎</strong>棘突短而分叉，<strong>近水平位</strong>。<strong>胸椎</strong>棘突细长，<strong>斜向后下方</strong>，呈叠瓦状排列。<strong>腰椎</strong>棘突呈板状，<strong>水平伸向后方</strong>。</li>
<li><strong>脊柱侧面观</strong>：从侧面观察脊柱，可见<strong>成人脊柱有颈、胸、腰、骶4个生理性弯曲</strong>。其中，<strong>颈曲和腰曲凸向前</strong>，<strong>胸曲和骶曲凸向后</strong>。脊柱的这些弯曲增大了脊柱的弹性，对维持人体的重心稳定和减轻震荡有重要意义。胸曲和骶曲凹向前方，在胚胎时已形成，胚胎是在全身屈曲状态下发育。婴儿出生后的开始抬头、坐起及站立行走对颈曲和腰曲的形成产生明显影响。脊柱的每一个弯曲，都有它的功能意义，<strong>颈曲支持头的抬起</strong>，<strong>腰曲使身体重心垂线后移</strong>，以维持身体的前后平衡，保持稳固的直立姿势，而<strong>胸曲和骶曲</strong>在一定意义上<strong>扩大了胸腔和盆腔的容积</strong>。<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E5%85%B3%E8%8A%82%E5%AD%A6/04.png" class title="04.png">
</li>
</ul>
</li>
</ul>
<h3 id="胸廓"><a href="#胸廓" class="headerlink" title="胸廓"></a>胸廓</h3><ul>
<li><strong>组成</strong>：胸廓由<strong>12块胸椎</strong>、<strong>12对肋</strong>、<strong>1块胸骨</strong>和它们之间的连结共同构成。它上窄，下宽，前后扁平，由于胸椎椎体前凸，水平切面上呈肾形。</li>
<li><strong>连接</strong>：构成胸廓的主要关节有<strong>胸肋关节</strong>和<strong>肋椎关节</strong><ul>
<li><strong>胸肋关节：</strong>由第2～7肋软骨与胸骨相应的肋切迹构成，属<strong>微动关节</strong>。第1肋与胸骨柄之间为软骨结合。第8～10肋软骨的前端不直接与胸骨相连，而依次与上位肋软骨形成<strong>软骨间连结</strong>，在两侧各形成一个肋弓。第11和12肋的前端游离于腹壁肌肉之中。</li>
<li><strong>肋椎关节：</strong>肋骨与脊柱的连结包括肋头和椎体的连结即<strong>肋头关节</strong>，以及肋结节和横突的连结即<strong>肋横突关节</strong>。<strong>肋头关节</strong>由肋头的关节面与相邻胸椎椎体边缘的肋凹（常称半关节面）构成，有肋头幅状韧带和关节内韧带加强。<strong>肋横突关节</strong>由肋结节关节面与相应椎骨的横突肋凹构成，有肋横突韧带、囊韧带、肋横突上韧带和肋横突外侧韧带等加强。这两个关节在功能上是联合关节，运动时肋骨沿肋头至肋结节的轴线旋转，使肋上升或下降，以增加或缩小胸廓的前后径和横径，从而改变胸腔的容积有助于呼吸。</li>
</ul>
</li>
<li><strong>特点</strong>：上窄下宽、前后径小于左右径、脊柱突入胸廓内形成两侧肋窝。</li>
<li><strong>胸廓上下口</strong><ul>
<li><strong>胸廓上口</strong>由胸骨柄上缘、第1肋和第1胸椎椎体围成，是胸腔与颈部的通道</li>
<li><strong>胸廓下口</strong>由剑突、两侧肋弓<strong>、</strong>第12及第11对肋前端和第12胸椎围成，膈肌封闭胸腔底</li>
</ul>
</li>
<li><strong>体表标志：</strong>两侧肋弓在中线构成向下开放的<strong>胸骨下角</strong>。角的尖部有<strong>剑突</strong>，剑突又将胸骨下角分成了<strong>左、右剑肋角</strong>。剑突尖约平对第10胸椎下缘。<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E5%85%B3%E8%8A%82%E5%AD%A6/05.png" class title="05.png">
</li>
</ul>
<h2 id="上肢肢带骨的连接"><a href="#上肢肢带骨的连接" class="headerlink" title="上肢肢带骨的连接"></a>上肢肢带骨的连接</h2><h3 id="胸锁关节"><a href="#胸锁关节" class="headerlink" title="胸锁关节"></a><strong>胸锁关节</strong></h3><p><strong>胸锁关节</strong>是上肢骨与躯干骨间连结的惟一关节。由<strong>锁骨的胸骨端</strong>与<strong>胸骨的锁切迹</strong>及第一肋软骨的上面构成，属于<strong>多轴关节</strong>。关节囊坚韧并由胸锁前、后韧带，锁间韧带、肋锁韧带等囊外韧带加强。关节腔内有纤维软骨构成的关节盘，将关节腔分为外上和内下两部分。胸锁关节允许锁骨外侧端向前、向后运动20°～30°角；向上、向下运动约60°角；绕冠状轴作微小的旋转和环转运动。胸锁关节的活动度虽小，但以此为支点扩大了上肢的活动范围。</p>
<h3 id="肩锁关节"><a href="#肩锁关节" class="headerlink" title="肩锁关节"></a><strong>肩锁关节</strong></h3><p><strong>肩锁关节</strong>由<strong>锁骨的肩峰端</strong>与<strong>肩峰的关节面</strong>构成，属于<strong>平面关节</strong>。是肩胛骨活动的支点。关节的上方有肩锁韧带加强，关节囊和锁骨下方有坚韧的喙锁韧带连于喙突。关节活动度小。<br><img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E5%85%B3%E8%8A%82%E5%AD%A6/06.png" class title="06.png"></p>
<hr>
<h2 id="上肢自由骨的连接"><a href="#上肢自由骨的连接" class="headerlink" title="上肢自由骨的连接"></a>上肢自由骨的连接</h2><h3 id="肩关节"><a href="#肩关节" class="headerlink" title="肩关节"></a>肩关节</h3><p>肩关节是全身最灵活的关节，由<strong>肱骨头</strong>与<strong>肩胛骨关节盂</strong>(yu)构成，也称盂肱关节，是典型的<strong>球窝关节。</strong>肩关节有如下特点：</p>
<ul>
<li><strong>头大盂小</strong>：肱骨头近似圆球且较大，关节盂<strong>浅而小。</strong>关节盂的周缘有纤维软骨构成的<strong>盂唇(盂缘)</strong>来加深关节窝，但仅能容纳关节头的1/4 ～ 1/3。肩关节的这种结构形状增加了运动幅度，但也降低了关节的稳定性，因此，关节周围的<strong>肌肉、韧带</strong>对其稳固性起了重要作用。</li>
<li><strong>关节囊薄而松弛：</strong>关节囊的肩胛骨端附着于关节盂的周缘，肱骨端附于肱骨解剖颈，在内侧可达肱骨外科颈。关节囊的滑膜层可膨出形成滑液鞘或滑膜囊，以利于肌腱的活动。<strong>肱二头肌长头腱</strong>就在结节间滑液鞘内<strong>穿过关节囊</strong>。关节囊的上壁有喙肱韧带，从喙突根部至肱骨大结节前面，与冈上肌腱交织在一起并融入关节囊的纤维层。囊的前壁和后壁也有数条肌腱的纤维加入，以增加关节的稳固性。</li>
<li><strong>关节脱位</strong>：关节囊的下壁最为薄弱，故肩关节脱位时，肱骨头常从前下方滑出，发生<strong>前脱位</strong>。此时患者表现方肩（肩峰突出），以及搭背实验阳性。<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E5%85%B3%E8%8A%82%E5%AD%A6/07.png" class title="07.png">
</li>
</ul>
<h3 id="肘关节"><a href="#肘关节" class="headerlink" title="肘关节"></a>肘关节</h3><p>是由<strong>肱骨</strong>下端与<strong>尺骨</strong>、<strong>桡骨</strong>上端构成的复关节，包括<strong>三骨六面三关节</strong>。</p>
<ul>
<li>肘关节的<strong>组成</strong><ul>
<li><strong>肱骨滑车</strong>和<strong>尺骨滑车切迹</strong>构成<strong>肱尺关节</strong></li>
<li><strong>肱骨小头</strong>和<strong>桡骨头的关节凹</strong>构成<strong>肱桡关节</strong></li>
<li><strong>桡骨环状关节面</strong>和<strong>尺骨桡切迹</strong>构成<strong>桡尺近侧关节</strong></li>
</ul>
</li>
<li><strong>肘关节的关节囊</strong><br>  肘关节的3个关节包在一个关节囊内，肘<strong>关节囊前、后壁薄而松弛</strong>，两侧壁厚而紧张，并有<strong>韧带加强</strong>。囊的后壁最薄弱，常见桡、尺两骨<strong>向后脱位</strong>，移向肱骨的后上方。</li>
<li>肘关节的<strong>韧带</strong><ul>
<li><strong>桡侧副韧带</strong>位于囊的桡侧，由肱骨外上髁向下扩展，止于桡骨环状韧带。</li>
<li><strong>尺侧副韧带</strong>位于囊的尺侧，由肱骨内上髁向下呈扇形扩展，止于尺骨滑车切迹内侧缘。</li>
<li><strong>桡骨环状韧带</strong>位于桡骨环状关节面的周围，两端附着于尺骨桡切迹的前、后缘，与尺骨桡切迹共同构成一个上口大、下口小的骨纤维环容纳桡骨头，防止桡骨头脱出。</li>
</ul>
</li>
<li>肘关节的<strong>运动</strong><br>  肘关节的运动以肱尺关节为主，允许作<strong>屈、伸运动</strong>，尺骨在肱骨滑车上运动，桡骨头在肱骨小头上运动。因肱骨滑车的内侧缘更为向前下突出，超过外侧缘约6mm，使关节的运动轴斜向下内，当伸前臂时，前臂偏向外侧，与臂形成约163°的“提携角”。肱桡关节能作屈、伸和旋前、旋后运动，桡尺近侧关节与桡尺远侧关节联合可使前臂<strong>旋前和旋后</strong>。</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E5%85%B3%E8%8A%82%E5%AD%A6/09.png" class title="09.png">
<h3 id="桡尺连结"><a href="#桡尺连结" class="headerlink" title="桡尺连结"></a><strong>桡尺连结</strong></h3><p>桡骨和尺骨借<strong>桡尺近侧关节</strong>、<strong>桡尺远侧关节</strong>和<strong>前臂骨间膜</strong>相连。</p>
<ul>
<li><strong>桡尺近侧关节</strong>见肘关节</li>
<li><strong>桡尺远侧关节</strong>由尺骨头环状关节面构成关节头，由桡骨的尺切迹及自下缘至尺骨茎突根部的关节盘共同构成关节窝。关节盘为三角形纤维软骨板，将尺骨头与腕骨隔开。关节囊松弛，附着于关节面和关节盘周缘。</li>
<li><strong>前臂骨间膜</strong>连结尺骨和桡骨的<strong>骨间缘之间的坚韧纤维膜</strong>。纤维方向是从桡骨斜向下内达尺骨。当前臂处于旋前或旋后位时，骨间膜松弛。前臂处于半旋前位时，骨间膜最紧张，这也是骨间膜的最大宽度。因此，处理前臂骨折时，应将前臂固定于半旋前或半旋后位，以防骨间膜挛缩，影响前臂愈后的旋转功能。</li>
<li>桡尺近侧和远侧关节是<strong>联动关节</strong>，<strong>前臂可作旋转运动</strong>，其旋转轴为通过桡骨头中心至尺骨头中心的连线(<strong>桡骨绕尺骨旋转</strong>)，运动时桡骨下端连同关节盘围绕尺骨头旋转。当桡骨转至尺骨前方并与之相交叉时，手背向前，称为旋前；与此相反的运动，即桡骨转回到尺骨外侧，称为旋后。</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E5%85%B3%E8%8A%82%E5%AD%A6/10.png" class title="10.png">
<h3 id="桡腕关节"><a href="#桡腕关节" class="headerlink" title="桡腕关节"></a>桡腕关节</h3><p>桡腕关节，又称腕关节，是典型的椭圆关节。</p>
<ul>
<li>桡腕关节的<strong>组成</strong>与<strong>特点</strong><ul>
<li><strong>关节头</strong>：由手的<strong>舟骨</strong>、<strong>月骨</strong>和<strong>三角骨</strong>的近侧关节面构成</li>
<li><strong>关节窝</strong>：<strong>桡骨的腕关节面</strong>和<strong>尺骨头下方</strong>的<strong>关节盘</strong>构成(尺骨不参与构成桡腕关节)</li>
<li><strong>关节囊</strong>：关节囊<strong>松弛</strong>，关节的前、后和两侧均有韧带加强，<strong>掌侧韧带</strong>最为坚韧，因此腕关节的后伸运动受限。</li>
</ul>
</li>
<li>桡腕关节的<strong>运动</strong><ul>
<li>桡腕关节可作<strong>屈、伸、展、收</strong>及<strong>环转运动</strong></li>
</ul>
</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E5%85%B3%E8%8A%82%E5%AD%A6/11.png" class title="11.png">
<h2 id="下肢肢带骨的连接"><a href="#下肢肢带骨的连接" class="headerlink" title="下肢肢带骨的连接"></a>下肢肢带骨的连接</h2><h3 id="骶髂关节"><a href="#骶髂关节" class="headerlink" title="骶髂关节"></a>骶髂关节</h3><ul>
<li>骶髂关节由<strong>骶骨</strong>和<strong>髂骨</strong>的<strong>耳状面</strong>构成，<strong>关节面凸凹不平</strong>，彼此<strong>结合紧密</strong>。关节囊紧张，有骶髂前、后韧带加强。关节后上方有骶髂骨间韧带充填和连结。骶髂关节具有相当大的<strong>稳固性</strong>，以适应支持体重的功能。妊娠妇女其活动度可稍增大。</li>
</ul>
<h3 id="耻骨联合"><a href="#耻骨联合" class="headerlink" title="耻骨联合"></a>耻骨联合</h3><ul>
<li>耻骨联合由两侧<strong>耻骨联合面</strong>借纤维软骨构成的<strong>耻骨间盘</strong>连结构成。耻骨间盘中往往出现一<strong>矢状位的裂隙</strong>，女性较男性的厚，裂隙也较大，孕妇和经产妇尤为显著。在耻骨联合的上、下方分别有连结两侧耻骨的<strong>耻骨上韧带</strong>和<strong>耻骨弓状韧带</strong>。耻骨联合的活动甚微，但在分娩过程中，耻骨间盘中的裂隙增宽，以增大骨盆的径线。</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E5%85%B3%E8%8A%82%E5%AD%A6/13.png" class title="13.png">
<h3 id="骨盆"><a href="#骨盆" class="headerlink" title="骨盆"></a>骨盆</h3><ul>
<li>骨盆由左右<strong>髋骨</strong>、<strong>骶骨和尾骨</strong>组成。人体直立时，骨盆向前倾斜，两侧髂前上棘与两耻骨结节位于同一冠状面内，此时，尾骨尖与耻骨联合上缘位于同一水平面上。骨盆可由<strong>骶骨岬</strong>向两侧经<strong>弓状线</strong>、<strong>耻骨梳</strong>、<strong>耻骨结节</strong>至<strong>耻骨联合上缘</strong>构成的<strong>环形界线</strong>(大小骨盆分界线)，分为上方的<strong>大骨盆</strong>又称假骨盆，和下方的<strong>小骨盆</strong>又称真骨盆。</li>
<li>小骨盆是大骨盆向下延伸的骨性狭窄部，可分为<strong>骨盆上口</strong>、<strong>骨盆下口</strong>和<strong>骨盆腔</strong>。骨盆上口由上述界线围成，呈圆形或卵圆形。骨盆下口由<strong>尾骨尖</strong>、<strong>骶结节韧带</strong>、<strong>坐骨结节</strong>、<strong>坐骨支</strong>、<strong>耻骨下支</strong>和<strong>耻骨联合下缘围成</strong>，呈菱形。两侧坐骨支与耻骨下支连成耻骨弓，它们之间的夹角称为耻骨下角。骨盆上、下口之间的腔称为<strong>骨盆腔</strong>，也称为<strong>固有盆腔</strong>。该腔内有直肠、膀胱和部分生殖器官。骨盆腔是一前壁短，侧壁和后壁较长的弯曲通道，其中轴为骨盆轴，分娩时，胎儿循此轴娩出。</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E5%85%B3%E8%8A%82%E5%AD%A6/14.png" class title="14.png">
<h2 id="下肢自由骨的连接"><a href="#下肢自由骨的连接" class="headerlink" title="下肢自由骨的连接"></a>下肢自由骨的连接</h2><h3 id="髋关节"><a href="#髋关节" class="headerlink" title="髋关节"></a>髋关节</h3><ul>
<li><strong>组成</strong>：髋关节由<strong>髋臼</strong>与<strong>股骨头</strong>构成，属球窝关节。髋臼的周缘附有<strong>纤维软骨</strong>构成的<strong>髋臼唇</strong>，以增加髋臼的深度。髋臼切迹被髋臼横韧带封闭，使半月形的髋臼关节面扩大为环形以紧抱股骨头。髋臼窝内充填有脂肪组织。</li>
<li><strong>关节囊</strong>：髋关节的关节囊<strong>坚韧致密</strong>，<strong>包络范围广</strong>。向上附着于髋臼周缘及横韧带，向下附着于股骨颈，前面达转子间线，后面包罩股骨颈的<strong>内侧2/3</strong>(转子间嵴略上方处)。因此股骨颈骨折有<strong>囊内、囊外骨折</strong>之分。</li>
<li><strong>韧带</strong>：关节囊周围有多条韧带加强<ul>
<li><strong>髂股韧带</strong>：最为强健，起自髂前下棘，呈人字形向下经囊的前方止于转子间线。可限制大腿过伸，对维持人体直立姿势有很大作用。</li>
<li><strong>股骨头韧带</strong>：<strong>位于关节内</strong>，连结股骨头凹和髋臼横韧带之间，为滑膜所包被，内含营养股骨头的血管。当大腿半屈并内收时，韧带紧张，外展时韧带松弛。</li>
<li><strong>耻股韧带</strong>：由耻骨上支向外下于关节囊前下壁与髂股韧带的深部融合。可限制大腿的外展及旋外运动。</li>
<li><strong>坐股韧带</strong>：加强关节囊的后部，起自坐骨体，斜向外上与关节囊融合，附着于大转子根部。可限制大腿的旋内运动。</li>
<li><strong>轮匝带</strong>：是关节囊的深层纤维围绕股骨颈的环形增厚，可约束股骨头向外脱出。</li>
</ul>
</li>
<li><strong>运动</strong>：髋关节可作三轴的<strong>屈、伸、展、收、旋内、旋外</strong>以及<strong>环转</strong>运动。由于股骨头深藏于髋臼内，关节囊相对紧张而坚韧，又受多条韧带限制，其运动幅度远不及肩关节，但具有<strong>较大的稳固性</strong>，以适应其<strong>承重和行走</strong>的功能。</li>
<li><strong>脱位</strong>：髋关节囊的后下部相对较薄弱，脱位时，股骨头易向下方脱出(<strong>后脱位</strong>)</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E5%85%B3%E8%8A%82%E5%AD%A6/15.png" class title="15.png">
<h3 id="膝关节"><a href="#膝关节" class="headerlink" title="膝关节"></a>膝关节</h3><ul>
<li><strong>组成</strong>：膝关节由<strong>股骨下端</strong>、<strong>胫骨上端</strong>和<strong>髌骨</strong>构成(腓骨不参与构成膝关节)，是<strong>人体最大最复杂</strong>的关节。髌骨与股骨的髌面相接，股骨的内、外侧髁分别与胫骨的内、外侧髁相对。</li>
<li><strong>关节囊：</strong>膝关节的关节囊<strong>薄而松弛</strong>，附着于各关节面的周缘，周围有韧带加固，以增加关节的稳定性。</li>
<li><strong>囊外韧带</strong>：<ul>
<li><strong>髌韧带</strong>为股四头肌腱的中央部纤维索，自髌骨向下止于胫骨粗隆。髌韧带扁平而强韧，其浅层纤维越过髌骨连于股四头肌腱。</li>
<li><strong>腓侧副韧带</strong>为条索状坚韧的纤维索，起自股骨外上髁，向下延伸至腓骨头。韧带表面大部分被股二头肌腱所遮盖，与外侧半月板不直接相连。</li>
<li><strong>胫侧副韧带</strong>呈宽扁束状，位于膝关节内侧后份。起自股骨内上髁，向下附着于胫骨内侧髁及相邻骨体，与关节囊和内侧半月板紧密结合。<br>  胫侧副韧带和腓侧副韧带在伸膝时紧张，屈膝时松弛，半屈膝时最松弛。因此，在半屈膝位允许膝关节作少许旋内和旋外运动。</li>
<li>腘斜韧带由半膜肌腱延伸而来，起自胫骨内侧髁，斜向外上方，止于股骨外上髁，部分纤维与关节囊融合，可防止膝关节过伸。</li>
</ul>
</li>
<li><strong>囊内韧带</strong>：囊内<strong>十字交叉韧带</strong>位于膝关节中央稍后方，非常强韧，由滑膜衬覆，分为前、后两条<ul>
<li><strong>前交叉韧带</strong>，起自胫骨髁间隆起的前方内侧，与内、外侧半月板的前角愈着，斜向后上方外侧，纤维呈扇形附着于股骨外侧髁的内侧。</li>
<li><strong>后交叉韧带</strong>，较前交叉韧带短而强韧，并较垂直。起自胫骨髁间隆起的后方，斜向前上方内侧，附着于股骨内侧髁的外侧面。</li>
<li>膝交叉韧带牢固地连结股骨和胫骨，可<strong>限制胫骨</strong>沿股骨<strong>向前、后移位</strong>。前交叉韧带在伸膝时最紧张，能限制胫骨前移。后交叉韧带在屈膝时最紧张，可限制胫骨后移。</li>
</ul>
</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E5%85%B3%E8%8A%82%E5%AD%A6/16.png" class title="16.png">
<ul>
<li><strong>膝关节囊的滑膜层</strong>是全身关节中最宽阔最复杂的，附着于该关节各骨的关节面周缘，覆盖关节内除了关节软骨和半月板以外的所有结构。滑膜在髌骨上缘的上方，向上突起形成长5cm左右的<strong>髌上囊</strong>于股四头肌腱和股骨体下部之间(降低股四头肌肌腱与股骨的摩擦)。在髌骨下方的中线两侧，部分滑膜层突向关节腔内，形成一对<strong>翼状襞</strong>，襞内含有脂肪组织(充填关节腔内的空隙)。还有不与关节腔相通的滑液囊，如位于髌韧带与胫骨上端之间的<strong>髌下深囊</strong>。</li>
<li><strong>半月板：</strong>是垫在股骨内、外侧髁与胫骨内、外侧髁关节面之间的两块半月形纤维软骨板，分别称为内、外侧半月板。<strong>内侧半月板</strong>，较大，<strong>呈“C”形</strong>，前端窄后份宽，外缘与关节囊及胫侧副韧带紧密相连。<strong>外侧半月板</strong>，较小，<strong>近似“O”形</strong>，外缘亦与关节囊相连。半月板上面凹陷，下面平坦，外缘厚，内缘薄，两端借韧带附着于胫骨髁间隆起。<strong>周围区</strong>有来自关节囊的<strong>毛细血管</strong>袢分布，<strong>内侧区域</strong>相对<strong>无血管</strong>。半月板使<strong>关节面更为相适</strong>，也能<strong>缓冲压力</strong>，吸收震荡，起弹性垫的作用。半月板还增大了关节窝的深度，又能连同股骨髁一起对胫骨作旋转运动。半月板的位置随着膝关节的运动而改变，屈膝时，半月板滑向后方，伸膝时滑向前方。在半屈膝旋转小腿时，一个半月板滑向前，另一个滑向后。例如，伸膝时，胫骨两髁连同半月板，沿着股骨两髁的关节面，自后向前滑动。由于股骨两髁关节面后部的曲度较下部的大，所以在伸的过程中，股骨两髁与胫骨两髁的接触面积逐渐增大，与此相应，两个半月板也逐渐向前方滑动。由于半月板随膝关节运动而移动，当膝关节在急骤强力动作时，常造成半月板损伤。例如，当急剧伸小腿并作强力旋转（如踢足球）时，半月板尚未来得及前滑，被膝关节上、下关节面挤住，即可发生半月板挤伤或破裂。由于内侧半月板与关节囊及胫侧副韧带紧密相连，因而<strong>内侧半月板损伤的机会较多</strong>。</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E5%85%B3%E8%8A%82%E5%AD%A6/17.png" class title="17.png">
<h3 id="胫腓连结"><a href="#胫腓连结" class="headerlink" title="胫腓连结"></a>胫腓连结</h3><ul>
<li>胫、腓两骨之间的连结紧密，上端由胫骨外侧髁与腓骨头构成微动的<strong>胫腓关节</strong>，两骨干之间有坚韧的<strong>小腿骨间膜</strong>相连，下端借胫腓前、后韧带构成坚强的韧带连结。小腿两骨间的活动度甚小。</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E5%85%B3%E8%8A%82%E5%AD%A6/18.png" class title="18.png">
<h3 id="距小腿关节"><a href="#距小腿关节" class="headerlink" title="距小腿关节"></a>距小腿关节</h3><ul>
<li>足关节包括距小腿（踝）关节、跗骨间关节、跗跖关节、跖骨间关节、<strong>跖趾关节</strong>和趾骨间关节。</li>
<li>距小腿关节亦称<strong>踝关节</strong>，由<strong>胫、腓骨下端</strong>与<strong>距骨滑车</strong>构成，近似单轴的屈戌关节，在足背屈或跖屈时，其旋转轴是可变的。踝关节的关节囊附着于各关节面的周围，囊的前、后壁薄而松弛，两侧有韧带增厚加强。内侧有<strong>内侧韧带</strong>（或称三角韧带），为坚韧的三角形纤维索，起自内踝尖，向下呈扇形展开，止于足舟骨、距骨和跟骨。外侧韧带由不连续的三条独立的韧带组成，前为距腓前韧带，中为跟腓韧带，后为距腓后韧带，三条韧带均起自外踝，分别向前、向下和向后内止于距骨及跟骨，均较薄弱。</li>
<li>踝关节能作<strong>背屈</strong>（伸）和<strong>跖屈</strong>（屈）运动。距骨滑车前宽后窄，当背屈时，较宽的滑车前部嵌入关节窝内，踝关节较稳定。当跖屈时，由于较窄的滑车后部进入关节窝内，足能作轻微的侧方运动，关节不够稳定，故踝关节扭伤多发生在跖屈（如下山、下坡、下楼梯）的情况。</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E5%85%B3%E8%8A%82%E5%AD%A6/19.png" class title="19.png">]]></content>
      <categories>
        <category>biomechanics</category>
      </categories>
      <tags>
        <tag>人体解剖学</tag>
      </tags>
  </entry>
  <entry>
    <title>人体解剖学 1 - 骨学基础</title>
    <url>/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E9%AA%A8%E5%AD%A6/</url>
    <content><![CDATA[<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E9%AA%A8%E5%AD%A6/00.png" class title="00.png">
<span id="more"></span>
<h2 id="骨学总论"><a href="#骨学总论" class="headerlink" title="骨学总论"></a>骨学总论</h2><p>骨是人体重要的器官之一，骨组织主要由骨细胞、胶原纤维和基质等构成，具有一定的形态，外被骨膜，内容骨髓，含有丰富的血管、淋巴管及神经；具有一定的功能，能不断进行新陈代谢和生长发育，并有修复、再生和重塑的能力。经常锻炼可促进骨的良好发育，长期废用则出现骨质疏松。骨基质中沉积有大量钙盐和磷酸盐，是人体钙、磷的储存库，参与体内钙、磷代谢。骨髓有造血功能。</p>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E9%AA%A8%E5%AD%A6/01.png" class title="01.png">
<h3 id="骨的形态"><a href="#骨的形态" class="headerlink" title="骨的形态"></a>骨的形态</h3><p>成人有206块骨，可分为颅骨、躯干骨和四肢骨三部分。前二者也称为中轴骨。按形态，骨可分为4类：</p>
<ul>
<li><strong>长骨</strong>：呈长管状，分布于四肢，如尺骨和掌骨等。长骨分为一体两端, 体又称<strong>骨干</strong>，内有空腔称<strong>髓腔</strong>，容纳骨髓。体表面有1～2个血管出入的孔，称<strong>滋养孔</strong>。两端膨大称<strong>骺（hou）</strong>，有一光滑的关节面，与相邻关节面构成关节。</li>
<li><strong>短骨</strong>：形似立方体，多成群分布于连结牢固且较灵活的部位，如腕骨和附骨。</li>
<li><strong>扁骨</strong>：呈板状，主要构成颅腔、胸腔和盆腔的壁，起保护作用，如颅盖骨和肋骨。</li>
<li><strong>不规则骨</strong>：形状不规则，如椎骨。有些不规则骨内有腔洞，称<strong>含气骨</strong>，如上颌骨。</li>
</ul>
<h3 id="骨的构造"><a href="#骨的构造" class="headerlink" title="骨的构造"></a>骨的构造</h3><img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E9%AA%A8%E5%AD%A6/02.png" class title="02.png">
<ul>
<li><strong>骨质</strong>：由骨组织构成，分<strong>密质</strong>和<strong>松质</strong>。骨密质，质地致密，耐压性强，分布于骨的表面。骨松质，呈海绵状，由相互交织的骨小梁排列而成，配布于骨的内部，骨小梁按照骨所承受的压力和张力的方向排列，因而骨能承受较大的重量。颅盖骨表层为密质，分别称外板和内板，外板厚而坚韧，富有弹性，内板薄而松脆，故颅骨骨折多见于内板。内、外板之间为骨松质，称板障，有板障静脉经过。骨干与骺相邻的部分称干骺端，幼年时保留一片软骨，称<strong>骺软骨</strong>（<strong>骺板</strong>），骺软骨细胞不断分裂繁殖和骨化，使骨不断加长。成年后，骺软骨骨化，骨干与骺融为一体，其间遗留一<strong>骺线</strong>。</li>
<li><strong>骨髓</strong>：充填于骨髓腔和骨松质间隙内。胎儿和幼儿的骨髓有<strong>造血功能</strong>，内含不同发育阶段的红细胞和某些白细胞，呈红色，称<strong>红骨髓</strong>。5岁以后，长骨骨干内的红骨髓逐渐被脂肪组织代替，呈黄色，称<strong>黄骨髓</strong>，失去造血能力。但在慢性失血过多或重度贫血时，黄骨髓能转化为红骨髓，恢复造血功能。在椎骨、髂骨、肋骨、胸骨及肱骨和股骨等长骨的骺内终生都是红骨髓，因此，临床常选髂前上嵴或髂后上嵴等处进行骨髓穿刺，检查骨髓象。</li>
<li><strong>骨膜：</strong>除关节面的部分外，新鲜骨的表面都覆有骨膜。骨膜由纤维结缔组织构成，<strong>含有丰富的血管和神经</strong>，对骨的营养、再生和感觉有重要作用。骨膜可分为内、外两层，外层致密有许多胶原纤维束穿入骨质，使之固着于骨面。内层疏松有<strong>成骨细胞</strong>和<strong>破骨细胞</strong>，具有产生新骨质、破坏原骨质和重塑骨的功能，幼年期骨细胞功能活跃，促进骨的生长；成年时处于相对静止状态。但当骨发生损伤，如骨折时，骨膜又重新启动成骨功能，促进骨折的修复愈合。如骨膜剥离太多或损伤过大，则骨折愈合困难。<br>衬在骨髓腔内面和骨松质间隙内的骨膜称骨内膜, 是一层菲薄的结缔组织，也含有成骨细胞和破骨细胞，有造骨和破骨的功能。</li>
<li><strong>骨的血管：</strong>长骨的动脉包括<strong>滋养动脉</strong>、<strong>干骺端动脉</strong>、<strong>骺动脉</strong>及<strong>骨膜动脉</strong>。滋养动脉是长骨的主要动脉，一般有1～2支，经骨干的<strong>滋养孔</strong>进入骨髓腔，分升支和降支达骨端，分支分布到骨干骨密质的内层、骨髓和干骺端，在成年人可与干骺端动脉及骺动脉的分支吻合。干骺端动脉和骺动脉均发自邻近动脉，从骺软骨附近穿入骨质。上述各动脉均有静脉伴行。不规则骨、扁骨和短骨的动脉来自骨膜动脉或滋养动脉。</li>
<li><strong>骨的神经：</strong>伴滋养血管进入骨内，分布到血管周围间隙中，主要为内脏传出纤维，分布到血管壁；躯体传入纤维则多分布于骨膜。骨膜对张力或撕扯的刺激较为敏感，故骨脓肿和骨折常引起剧痛。</li>
</ul>
<h3 id="骨的生长"><a href="#骨的生长" class="headerlink" title="骨的生长"></a>骨的生长</h3><p>骨根据发生，人体成骨的方式有两种，分为膜化骨和软骨化骨。</p>
<ul>
<li><strong>膜化骨</strong>：在结缔组织膜内出现骨化中心，成骨细胞不断分泌有机物胶原纤维和粘蛋白，同时无机盐不断沉积钙化，从而形成骨质。如颅骨中的一些扁形骨。</li>
<li><strong>软骨化骨</strong>：人体的长骨、短骨和一些不规则骨，都属于软骨内成骨。在透明软骨的基础上逐渐骨化而成。</li>
</ul>
<p>骨的生长是在膜内成骨和软骨内成骨的基础上进行的，使骨<strong>由小到大</strong>、<strong>由细变粗</strong>逐渐长成。现以长骨为例作以简要的说明：长骨的生长，包括<strong>长长</strong>和<strong>长粗</strong>两个过程。长粗是以膜内成骨的方式进行的，骨外膜内层的<strong>成骨细胞</strong>不断产生骨胶原，同时无机盐，不断沉积并钙化，<strong>使骨干不断增粗</strong>。而骨内膜中的<strong>破骨细胞则使骨髓腔扩大</strong>，使骨体增粗且保持一定的厚度。长骨的长长则依靠软骨内成骨来实现。<strong>骺软骨</strong>不断的产生又不断的骨化，<strong>使骨体不断的增长</strong>，当骺软骨完全骨化后，骨的长长则停止。</p>
<h3 id="体表骨性标志"><a href="#体表骨性标志" class="headerlink" title="体表骨性标志"></a>体表骨性标志</h3><ul>
<li>锁骨全程、肩峰、肱骨内外上髁、尺骨鹰嘴、桡骨茎突、尺骨茎突、豌豆骨、掌骨头、指骨滑车、指骨粗隆</li>
<li>髂嵴、髂前上棘、坐骨结节、大转子、股骨内外侧髁 、胫骨内外侧髁、髌骨、胫骨粗隆、腓骨头、内踝、外踝</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E9%AA%A8%E5%AD%A6/23.png" class title="23.png">
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E9%AA%A8%E5%AD%A6/24.png" class title="24.png">
<h2 id="躯干骨"><a href="#躯干骨" class="headerlink" title="躯干骨"></a>躯干骨</h2><p>人体的中轴骨骼包括躯干骨和颅。躯干骨包括<strong>1块胸骨、1块骶骨、1块尾骨、24块椎骨</strong>和<strong>12对肋骨</strong>。它们分别参与<strong>脊柱</strong>、<strong>骨性胸廓</strong>和<strong>骨盆</strong>的构成。</p>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E9%AA%A8%E5%AD%A6/03.png" class title="03.png">
<h3 id="胸骨"><a href="#胸骨" class="headerlink" title="胸骨"></a>胸骨</h3><p>胸骨位于胸前壁正中，前凸后凹，可分<strong>胸骨柄</strong>、<strong>胸骨体</strong>和<strong>剑突</strong>三部分。</p>
<ul>
<li>胸骨柄上宽下窄，上缘中分为<strong>颈静脉切迹</strong>，两侧有<strong>锁切迹</strong>与锁骨相连结。柄外侧缘上分接第1肋。柄与体连接处微向前突，称<strong>胸骨角</strong>，可在体表扪及，两侧的<strong>肋切迹</strong>与第2肋软骨相连接，是<strong>计数肋的重要标志</strong>。胸骨角向后平对第4胸椎体下缘。</li>
<li>胸骨体呈长方形，外侧缘接第2～7肋软骨。</li>
<li>剑突薄而细长，形状变化较大，下端游离。</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E9%AA%A8%E5%AD%A6/04.png" class title="04.png">
<h3 id="椎骨"><a href="#椎骨" class="headerlink" title="椎骨"></a>椎骨</h3><p>幼年时椎骨为32或33块，分为<strong>颈椎</strong>7块，<strong>胸椎1</strong>2块，<strong>腰椎</strong>5块，<strong>骶椎</strong>5块，<strong>尾椎</strong>3～4块。成年后5块骶椎融合成骶骨，3～4块尾椎长合成尾骨，共计26块。</p>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E9%AA%A8%E5%AD%A6/05.png" class title="05.png">
<p><strong>椎骨的一般形态</strong></p>
<ul>
<li>椎骨由前方短圆柱形的<strong>椎体</strong>和后方板状的<strong>椎弓</strong>组成。</li>
<li><strong>椎体</strong>是椎骨负重的主要部分，内部充满骨松质，表面的骨密质较薄，上下面皆粗糙，借椎间纤维软骨与邻近椎骨相接。椎体后面微凹陷，与椎弓共同围成<strong>椎孔</strong>。各椎孔贯通，构成<strong>椎管</strong>容纳脊髓（第一腰椎以上）。</li>
<li><strong>椎弓</strong>是弓形骨板，连接椎体的缩窄部分，称<strong>椎弓根</strong>，根的上、下缘各有一切迹，分别成为椎上、下切迹。相邻椎骨的椎上、下切迹共同围成椎间孔，有脊神经和血管通过。两侧椎弓根向后内扩展变宽的部分，称椎弓板，两侧在中线会合。<br>由椎弓发出7个突起：<ul>
<li><strong>棘突1个(ji,第四声)</strong>，由椎弓后面正中伸向后方或后下方，尖端可在体表扪到。</li>
<li><strong>横突1对</strong>，从椎弓根与椎弓板移行处伸向两侧。棘突和横突都是肌和韧带的附着处。</li>
<li><strong>关节突2对</strong>，在椎弓根与椎弓板结合处分别向上、下方突起，即<strong>上关节突</strong>和<strong>下关节突</strong>，相邻关节突构成关节突关节。</li>
</ul>
</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E9%AA%A8%E5%AD%A6/06.png" class title="06.png">
<p><strong>各部椎骨的主要特征</strong></p>
<ul>
<li><strong>颈椎</strong>：<br>共7块，椎体较小，横断面呈椭圆形。横突有孔，称<strong>横突孔</strong>，有<strong>椎动脉</strong>和<strong>椎静脉</strong>通过。<br>第6颈椎横突末端前方的结节特别隆起，称<strong>颈动脉结节</strong>，颈总动脉经其前方。当头部出血时，可用手指将颈总动脉压于此结节，进行暂时止血。<br>第2～6颈椎的棘突较短，末端分叉。上、下关节突的关节面几呈水平位。<br>第3～7颈椎体上面侧缘向上突起称椎体钩。椎体钩与上位椎体下面的两侧唇缘相接，形成钩椎关节，又称Luschka关节。如锥体钩过度增生肥大，可使椎间孔狭窄，压迫脊神经，产生颈椎病的症状和体征。颈椎椎孔较大，呈三角形。</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E9%AA%A8%E5%AD%A6/07.png" class title="07.png">
<ul>
<li><p>第1颈椎又名<strong>寰椎</strong>(huan)，呈环状，无椎体、棘突和关节突，由前弓、后弓及侧块组成。前弓较短，后面正中有齿关节凹（齿突凹），与枢椎的齿突相关节。侧块连接前后两弓，上面各有一椭圆形关节面，与枕髁相关节；下面有圆形关节面与枢椎上关节面相关节。后弓较长，上面有横行的椎动脉沟，有椎动脉通过。</p>
<p>  第2颈椎又名<strong>枢椎</strong>(shu)，特点是椎体向上伸出<strong>齿突</strong>，与寰椎齿突凹相关节。齿突原为寰椎椎体，发育过程中脱离寰椎而与枢椎体融合。</p>
<p>  第7颈椎又名<strong>隆椎</strong>，棘突特长，末端不分叉，活体易于触及，常作为<strong>计数椎骨序数</strong>的标志。方法：患者低头，肩峰为线的脊椎凸起，左右转头时，不动上方微动的就是第七颈椎的棘突。</p>
</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E9%AA%A8%E5%AD%A6/08.png" class title="08.png">
<ul>
<li><strong>胸椎：</strong><br>椎体从上向下逐渐增大，横断面呈心形，其两侧面上、下缘分别由上、下<strong>肋凹</strong>，与肋头相关节（肋小头关节）。横突末端前面，有<strong>横突肋凹</strong>与肋结节相关节（肋横突关节）。第1胸椎和第9以下各胸椎的肋凹不典型。关节突的关节面几乎呈冠状位，上关节突的关节面朝向后，下关节突的关节面则朝向前。棘突较长，<strong>向后下方倾斜</strong>，呈叠瓦状排列。</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E9%AA%A8%E5%AD%A6/09.png" class title="09.png">
<ul>
<li><strong>腰椎：</strong><br><strong>椎体粗壮</strong>，横断面呈肾形。椎孔呈卵圆形或三角形。上、下关节突粗大，关节面几呈矢状位，<strong>棘突</strong>宽而短，呈板状，<strong>水平伸向后方</strong>。各棘突间的<strong>间隙较宽</strong>，临床上可于3-4腰椎或者4-5腰椎间作腰椎穿刺术（水平进针）。计数棘突的方法：髂嵴最高点的连线为第四腰椎的棘突。</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E9%AA%A8%E5%AD%A6/10.png" class title="10.png">
<ul>
<li><strong>骶骨：</strong><br>由<strong>5块骶(di)椎融合</strong>而成，呈三角形，上宽下尖，盆面（前面）凹陷，上缘中分向前隆凸，称<strong>骶骨岬</strong>。盆面中部有四条横线，是椎体融合的痕迹。横线两端有<strong>4对骶前孔</strong>。<br><strong>背面粗糙隆凸</strong>，正中线上有<strong>骶正中嵴</strong>，嵴外侧有<strong>4对骶后孔</strong>。骶前、后孔均与骶管相通，分别有骶神经前、后支通过。骶管由骶椎的椎孔长合而成，它<strong>上通椎管</strong>，下端的裂孔称<strong>骶管裂孔</strong>，裂孔两侧有向下突出的骶角，骶管麻醉常以<strong>骶骨角</strong>作为标志。骶骨外侧部上宽下窄，上份有<strong>耳状面</strong>与髂(qia)骨的耳状面构成<strong>骶髂关节</strong>，耳状面后方骨面凹凸不平。</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E9%AA%A8%E5%AD%A6/11.png" class title="11.png">
<ul>
<li><strong>尾骨：</strong><br>由3～4块退化的尾椎长合而成。上接骶骨，下端游离为尾骨尖。</li>
</ul>
<h3 id="肋骨"><a href="#肋骨" class="headerlink" title="肋骨"></a>肋骨</h3><ul>
<li>肋由肋骨和肋软骨组成，共12对；</li>
<li>第1～7对肋前端直接与胸骨连接，称<strong>真肋</strong>，其中第1肋与胸骨柄间为软骨结合，第2肋至第7肋与胸骨构成微动的胸肋关节。</li>
<li>第8~10对肋不直接与胸骨相连称<strong>假肋</strong>；其中第8～10对肋前端与上位肋借肋软骨构成<strong>软骨间关节</strong>，形成<strong>肋弓。</strong></li>
<li>第11～12对肋前端游离于腹壁肌层中，称<strong>浮肋</strong>。肋的后端与胸椎构成肋椎关节。</li>
<li><strong>肋的连结</strong>：包括软骨结合、关节连结、软骨连结</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E9%AA%A8%E5%AD%A6/12.png" class title="12.png">
<hr>
<h2 id="上肢骨"><a href="#上肢骨" class="headerlink" title="上肢骨"></a>上肢骨</h2><p><strong>附肢骨</strong>包括上肢骨和下肢骨。上、下肢骨均由<strong>肢带骨</strong>和<strong>自由肢骨</strong>组成。上、下肢骨的数目和排列方式基本相同。由于人体直立，上肢成为灵活的劳动器官，下肢起着支持和移位的作用。因而，上肢骨纤细轻巧，下肢骨粗大坚固。</p>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E9%AA%A8%E5%AD%A6/13.png" class title="13.png">
<h3 id="锁骨"><a href="#锁骨" class="headerlink" title="锁骨"></a>锁骨</h3><ul>
<li>锁骨呈S形弯曲，架于胸廓前上方。内侧端粗大，为<strong>胸骨端</strong>，有关节面与胸骨柄相关节。外侧端扁平，为<strong>肩峰端</strong>，有小关节面与肩胛骨肩峰相关节。内侧2／3凸向前，呈三棱棒形；外侧1／3凸向后，呈扁平形，二者之间交界处较薄弱，<strong>锁骨骨折</strong>多发生在此处（下有锁骨下动脉）。锁骨全长可在体表扪到。锁骨将肩胛骨支撑于胸廓之外，以保证上肢的灵活运动。</li>
</ul>
<h3 id="肩胛骨"><a href="#肩胛骨" class="headerlink" title="肩胛骨"></a>肩胛骨</h3><ul>
<li>肩胛骨为<strong>三角形扁骨</strong>，贴于胸廓后外面，介于第2到第7肋骨之间。可分二面、三缘和三个角。腹侧面或肋面与胸廓相对，为一大的浅窝，称<strong>肩胛下窝</strong>。背侧面有一横嵴，称<strong>肩胛冈</strong>。冈上、下方的浅窝，分别称<strong>冈上窝</strong>和<strong>冈下窝</strong>。肩胛冈向外侧延伸的扁平突起，称<strong>肩峰</strong>，与锁骨的肩峰端相接。上缘短而薄，外侧分有<strong>肩胛切迹</strong>，切迹外侧有向前的指状突起称<strong>喙突(hui)</strong>。内侧缘薄而锐利，临近脊柱故又称脊柱缘。外侧缘肥厚邻近腋窝，又称腋缘。<strong>上角</strong>为上缘与脊柱缘会合处，平对第2肋。<strong>下角</strong>为脊柱缘与腋缘会合处，平对第7肋或第7肋间隙，为计数肋的标志。<strong>外侧角</strong>为腋缘与上缘会合处，最肥厚，为朝向外侧方的梨形浅窝，称<strong>关节盂(yu)</strong>，<strong>与肱骨头相关节</strong>。盂上 、下方各有一粗糙隆起，分别称<strong>盂上结节</strong>和<strong>盂下结节</strong>。</li>
<li>肩胛冈、肩峰、肩胛骨下角、内侧缘及喙突都可在体表扪到。</li>
<li>计数肋的标志：肩胛上角对应第二肋，肩胛下角对应第七肋。</li>
<li>计数棘突的标志：两侧肩胛冈内侧段的连线为第三胸椎的棘突；肩胛下角连线为第八胸椎棘突。</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E9%AA%A8%E5%AD%A6/14.png" class title="14.png">
<h3 id="肱骨"><a href="#肱骨" class="headerlink" title="肱骨"></a>肱骨</h3><ul>
<li>肱骨(gong)分一体及上、下两端。上端有朝向上后内方呈半球形的<strong>肱骨头</strong>，与肩胛骨的关节盂相关节。头周围的环状浅沟，称<strong>解剖颈</strong>。肱骨头的外侧和前方分别有隆起的<strong>大结节</strong>和<strong>小结节</strong>，它们向下各延伸一嵴，称大结节嵴和小结节嵴。两结节间有一纵沟，称<strong>结节间沟</strong>。上端与体交界处稍细，称<strong>外科颈</strong>，较易发生骨折。</li>
<li>肱骨体上半部呈圆柱形，下半部呈三棱柱形。中部外侧面有粗糙的<strong>三角肌粗隆</strong>，为三角肌附着处。后面中部，有一自内上斜向外下的浅沟，称<strong>桡神经沟(rao)</strong>。桡神经和肱深动脉沿此沟经过，肱骨中部骨折可能伤及桡神经。内侧缘近中点处有开口向上的滋养孔。</li>
<li>下端较扁，外侧部前面有半球状的<strong>肱骨小头</strong>，与桡骨相关节；内侧部有滑车状的<strong>肱骨滑车</strong>，与尺骨形成关节。滑车前面上方有一窝，称<strong>冠突窝</strong>；肱骨小头前面上方有一窝，称<strong>桡窝</strong>；滑车后面上方有一窝，称<strong>鹰嘴窝</strong>，伸肘时容纳尺骨鹰嘴 。小头外侧和滑车内侧各有一突起，分别称<strong>外上髁</strong>和<strong>内上髁</strong>。内上髁后方有一浅沟，称<strong>尺神经沟</strong>，尺神经由此经过。下端与体交界处，即肱骨内、外上髁稍上方，骨质较薄弱，受暴力可发生肱骨髁上骨折。</li>
<li>肱骨大结节和内、外上髁都可在体表扪到。</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E9%AA%A8%E5%AD%A6/15.png" class title="15.png">
<h3 id="桡骨"><a href="#桡骨" class="headerlink" title="桡骨"></a>桡骨</h3><p>桡骨(rao)位于前臂外侧部，分一体两端。上端膨大称<strong>桡骨头</strong>，头上面有<strong>关节凹</strong>与肱骨小头相关节；周围的<strong>环状关节面</strong>与尺骨相关节；头下方略细，称<strong>桡骨颈</strong>。颈的内下方有一突起称<strong>桡骨粗隆</strong>。桡骨体呈三棱柱形，内侧缘为薄锐的骨间缘。下端前凹后凸，外侧向下突出，为<strong>桡骨茎突</strong>。下端内面有关节面，称<strong>尺切迹</strong>，与尺骨头相关节，下面有腕关节面与腕骨相关节。</p>
<p>桡骨茎突和桡骨头在体表可扪到。</p>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E9%AA%A8%E5%AD%A6/16.png" class title="16.png">
<h3 id="尺骨"><a href="#尺骨" class="headerlink" title="尺骨"></a>尺骨</h3><p>尺骨居前臂内侧部，分一体两端。上端粗大，前面有一半圆形深凹，称<strong>滑车切迹</strong>，与肱骨滑车相关节。切迹后上方的突起称<strong>鹰嘴</strong>，前下方的突起称冠突。冠突外侧面有<strong>桡切迹</strong>，与桡骨头相关节；冠突下方的粗糙隆起，称<strong>尺骨粗隆</strong>。尺骨体上段粗，下段细，外缘锐利，为骨间缘，与桡骨的骨间缘相对。下端为<strong>尺骨头</strong>，其前、外、后有环状关节面与桡骨的尺切迹相关节，下面光滑借三角形的关节盘与腕骨隔开。头后内侧的锥状突起，称<strong>尺骨茎突</strong>。在正常情况下，尺骨茎突比桡骨茎突约高 1 cm。</p>
<p>鹰嘴、后缘全长、尺骨头和茎突都可在体表扪到。</p>
<h3 id="手骨"><a href="#手骨" class="headerlink" title="手骨"></a>手骨</h3><p>手骨包括<strong>腕骨</strong>、<strong>掌骨</strong>和<strong>指骨</strong>。</p>
<ul>
<li><strong>腕骨</strong>：8块。排成近、远二排。近侧排由桡侧向尺侧为：<strong>手舟骨</strong>、<strong>月骨</strong>、<strong>三角骨</strong>和<strong>豌豆骨</strong>；远侧列为：<strong>大多角骨</strong>、<strong>小多角骨</strong>、<strong>头状骨</strong>和<strong>钩骨</strong>。8块腕骨连接形成一掌面凹陷的<strong>腕骨沟</strong>。各骨相邻的关节面，形成<strong>腕骨间关节</strong>。手舟骨、月骨和三角骨近端形成的椭圆形关节面，与桡骨腕关节面及尺骨头下方的关节盘构成<strong>桡腕关节</strong>。</li>
<li><strong>掌骨</strong>：5块。由桡侧向尺侧，依次为第1～5掌骨。掌骨近端为<strong>底</strong>，接腕骨；<strong>远端为头，</strong>接指骨，中间部为<strong>体</strong>。第1掌骨短而粗，其底有鞍状关节面，与大多角骨的鞍状关节面相关节。</li>
<li><strong>指骨</strong>：共14块，属长骨。<strong>拇指</strong>有2节，分别为<strong>近节</strong>和<strong>远节</strong>指骨，其余各指为3节，分别为<strong>近节</strong>指骨、<strong>中节</strong>指骨和<strong>远节</strong>指骨。每节指骨的近端为底，中间部为体，<strong>远端为滑车</strong>。远节指骨远端掌面粗糙，称远节<strong>指骨粗隆</strong>。</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E9%AA%A8%E5%AD%A6/17.png" class title="17.png">
<hr>
<h2 id="下肢骨"><a href="#下肢骨" class="headerlink" title="下肢骨"></a>下肢骨</h2><img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E9%AA%A8%E5%AD%A6/18.png" class title="18.png">
<h3 id="髋骨"><a href="#髋骨" class="headerlink" title="髋骨"></a>髋骨</h3><p>髋骨(kuan)是不规则骨，上部扁阔，中部窄厚，有朝向下外的深窝，称髋臼；下部有一大孔，称闭孔。左右髋骨与骶、尾骨围成<strong>骨盆</strong>。髋骨由髂(qia)骨、耻骨和坐骨组成，三骨会合于髋臼，16岁左右完全融合。</p>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E9%AA%A8%E5%AD%A6/19.png" class title="19.png">
<ul>
<li><strong>髂骨：</strong>髋骨构成髋骨上部，分为肥厚的髂骨体和扁阔的髂骨翼。髂骨体构成髋臼的上2／5，翼上缘肥厚，形成弓形的<strong>髂嵴</strong>。髂嵴前端为<strong>髂前上棘</strong>，后端为髂后上棘。髂前上棘后方5～7cm处，髂嵴外唇向外突起，称<strong>髂结节</strong>，它们都是重要的体表标志。在髂前、后上棘的下方各有一薄锐突起，分别称髂前下棘和髂后下棘。髂后下棘下方有深陷的坐骨大切迹。髂骨翼内面的浅窝称髂窝，髂窝下界有圆钝骨嵴，称弓状线。髂骨翼后下方粗糙的耳状关节面称<strong>耳状面</strong>，与骶骨的耳状面相关节。耳状面后上方有<strong>髂粗隆</strong>，与骶骨间借韧带相连结。髂骨翼外面称为臀面，有臀肌附着。</li>
<li><strong>坐骨：</strong>坐骨构成髋骨下部，分坐骨体和坐骨支。体组成髋臼的后下2／5，后缘有尖形的<strong>坐骨棘</strong>，棘下方有<strong>坐骨小切迹</strong>。坐骨棘与髂后下棘之间为<strong>坐骨大切迹</strong>。坐骨体下后部向前、上、内延伸为较细的坐骨支，其末端与耻骨下支结合。坐骨体与坐骨支移行处的后部是粗糙的隆起，为<strong>坐骨结节</strong>，是坐骨最低部，可在体表扪到。</li>
<li><strong>耻骨：</strong>耻骨构成髋骨前下部，分体和上、下二支。体组成髋臼前下1／5。与髂骨体的结合处上缘骨面粗糙隆起，称<strong>髂耻隆起</strong>，由此向前内伸出耻骨上支，其末端急转向下，成为耻骨下支。耻骨上支上面有一条锐嵴，称<strong>耻骨梳</strong>，向后移行于<strong>弓状线</strong>(区分大骨盆和 小骨盆的分界线)，向前终于耻骨结节，是重要体表标志。耻骨结节到中线的粗钝上缘为耻骨嵴，也可在体表扪到。耻骨上、下支相互移行处内侧的椭圆形粗糙面，称耻骨联合面，两侧联合面借软骨相接，构成耻骨联合。耻骨下支伸向后下外，与坐骨支结合，这样，耻骨与坐骨共同围成闭孔。</li>
<li><strong>髋臼</strong>由髂、坐、耻三骨的体合成。窝内半月形的关节面称月状面。窝的中央未形成关节面的部分，称髋臼窝。髋臼边缘下部的缺口称髋臼切迹。</li>
</ul>
<h3 id="股骨"><a href="#股骨" class="headerlink" title="股骨"></a>股骨</h3><ul>
<li>股骨是<strong>人体最长</strong>最结实的长骨，长度约为体高的1／4，分一体两端。上端有朝向内上前的<strong>股骨头</strong>，与髋臼相关节。头中央稍下有小的股骨头凹。头下外侧的狭细部称<strong>股骨颈</strong>。颈与体连接处上外侧的方形隆起，称<strong>大转子</strong>；内下方的隆起，称<strong>小转子</strong>，有肌肉附着。大、小转子之间，前面有<strong>转子间线</strong>，后面有<strong>转子间嵴</strong>。大转于是重要的体表标志，可在体表扪到。</li>
<li>股骨体略弓向前，上段呈圆柱形，中段呈三棱柱形，下段前后略扁。体后面有纵行骨嵴，为<strong>股骨粗线</strong>。此线上端分叉，向上外延续于粗糙的<strong>臀肌粗隆</strong>，向上内侧延续为耻骨肌线。粗线下端也分为内、外两线，二线间的骨面为腘面。粗线中点附近，有口朝下的滋养孔。</li>
<li>下端有两个向后突出的膨大，为<strong>内侧髁</strong>和<strong>外侧髁。</strong>内、外侧髁的前面、下面和后面都是光滑的关节面。两髁前方的关节面彼此相连，形成<strong>髌面</strong>，与髌骨相 接。两髁后分之间的深窝称<strong>髁间窝</strong>。两髁侧面最突起处，分别为内上髁和外上髁。内上髁上方的小突起，称收肌结节。它们都是在体表可扪到的重要标志。</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E9%AA%A8%E5%AD%A6/20.png" class title="20.png">
<h3 id="髌骨"><a href="#髌骨" class="headerlink" title="髌骨"></a>髌骨</h3><ul>
<li>髌骨是人体最大的籽骨，位于股骨下端前面，在股四头肌腱内，上宽下尖，前面粗糙，后面为关节面，与股骨髌面相关节。髌骨可在体表扪到。</li>
</ul>
<h3 id="胫骨"><a href="#胫骨" class="headerlink" title="胫骨"></a>胫骨</h3><ul>
<li>胫骨位于小腿内侧部，是粗大的长骨。上端膨大，向两侧突出，形成<strong>内侧髁</strong>和<strong>外侧髁</strong>。二髁上面各有上关节面，与股骨髁相关节。两上关节面之间的粗糙小隆起，称<strong>髁间隆起</strong>。外侧髁后下方有腓关节面与腓骨头相关节。上端前面的隆起称<strong>胫骨粗隆</strong>。内、外侧髁和胫骨粗隆于体表均可扪到。</li>
<li>胫骨体呈三棱柱形，较锐的<strong>前缘</strong>和平滑的内侧面直接位于皮下，外侧缘有小腿骨间膜附着，称骨间缘。后面上分有斜向下内的比目鱼肌线。体后面上、中 1/3交界处附近，有向上开口的滋养孔。</li>
<li>胫骨下端稍膨大，其内下方有一突起，称<strong>内踝</strong>。下端的下面和内踝的外侧面有<strong>下关节面</strong>与距骨相关节。下端的外侧面有<strong>腓切迹</strong>与腓骨相接。内踝可在体表扪到。</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E9%AA%A8%E5%AD%A6/21.png" class title="21.png">
<h3 id="腓骨"><a href="#腓骨" class="headerlink" title="腓骨"></a>腓骨</h3><ul>
<li>腓骨位于胫骨外后方，为细长的长骨。上端稍膨大，称<strong>腓骨头</strong>，有腓骨头关节面与胫骨相关节。头下方缩窄，称<strong>腓骨颈</strong>。体内侧缘锐利，称骨间缘，有小腿骨间膜附着，体内侧近中点处，有向上开口的滋养孔。下端膨大，形成<strong>外踝</strong>。其内侧有<strong>外踝窝</strong>，与距骨相关节。腓骨头和外踝都可在体表扪到。</li>
</ul>
<h3 id="足骨"><a href="#足骨" class="headerlink" title="足骨"></a>足骨</h3><p>足骨包括<strong>跗骨</strong>、<strong>跖骨(zhi,第二音)</strong>和<strong>趾骨</strong>。</p>
<ul>
<li><strong>跗骨</strong>：7块，属短骨。分前、中、后三列。后列包括上方的<strong>距骨</strong>和下方的<strong>跟骨</strong>；中列为位于距骨前方的<strong>足舟骨</strong>；前列为内侧<strong>楔骨</strong>、中间楔骨、外侧楔骨，及跟骨前方的<strong>骰骨</strong>(tou)。跗骨几乎占据全足的一半，与下肢支持和<strong>负重功能</strong>相适应，距骨上面有<strong>前宽后窄</strong>的关节面，称<strong>距骨滑车</strong>，与<strong>内、外踝</strong>和<strong>胫骨的下关节面</strong>相关节。距骨下方与跟骨相关节。跟骨后端隆突，为<strong>跟骨结节</strong>。距骨前接足舟骨，足舟骨内下方的隆起称<strong>舟骨粗隆</strong>，是重要体表标志。足舟骨前方与3块楔骨相关节，外侧的骰骨与跟骨相接。</li>
<li><strong>跖骨</strong>：5块，只内侧向外侧依次为第1～5跖骨，形状和排列大致与掌骨相当，但比掌骨粗大。跖骨近端为底，与跗骨相接，中间为体，远端称头 ，与近节趾骨相接。第5跖骨底向后突出，称第5跖骨粗隆，在体表可扪到。</li>
<li><strong>趾骨</strong>：共14块。母趾为2节，其余各趾为3节。形态和命名与指骨相同。母趾骨粗壮，其余趾骨细小，第5趾的远节趾骨甚小，往往与中节趾骨长合。</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E9%AA%A8%E5%AD%A6/22.png" class title="22.png">
]]></content>
      <categories>
        <category>biomechanics</category>
      </categories>
      <tags>
        <tag>人体解剖学</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础 3 - 排序 Sorting</title>
    <url>/2022/05/01/1-Course/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/03-%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<img src="/2022/05/01/1-Course/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/03-%E6%8E%92%E5%BA%8F/0.png" class>
<span id="more"></span>
<h2 id="排序算法对比"><a href="#排序算法对比" class="headerlink" title="排序算法对比"></a>排序算法对比</h2><img src="/2022/05/01/1-Course/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/03-%E6%8E%92%E5%BA%8F/1.png" class>
<hr>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><ul>
<li>每次将未排序序列的最大元素放入已排序序列的开头</li>
<li>in-place算法，时间复杂度O(n^2)，排序算法不稳定</li>
</ul>
<img src="/2022/05/01/1-Course/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/03-%E6%8E%92%E5%BA%8F/2.gif" class>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(A)-<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        m = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            <span class="keyword">if</span> A[j] &gt; A[m]:</span><br><span class="line">                m = j</span><br><span class="line">        A[i], A[m] = A[m], A[i]</span><br></pre></td></tr></table></figure>
<h3 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h3><ul>
<li>每次将一个<strong>待排序元素</strong>插入到<strong>已排序序列</strong>中的合适位置</li>
<li>in-place算法，时间复杂度O(n^2)，排序算法稳定</li>
</ul>
<img src="/2022/05/01/1-Course/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/03-%E6%8E%92%E5%BA%8F/3.gif" class>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertion_sort</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(A)):</span><br><span class="line">        j = i</span><br><span class="line">        <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> A[j] &lt; A[j-<span class="number">1</span>]:</span><br><span class="line">            A[j], A[j-<span class="number">1</span>] = A[j-<span class="number">1</span>], A[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h3><ul>
<li>每次交换相邻的两个元素，直至没有需要交换的元素</li>
<li>in-place算法，时间复杂度O(n^2)，排序算法稳定</li>
</ul>
<img src="/2022/05/01/1-Course/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/03-%E6%8E%92%E5%BA%8F/4.gif" class>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(A)-<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        exchange = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, i):</span><br><span class="line">            <span class="keyword">if</span> A[j] &gt; A[j+<span class="number">1</span>]:</span><br><span class="line">                A[j], A[j+<span class="number">1</span>] = A[j+<span class="number">1</span>], A[j]</span><br><span class="line">                exchange = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> exchange:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<h3 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h3><ul>
<li>把一个序列分成两半，先分别对每个子序列排序，然后再将两个子序列合并</li>
<li>一般采用递归法，时间复杂度为O(<em>nlogn</em>)</li>
</ul>
<img src="/2022/05/01/1-Course/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/03-%E6%8E%92%E5%BA%8F/5.gif" class>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span>(<span class="params">A, a=<span class="number">0</span>, b=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> b <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        b = <span class="built_in">len</span>(A)</span><br><span class="line">    <span class="keyword">if</span> <span class="number">1</span> &lt; b - a:</span><br><span class="line">        c = (a + b + <span class="number">1</span>)//<span class="number">2</span></span><br><span class="line">        merge_sort(A, a, c)</span><br><span class="line">        merge_sort(A, c, b)</span><br><span class="line">        L, R = A[a:c], A[c:b]</span><br><span class="line">        i, j, k = <span class="number">0</span>, <span class="number">0</span>, a</span><br><span class="line">        <span class="keyword">while</span> k &lt; b:</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= <span class="built_in">len</span>(R)) <span class="keyword">or</span> (i &lt; <span class="built_in">len</span>(L) <span class="keyword">and</span> L[i] &lt; R[j]):</span><br><span class="line">                A[k] = L[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                A[k] = R[j]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="基数排序（Radix-Sort）"><a href="#基数排序（Radix-Sort）" class="headerlink" title="基数排序（Radix Sort）"></a>基数排序（Radix Sort）</h3><ul>
<li>在Direct Access Array Sort、Counting Sort、Tuple Sort基础上演化出来的排序算法，将每个整数分解为n的幂次，根据幂级顺序进行元组排序，可以做到线性时间内完成排序</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">counting_sort</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="string">&quot;Sort A assuming items non-negative keys&quot;</span></span><br><span class="line">    u = <span class="number">1</span> + <span class="built_in">max</span>([x.key <span class="keyword">for</span> x <span class="keyword">in</span> A])</span><br><span class="line">    D = [<span class="number">0</span>] * u</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> A:</span><br><span class="line">        D[x.key] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, u):</span><br><span class="line">        D[k] += D[k-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">list</span>(<span class="built_in">reversed</span>(A)):</span><br><span class="line">        A[D[x.key] - <span class="number">1</span>] = x</span><br><span class="line">        D[x.key] -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">radix_sort</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="string">&quot;Sort A assuming items have non-negative keys&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(A)</span><br><span class="line">    u = <span class="number">1</span> + <span class="built_in">max</span>([x <span class="keyword">for</span> x <span class="keyword">in</span> A])</span><br><span class="line">    c = <span class="number">1</span> + (u.bit_length()) // n.bit_length()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Obj</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    D = [Obj() <span class="keyword">for</span> a <span class="keyword">in</span> A]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        D[i].digits = []</span><br><span class="line">        D[i].item = A[i]</span><br><span class="line">        high = A[i]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(c):</span><br><span class="line">            high, low = <span class="built_in">divmod</span>(high, n)</span><br><span class="line">            D[i].digits.append(low)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(c):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            D[j].key = D[j].digits[i]</span><br><span class="line">        counting_sort(D)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        A[i] = D[i].item</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>course</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>COSMED使用基础教程</title>
    <url>/2022/05/10/4-Tutorials/Hardware/COSMED%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<img src="/2022/05/10/4-Tutorials/Hardware/COSMED%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/1.png" class>
<span id="more"></span>
<h2 id="COSMED硬件接口"><a href="#COSMED硬件接口" class="headerlink" title="COSMED硬件接口"></a>COSMED硬件接口</h2><img src="/2022/05/10/4-Tutorials/Hardware/COSMED%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/2.png" class title="Untitled">
<ul>
<li>A：气体采样管接口</li>
<li>B：流量传感器信号接口</li>
<li>C：SD卡</li>
<li>D：可更换电池</li>
<li>E：供电接口（可以与电池并存，优先使用此接口供电）</li>
<li>F：有线串口通信接口（用于连接电脑，每个月需连接一次以激活上位机软件）</li>
<li>G：氧气传感器，非特殊情况不建议打开该接口（氧传感器需每8个月更换一次）</li>
</ul>
<h2 id="COSMED主机操作"><a href="#COSMED主机操作" class="headerlink" title="COSMED主机操作"></a>COSMED主机操作</h2><img src="/2022/05/10/4-Tutorials/Hardware/COSMED%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/3.png" class title="Untitled">
<p>COSMED的主机端一般只进行开关机和校准操作，其余操作基本都通过上位机进行遥控。</p>
<h2 id="COSMED的校准"><a href="#COSMED的校准" class="headerlink" title="COSMED的校准"></a>COSMED的校准</h2><p>COSMED的校准包括三部分：涡轮校准、干燥管校准、标气校准</p>
<h3 id="流量校准"><a href="#流量校准" class="headerlink" title="流量校准"></a>流量校准</h3><p>目的：用于校准气流流量（涡轮）传感器。</p>
<p><strong>校准步骤：</strong></p>
<ul>
<li>1 - 将涡轮传感器从面罩上取下，依次连接可伸缩软管、软接头，到三升校准桶上</li>
</ul>
<img src="/2022/05/10/4-Tutorials/Hardware/COSMED%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/4.png" class title="Untitled">
<ul>
<li>2 - COSMED主机选择 <strong>Calibration - Flowmeter</strong></li>
</ul>
<img src="/2022/05/10/4-Tutorials/Hardware/COSMED%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/5.png" class title="Untitled">
<ul>
<li>3 - 根据提示缓慢的拉动校准桶的活塞，直至完全拉到另一端，然后再缓慢推入，重复8次</li>
</ul>
<img src="/2022/05/10/4-Tutorials/Hardware/COSMED%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/6.png" class title="Untitled">
<img src="/2022/05/10/4-Tutorials/Hardware/COSMED%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/7.png" class title="Untitled">
<ul>
<li>4 - 校准通过</li>
</ul>
<img src="/2022/05/10/4-Tutorials/Hardware/COSMED%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/8.png" class title="Untitled">
<ul>
<li>5 - 取下可伸缩软管、软接头、三升校准桶，并收回原处</li>
</ul>
<h3 id="干燥管校准"><a href="#干燥管校准" class="headerlink" title="干燥管校准"></a>干燥管校准</h3><p>目的：二氧化碳分析仪校零</p>
<p>校准步骤：</p>
<ul>
<li>1 - 将气体采样管的插头从涡轮帽上取下，并插入干燥管内</li>
</ul>
<img src="/2022/05/10/4-Tutorials/Hardware/COSMED%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/9.jpeg" class title="Untitled">
<img src="/2022/05/10/4-Tutorials/Hardware/COSMED%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/10.jpeg" class title="Untitled">
<ul>
<li>2 - COSMED主机选择 <strong>Calibration - Scrubber</strong></li>
</ul>
<img src="/2022/05/10/4-Tutorials/Hardware/COSMED%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/11.png" class title="Untitled">
<ul>
<li>3 - 等待校准完成</li>
</ul>
<img src="/2022/05/10/4-Tutorials/Hardware/COSMED%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/12.png" class title="Untitled">
<img src="/2022/05/10/4-Tutorials/Hardware/COSMED%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/13.png" class title="Untitled">
<ul>
<li>4 - <strong>取下干燥管，并放回密封管中，防止其失效</strong>！</li>
</ul>
<h3 id="标气校准"><a href="#标气校准" class="headerlink" title="标气校准"></a>标气校准</h3><p>校准氧气与二氧化碳传感器</p>
<p><strong>校准步骤：</strong></p>
<ul>
<li>1 - 将气体采样管插入COSMED的气体校准盒，确保校准盒的输入气路闭合</li>
</ul>
<img src="/2022/05/10/4-Tutorials/Hardware/COSMED%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/14.jpeg" class title="Untitled">
<ul>
<li>2 - 在气瓶阀门拧紧、气压阀门旋松状态下，先慢慢打开气瓶阀门，再逐渐慢慢旋紧气压阀门至0.4</li>
</ul>
<img src="/2022/05/10/4-Tutorials/Hardware/COSMED%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/15.png" class title="Untitled">
<img src="/2022/05/10/4-Tutorials/Hardware/COSMED%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/16.png" class title="Untitled">
<ul>
<li>3 - COSMED主机点击 <strong>Calibration - Reference Gas - BxB</strong> </li>
</ul>
<img src="/2022/05/10/4-Tutorials/Hardware/COSMED%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/17.png" class title="Untitled">
<img src="/2022/05/10/4-Tutorials/Hardware/COSMED%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/18.png" class title="Untitled">
<img src="/2022/05/10/4-Tutorials/Hardware/COSMED%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/19.png" class title="Untitled">
<ul>
<li>4 - 当出现如下提示时，打开气路开关（闭合开关时可稍向下用力）</li>
</ul>
<img src="/2022/05/10/4-Tutorials/Hardware/COSMED%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/20.png" class title="Untitled">
<img src="/2022/05/10/4-Tutorials/Hardware/COSMED%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/21.png" class title="Untitled">
<img src="/2022/05/10/4-Tutorials/Hardware/COSMED%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/22.png" class title="Untitled">
<ul>
<li>5 - 出现以下提示时，断开气路开关，拔出气体采样管</li>
</ul>
<img src="/2022/05/10/4-Tutorials/Hardware/COSMED%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/23.png" class title="Untitled">
<ul>
<li>6 - 校准通过</li>
</ul>
<img src="/2022/05/10/4-Tutorials/Hardware/COSMED%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/24.png" class title="Untitled">
<ul>
<li>7 - <strong>旋松气压阀门，关闭气瓶阀门，防止漏气以及安全事故！</strong></li>
</ul>
<h2 id="COSMED上位机软件"><a href="#COSMED上位机软件" class="headerlink" title="COSMED上位机软件"></a>COSMED上位机软件</h2><img src="/2022/05/10/4-Tutorials/Hardware/COSMED%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/25.png" class title="Untitled">
<img src="/2022/05/10/4-Tutorials/Hardware/COSMED%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/26.png" class title="Untitled">
<img src="/2022/05/10/4-Tutorials/Hardware/COSMED%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/27.png" class title="Untitled">
<img src="/2022/05/10/4-Tutorials/Hardware/COSMED%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/28.png" class title="Untitled">
<img src="/2022/05/10/4-Tutorials/Hardware/COSMED%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/29.png" class title="Untitled">
<img src="/2022/05/10/4-Tutorials/Hardware/COSMED%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/30.png" class title="Untitled">
<img src="/2022/05/10/4-Tutorials/Hardware/COSMED%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/31.png" class title="Untitled">
<img src="/2022/05/10/4-Tutorials/Hardware/COSMED%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/32.png" class title="Snipaste_2022-08-26_11-06-27.png">
<h2 id="COSMED数据同步工具-实时OCR"><a href="#COSMED数据同步工具-实时OCR" class="headerlink" title="COSMED数据同步工具 - 实时OCR"></a>COSMED数据同步工具 - 实时OCR</h2><img src="/2022/05/10/4-Tutorials/Hardware/COSMED%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/33.png" class title="Untitled">
<ul>
<li>双击打开实时OCR软件，开始数据测量后，勾选VO2、VCO2、VE，点击开始</li>
<li>在线OCR软件需要对COSMED界面的右侧和底部的图像进行检测，避免这些区域被遮挡</li>
</ul>
<h2 id="dSPACE端UDP通信配置"><a href="#dSPACE端UDP通信配置" class="headerlink" title="dSPACE端UDP通信配置"></a>dSPACE端UDP通信配置</h2><img src="/2022/05/10/4-Tutorials/Hardware/COSMED%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/34.png" class title="Untitled">
<ul>
<li>COSMED在线OCR软件将呼吸数据通过网线以UDP协议发送给dSPACE</li>
<li>其中电脑端IP地址为<strong><code>192.168.254.1</code></strong>，dSPACE端IP地址为<strong><code>192.168.254.100</code></strong></li>
<li>每个Packet数据包括八个字节，每两个字节表示一个16位整型，分别为VO2、VCO2、VE、HR</li>
<li>由于VE含有一位小数，发送时将VE真实值乘以10再发送，因此接收时需要再乘0.1</li>
</ul>
]]></content>
      <categories>
        <category>tutorials</category>
      </categories>
      <tags>
        <tag>设备教程</tag>
      </tags>
  </entry>
  <entry>
    <title>NKAEX组装说明</title>
    <url>/2022/05/10/4-Tutorials/Hardware/NKAEX%E7%BB%84%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<img src="/2022/05/10/4-Tutorials/Hardware/NKAEX%E7%BB%84%E8%A3%85%E6%95%99%E7%A8%8B/0.png" class title="Untitled">
<span id="more"></span>
<h3 id="Step-1-组装-关节轴-Assembly"><a href="#Step-1-组装-关节轴-Assembly" class="headerlink" title="Step 1 - 组装 关节轴 Assembly"></a>Step 1 - 组装 关节轴 Assembly</h3><img src="/2022/05/10/4-Tutorials/Hardware/NKAEX%E7%BB%84%E8%A3%85%E6%95%99%E7%A8%8B/1.png" class title="Untitled">
<ul>
<li>首先安装2颗轴承。若铝合金上的圆形孔较大无法装入则对其进行打磨；若偏大则在内侧涂速干胶再嵌入轴承。(轴承需要与铝合金零件表面完全贴合，不能有突出或凹陷，否则影响后续装配)</li>
<li>测试半D型轴能否插入下部铝合金零件的D型孔内，如果不能(大概率)则对零件进行打磨。</li>
<li>将下部铝合金零件放至上部铝合金零件的槽内，并在每侧垫入一个M6的垫片，以减小摩擦。</li>
<li>使用镊子等工具，将关节轴上所有零件的孔对准对齐。</li>
<li>将半D型轴插入关节孔，其中圆型一侧为外侧，D型一侧为内侧(指向人体踝关节)；两个关节轴Assembly的轴安装方向应当相反。</li>
<li>将卡簧卡入关节轴的卡簧槽内，轴向固定关节轴。</li>
<li>将M3机米螺丝安装至下部铝合金零件的螺纹孔内，径向固定关节轴。</li>
</ul>
<h3 id="Step-2-组装-Heel-Assembly"><a href="#Step-2-组装-Heel-Assembly" class="headerlink" title="Step - 2 组装 Heel Assembly"></a>Step - 2 组装 Heel Assembly</h3><img src="/2022/05/10/4-Tutorials/Hardware/NKAEX%E7%BB%84%E8%A3%85%E6%95%99%E7%A8%8B/2.png" class title="Untitled">
<ul>
<li>将3D打印LoadCell座上的M5.5通孔攻丝为M6的螺纹孔。</li>
<li>将Heel碳纤维板的末端直角打磨成0.8的倒角，使上下两个衬垫能够恰好完整包裹碳纤维板。</li>
<li>测试：将衬衬垫放Heel碳纤维的上下，法兰轴承和LoadCell座顺碳纤维套入，尝试法兰轴承能否装入衬垫和LoadCell座之间(可以较紧)；若完全没有装入的可能性，进行轻微打磨。</li>
<li>用速干胶将衬垫固定在碳纤维板的上下侧，凝固后按上一步的方式进行组装。若较紧，可使用钳子等工具将轴承强行嵌入衬垫和LoadCell座之间；若较松，使用速干胶固定。</li>
<li>将3D打印LoadCell连接头的下部通孔攻丝为M6螺纹孔。</li>
</ul>
<h3 id="Step-3-组装-FrontFoot-Assembly"><a href="#Step-3-组装-FrontFoot-Assembly" class="headerlink" title="Step - 3 组装 FrontFoot Assembly"></a>Step - 3 组装 FrontFoot Assembly</h3><img src="/2022/05/10/4-Tutorials/Hardware/NKAEX%E7%BB%84%E8%A3%85%E6%95%99%E7%A8%8B/3.png" class title="Untitled">
<ul>
<li>将轴承安装至足部碳板的前侧M8孔内，根据需要使用速干胶固定。</li>
<li>使用螺丝组装足部结构，其中跖趾关节座有螺纹孔的一侧朝向人体；跖趾关节座上部的螺纹孔内涂螺纹紧固胶，增大螺丝摩擦力。</li>
</ul>
<h3 id="Step-4-整体结构组装"><a href="#Step-4-整体结构组装" class="headerlink" title="Step - 4 整体结构组装"></a>Step - 4 整体结构组装</h3><img src="/2022/05/10/4-Tutorials/Hardware/NKAEX%E7%BB%84%E8%A3%85%E6%95%99%E7%A8%8B/4.png" class title="Untitled">]]></content>
      <categories>
        <category>tutorials</category>
      </categories>
      <tags>
        <tag>硬件教程</tag>
      </tags>
  </entry>
  <entry>
    <title>PCB-3D模型渲染全流程</title>
    <url>/2021/10/03/4-Tutorials/Hardware/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<blockquote>
<p>以LCEDA为PCB设计软件，将3D模型完美导出至SW并渲染</p>
</blockquote>
<img src="/2021/10/03/4-Tutorials/Hardware/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/IMU_Rendering.gif" class>
<span id="more"></span>
<h2 id="Step-1-LCEDA导出PCB文件至AD"><a href="#Step-1-LCEDA导出PCB文件至AD" class="headerlink" title="Step 1:  LCEDA导出PCB文件至AD"></a>Step 1:  LCEDA导出PCB文件至AD</h2><img src="/2021/10/03/4-Tutorials/Hardware/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/%E6%88%AA%E5%B1%8F2021-10-10_%E4%B8%8B%E5%8D%883.41.35.png" class>
<ul>
<li>截取顶/底层预览图（配置好板子颜色）<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img src="/2021/10/03/4-Tutorials/Hardware/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/截屏2021-10-10_下午3.44.47.png" style="zoom: 45%;"></div><div class="group-picture-column" style="width: 50%;"><img src="/2021/10/03/4-Tutorials/Hardware/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/截屏2021-10-10_下午3.44.54.png" style="zoom: 45%;"></div></div></div></div>
</li>
</ul>
<h2 id="Step-2-AD导入PCB文件"><a href="#Step-2-AD导入PCB文件" class="headerlink" title="Step 2:  AD导入PCB文件"></a>Step 2:  AD导入PCB文件</h2><img src="/2021/10/03/4-Tutorials/Hardware/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/%E6%88%AA%E5%B1%8F2021-10-10_%E4%B8%8B%E5%8D%883.54.39.png" class>
<ul>
<li>选中外边框，设置为PCB板的外形</li>
</ul>
<p><img src="/2021/10/03/4-Tutorials/Hardware/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/截屏2021-10-10_下午3.56.08.png" style="zoom:200%;"></p>
<ul>
<li>生成PCB库</li>
</ul>
<img src="/2021/10/03/4-Tutorials/Hardware/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/%E6%88%AA%E5%B1%8F2021-10-10_%E4%B8%8B%E5%8D%883.57.14.png" class>
<ul>
<li>进入PCB library(左下角)，为元件添加3D模型</li>
</ul>
<img src="/2021/10/03/4-Tutorials/Hardware/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/%E6%88%AA%E5%B1%8F2021-10-10_%E4%B8%8B%E5%8D%886.08.19.png" class>
<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/2021/10/03/4-Tutorials/Hardware/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/截屏2021-10-10_下午6.06.55.png" style="zoom:19%;"></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/2021/10/03/4-Tutorials/Hardware/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/截屏2021-10-10_下午6.07.30.png" style="zoom: 19%;"></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/2021/10/03/4-Tutorials/Hardware/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/截屏2021-10-10_下午6.07.39.png" style="zoom:19%;"></div></div></div></div>
<blockquote>
<p>推荐两个优秀的模型下载网站：<br><a href="https://grabcad.com/">https://grabcad.com/</a> (科学)<br><a href="https://www.3dcontentcentral.cn/">https://www.3dcontentcentral.cn/</a></p>
</blockquote>
<ul>
<li>更新PCB</li>
</ul>
<img src="/2021/10/03/4-Tutorials/Hardware/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/%E6%88%AA%E5%B1%8F2021-10-10_%E4%B8%8B%E5%8D%886.08.59.png" class>
<ul>
<li>设置PCB板厚度</li>
</ul>
<img src="/2021/10/03/4-Tutorials/Hardware/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/%E6%88%AA%E5%B1%8F2021-10-10_%E4%B8%8B%E5%8D%886.11.46.png" class>
<img src="/2021/10/03/4-Tutorials/Hardware/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/%E6%88%AA%E5%B1%8F2021-10-10_%E4%B8%8B%E5%8D%888.16.35.png" class>
<h2 id="Step-3-导出AD文件至SW"><a href="#Step-3-导出AD文件至SW" class="headerlink" title="Step 3:  导出AD文件至SW"></a>Step 3:  导出AD文件至SW</h2><ul>
<li>AD导出<code>.x_t</code>格式文件，导出设置中选择不导出铜皮</li>
</ul>
<img src="/2021/10/03/4-Tutorials/Hardware/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/%E6%88%AA%E5%B1%8F2021-10-10_%E4%B8%8B%E5%8D%886.12.44.png" class>
<img src="/2021/10/03/4-Tutorials/Hardware/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/Untitled.png" class>
<ul>
<li>SW打开<code>.x_t</code>格式文件，并保存为装配体</li>
</ul>
<img src="/2021/10/03/4-Tutorials/Hardware/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/%E6%88%AA%E5%B1%8F2021-10-10_%E4%B8%8B%E5%8D%886.18.08.png" class>
<ul>
<li>将PCB板设置为灰色</li>
</ul>
<img src="/2021/10/03/4-Tutorials/Hardware/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/%E6%88%AA%E5%B1%8F2021-10-10_%E4%B8%8B%E5%8D%886.22.32.png" class>
<img src="/2021/10/03/4-Tutorials/Hardware/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/%E6%88%AA%E5%B1%8F2021-10-10_%E4%B8%8B%E5%8D%886.23.24.png" class>
<ul>
<li>为PCB的顶面和底面添加纹理（贴图）</li>
</ul>
<img src="/2021/10/03/4-Tutorials/Hardware/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/%E6%88%AA%E5%B1%8F2021-10-10_%E4%B8%8B%E5%8D%886.24.05.png" class>
<img src="/2021/10/03/4-Tutorials/Hardware/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/%E6%88%AA%E5%B1%8F2021-10-10_%E4%B8%8B%E5%8D%886.25.06.png" class>
<ul>
<li>编辑纹理属性</li>
</ul>
<img src="/2021/10/03/4-Tutorials/Hardware/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/%E6%88%AA%E5%B1%8F2021-10-10_%E4%B8%8B%E5%8D%886.26.00.png" class>
<ul>
<li>在属性中选择高级模式，并选择之前保存的图像</li>
</ul>
<img src="/2021/10/03/4-Tutorials/Hardware/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/%E6%88%AA%E5%B1%8F2021-10-10_%E4%B8%8B%E5%8D%886.26.58.png" class>
<ul>
<li>在映射中将图片大小改为PCB的实际尺寸</li>
</ul>
<img src="/2021/10/03/4-Tutorials/Hardware/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/%E6%88%AA%E5%B1%8F2021-10-10_%E4%B8%8B%E5%8D%886.28.17.png" class>
<ul>
<li>其中一面贴图还需要设置为水平镜像</li>
</ul>

<h2 id="Step-4-SolidWorks-Visualize渲染"><a href="#Step-4-SolidWorks-Visualize渲染" class="headerlink" title="Step 4:  SolidWorks Visualize渲染"></a>Step 4:  SolidWorks Visualize渲染</h2><ul>
<li>在Visualize中新建项目并导入模型（由<code>.x_t</code>生成的为装配体模型）</li>
</ul>
<img src="/2021/10/03/4-Tutorials/Hardware/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/%E6%88%AA%E5%B1%8F2021-10-10_%E4%B8%8B%E5%8D%886.47.16.png" class>
<ul>
<li>根据需求调整材质颜色与属性</li>
</ul>
<img src="/2021/10/03/4-Tutorials/Hardware/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/%E6%88%AA%E5%B1%8F2021-10-10_%E4%B8%8B%E5%8D%886.49.06.png" class>
<ul>
<li>根据需求调整环境与背板</li>
</ul>
<img src="/2021/10/03/4-Tutorials/Hardware/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/%E6%88%AA%E5%B1%8F2021-10-10_%E4%B8%8B%E5%8D%886.50.51.png" class>
<ul>
<li>根据需求相机位置与姿态</li>
</ul>
<img src="/2021/10/03/4-Tutorials/Hardware/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/%E6%88%AA%E5%B1%8F2021-10-10_%E4%B8%8B%E5%8D%886.55.01.png" class>
<ul>
<li>进行渲染</li>
</ul>
<img src="/2021/10/03/4-Tutorials/Hardware/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/EB_MotorCOM.jpg" class>
<blockquote>
<p>Reference：</p>
<ol>
<li><a href="https://www.bilibili.com/read/cv6758801/">https://www.bilibili.com/read/cv6758801/</a></li>
<li><a href="https://blog.csdn.net/hxkrrzq/article/details/99180230">https://blog.csdn.net/hxkrrzq/article/details/99180230</a></li>
<li><a href="https://blog.csdn.net/huadaoyingmu/article/details/99985021">https://blog.csdn.net/huadaoyingmu/article/details/99985021</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>tutorials</category>
      </categories>
      <tags>
        <tag>硬件开发</tag>
      </tags>
  </entry>
  <entry>
    <title>人体解剖学 3 - 肌学基础</title>
    <url>/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E8%82%8C%E5%AD%A6/</url>
    <content><![CDATA[<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E8%82%8C%E5%AD%A6/00.png" class title="00.jpeg">
<span id="more"></span>
<h2 id="肌学总论"><a href="#肌学总论" class="headerlink" title="肌学总论"></a>肌学总论</h2><p>骨骼肌是人体重量最大的组织, 约占体重的40%-50%，在骨和关节的配合下，通过骨骼肌的收缩和舒张，完成各种躯体运动，每个骨骼肌纤维都是一个独立的功能单位和结构单位，至少接受一个运动神经末梢的支配，在中枢神经的控制下完成运动。</p>
<h3 id="肌的类型"><a href="#肌的类型" class="headerlink" title="肌的类型"></a>肌的类型</h3><ul>
<li>按肌细胞分化分类：分为<strong>骨骼肌</strong>、<strong>心肌</strong>和<strong>平滑肌</strong>。</li>
<li>按配布与运动作用分类：分为<strong>原动肌</strong>、<strong>拮抗肌</strong>、<strong>固定肌</strong>和<strong>协同肌</strong>。在不同的运动中，某块肌肉可担当原动肌、拮抗肌、固定肌或协同肌等不同的角色。即使在同一运动中，由于重力的协助或抵抗力不同，同一块肌肉的作用也会改变。</li>
<li>按肌纤维类型分类：人类骨骼肌存在三种不同功能的肌纤维：<strong>I型慢缩纤维</strong>，又称<strong>红肌</strong>，即缓慢 - 氧化型肌纤维；<strong>IIa 型</strong>和 <strong>IIb 型快缩纤维</strong>，又称<strong>白肌</strong>。II a 型又称快速氧化酵解型纤维，氧化和酵解代谢途径均较完善，抗痩劳特性介于 I 型和 II b 型之间。IIb 型又称快速酵解型纤维。</li>
<li>按形态分类：分为<strong>长肌、阔肌、轮匝肌、短肌</strong>。</li>
</ul>
<h3 id="肌的形态"><a href="#肌的形态" class="headerlink" title="肌的形态"></a>肌的形态</h3><p>肌的形态多种多样，按外形：分长肌(多见于四肢)、短肌(多位于躯干深层)、扁肌(多见于胸腹壁)、轮匝肌(在孔裂周围)。肌肉由<strong>肌腹</strong>和<strong>肌腱</strong>两部分构成。</p>
<ul>
<li><strong>肌腹</strong>：主要由横纹肌纤维组成，色红，柔软，有收缩能力。肌腹外包有肌外膜。由肌外膜发出若干纤维隔进入肌腹内将其分为割为较小的<strong>肌束</strong>，包被肌束的结缔组织称肌束膜。肌束内<strong>每条肌纤维</strong>还包有肌内膜。</li>
<li><strong>肌腱</strong>：主要由平行的胶原纤维束构成，色白，强韧，无收缩能力。位于肌腹的两端，附着于骨。</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E8%82%8C%E5%AD%A6/41.png" class title="41.png">
<h3 id="肌的辅助装置"><a href="#肌的辅助装置" class="headerlink" title="肌的辅助装置"></a>肌的辅助装置</h3><p>肌的辅助装置位于肌肉周围，具有保护肌肉和辅助肌肉活动的作用。包括：</p>
<ul>
<li><strong>筋膜</strong>：分为浅筋膜和深筋膜。<strong>浅筋膜</strong>即脂肪及组织。<strong>深筋膜</strong>包囊肌肉，并随肌肉的分层而分层，能保护肌肉免受摩擦，分隔肌群，保证各肌能单独活动。</li>
<li><strong>滑液囊</strong>：位于肌腱与骨面接触处，以减少两者间的摩擦。</li>
<li><strong>腱鞘</strong>：套在长腱表面的鞘管，有固定及减少摩擦的作用，由内层(腱滑液鞘)和外层(腱纤维鞘)构成。前者又分为脏、壁两层，两层相互移行处构成腱系膜。</li>
<li><strong>籽骨</strong>：由肌腱骨化而成，有消除肌腱与骨面之间的摩擦及加大肌的作用。</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E8%82%8C%E5%AD%A6/42.png" class title="42.png">
<h3 id="肌起止、配布、作用和命名法"><a href="#肌起止、配布、作用和命名法" class="headerlink" title="肌起止、配布、作用和命名法"></a><strong>肌起止、配布、作用和命名法</strong></h3><ul>
<li>肌肉通常起于一骨，止于另一骨，中间跨过一个或几个关节。一般将接近身体正中面或四肢靠近近侧的附着点称为<strong>肌肉的起点或定点</strong>，另一端称为<strong>止点或动点</strong>。骨肉排列规律是，以跨越关节的运动轴为准，形成两群互相对抗的肌肉。如跨越水平冠状轴<strong>屈肌群和伸肌群</strong>；分布于水平矢状轴两侧的<strong>内收肌群和外展肌群</strong>；横行或斜行跨越垂直轴的<strong>旋内(旋前)肌群和旋外(旋后)肌群</strong>。</li>
<li>肌肉可根据<strong>形状、大小、位置、起止点、纤维方向和作用</strong>等命名。依形态命名的如斜方肌、菱形肌、三角肌、梨状肌等；依位置命名的如肩胛下肌、冈上肌、冈下肌、肱肌等；依位置和大小综合命名的有胸大肌、胸小肌、臀大肌等；依起止点命名的如胸锁乳突肌、肩胛舌骨肌等；依纤维方向和部位综合命名的有腹外斜肌、肋间外肌等；依作用命名的如旋后肌、咬肌等；依作用结合其它因素综合命名的如旋前圆肌、内收长肌、指浅屈肌等。</li>
</ul>
<h2 id="躯干肌"><a href="#躯干肌" class="headerlink" title="躯干肌"></a>躯干肌</h2><p>躯干肌可分为<strong>背肌</strong>、<strong>胸肌</strong>、<strong>膈肌</strong>、<strong>腹肌</strong>和<strong>会阴肌</strong>。</p>
<h3 id="背肌"><a href="#背肌" class="headerlink" title="背肌"></a>背肌</h3><img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E8%82%8C%E5%AD%A6/01.png" class title="01.png">
<p><strong>背浅肌：</strong><br>背浅肌分为两层，均起自脊柱的不同部位，止于上肢带骨或自由上肢骨。有<strong>斜方肌、背阔肌</strong>、<strong>肩胛提肌</strong>和<strong>菱形肌</strong>。</p>
<ul>
<li><strong>斜方肌位</strong>于项部和背上部的浅层，为三角形的扁肌，左右两侧合在一起呈斜方形，故而得名。该肌<strong>起自上项线</strong>、<strong>枕外隆凸</strong>、<strong>项韧带</strong>、<strong>第7颈椎</strong>和<strong>全部胸椎的棘突</strong>，上部的肌束斜向外下方，中部的平行向外，下部的斜向外上方，<strong>止于锁骨的外侧1/3部分</strong>、<strong>肩峰</strong>和<strong>肩胛冈</strong>。<strong>作用</strong>：使肩胛骨向脊柱靠拢，上部肌束可上提肩胛骨，下部肌束使肩胛骨下降。如果肩胛骨固定，一侧肌收缩使颈向同侧屈、脸转向对侧，两侧同时收缩可使头后仰。该肌瘫痪时，产生“塌肩”。</li>
<li><strong>背阔肌</strong>为<strong>全身最大的扁肌</strong>，位于背的下半部及胸的后外侧，以腱膜<strong>起自下6个胸椎的棘突</strong>、<strong>全部腰椎的棘突</strong>、<strong>骶正中嵴</strong>及<strong>髂嵴后部</strong>等处，肌束向外上方集中，经肱骨的内侧至其前方，以扁腱<strong>止于肱骨小结节嵴</strong>。作用：<strong>使肱骨内收、旋内和后伸</strong>。当上肢上举固定时，可引体向上。临床上常利用背阔肌制作成肌皮瓣或肌瓣修复大面积缺损，或用于心肌成形术，此时不会对正常功能产生严重影响。</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E8%82%8C%E5%AD%A6/02.png" class title="02.png">
<ul>
<li><strong>肩胛提肌</strong>项部两侧、斜方肌的深面，起自上4个颈椎的横突，止于肩胛骨的上角。作用：上提肩胛骨，并使肩胛骨下角转向内，如肩胛骨固定，可使颈向同侧屈曲。</li>
<li><strong>菱形肌</strong>位于斜方肌的深面，为菱形的扁肌，起自第6、7颈椎和第1～4胸椎的棘突，纤维行向下外，止于肩胛骨的内侧缘。作用：牵引肩胛骨向内上并向脊柱靠拢。</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E8%82%8C%E5%AD%A6/03.png" class title="03.png">
<p><strong>背深肌：</strong><br>背深肌在脊柱两侧排列，分为长肌和短肌。长肌位置较浅，主要有<strong>竖脊肌</strong>和<strong>夹肌</strong>；短肌位于深部，种类较多而复杂，有枕下肌、棘间肌、横突间肌、肋提肌等。它们都是从肌节演变而来，短肌仍保留明显的分节特征，长肌是肌节在不同程度上融合后形成的。背深部的长、短肌对<strong>维持人体直立姿势</strong>起重要作用，短肌还与脊柱的韧带一起保持各椎骨之间的稳固连接。</p>
<ul>
<li><strong>竖脊肌(骶棘肌</strong>)：由内向外包括<strong>棘肌</strong>、<strong>胸最长肌</strong>、<strong>髂肋肌</strong>，为背肌中最长、最大的肌，纵列于躯干的背面、脊柱两侧的沟内，起自骶骨背面和髂嵴的后部，向上分出三群肌束，沿途止于椎骨和肋骨，向上可到达颞骨乳突。作用：使<strong>脊柱后伸和仰</strong>头，一侧收缩使脊柱侧屈。</li>
<li><strong>夹肌</strong>：包络头夹肌和颈夹肌，位于斜方肌、菱形肌的深面，起自项韧带下部、第7颈椎棘突和上部胸椎，向上外止于颞骨乳突和第1～3颈椎横突。作用：此肌如单侧收缩，<strong>使头转向同侧</strong>，两侧收缩，<strong>使头后仰</strong>。</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E8%82%8C%E5%AD%A6/04.png" class title="04.png">
<p><strong>胸腰筋膜：</strong><br>被覆于斜方肌和背阔肌表面的深筋膜较薄弱，但在竖脊肌周围的筋膜特别发达，称胸腰筋膜。胸腰筋膜<strong>包裹在竖脊肌和腰方肌的周围</strong>，<strong>在腰部筋膜明显增厚</strong>，<strong>可分为浅、中和深层</strong>。浅层位于竖脊肌的后面，向内附于棘上韧带，外侧附于肋角，向下附于髂嵴，也是背阔肌的起始腱膜，白色而有光泽。中层分隔竖脊肌和腰方肌，中层和浅层在竖脊肌外侧会合，构成竖脊肌鞘。深层覆盖腰方肌的前面，三层筋膜在腰方肌外侧缘会合而成为腹内斜肌和腹横肌的起点。由于腰部活动度大，在剧烈运动中，胸腰筋膜常可扭伤，为<strong>腰背劳损</strong>病因之一。</p>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E8%82%8C%E5%AD%A6/05.png" class title="05.png">
<h3 id="胸肌"><a href="#胸肌" class="headerlink" title="胸肌"></a>胸肌</h3><p>胸肌可分为两群，一群为<strong>胸上肢肌</strong>，位于胸壁的前面及侧面浅层，为阔肌，止于上肢带骨或肱骨；一群为<strong>胸固有肌</strong>，参与胸壁的构成，仍保持着节段性。     </p>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E8%82%8C%E5%AD%A6/06.png" class title="06.png">
<p><strong>胸上肢肌 ：</strong>     </p>
<ul>
<li><strong>胸大肌</strong>位置表浅，宽而厚，呈扇形，覆盖胸廓前壁的大部，起自<strong>锁骨的内侧半</strong>、<strong>胸骨</strong>和<strong>第1～6肋软骨</strong>等处，各部肌束聚合向外，以扁腱<strong>止于肱骨大结节嵴</strong>。作用：<strong>使肩关节内收、旋内和前屈</strong>。如上肢固定，可上提躯干，与背阔肌一起完成引体向上的动作，也可提肋助吸气。</li>
<li><strong>胸小肌</strong>位于胸大肌深面，呈三角形，起自第3～5肋骨，止于肩胛骨的喙突。作用：拉肩胛骨向前下方。当肩胛骨固定时，可上<strong>提肋以助吸气</strong>。</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E8%82%8C%E5%AD%A6/07.png" class title="07.png">
<ul>
<li><strong>前锯肌</strong>为宽大的扁肌，位于胸廓侧壁，以数个肌齿起自上8个或9个肋骨，肌束斜向后上内，经肩胛骨的前方，止于肩胛骨内侧缘和下角。作用：<strong>拉肩胛骨向前和紧贴胸廓</strong>，下部肌束使肩胛骨下角旋外，助臂上举，当肩胛骨固定时，可上提肋骨助深吸气。若此肌瘫痪，则肩胛骨下角离开胸廓而突出于皮下，称为“<strong>翼状肩</strong>”，此时不能完全上举臂或做向前推的动作。</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E8%82%8C%E5%AD%A6/08.png" class title="08.png">
<p><strong>胸固有肌：</strong></p>
<ul>
<li><strong>肋间内肌</strong>位于肋间外肌的深面，起自下位肋骨的上缘，止于上位肋骨的下缘，肌束方向与肋间外肌相反，前部肌束达胸骨外侧缘，后部肌束只到肋角，自此向后为肋间内膜所代替。作用：<strong>降肋助呼气</strong>。</li>
<li><strong>肋间外肌</strong>共11对，位于各肋间隙的浅层，起自肋骨下缘，肌束斜向前下，止于下一肋骨的上缘，其前部肌束仅达肋骨与肋软骨的结合处，在肋软骨间隙处，移行为一片结缔组织膜，称肋间外膜。作用：<strong>提肋</strong>，使胸廓纵径及横径皆扩大，<strong>以助吸气</strong>。</li>
</ul>
<h3 id="膈肌"><a href="#膈肌" class="headerlink" title="膈肌"></a>膈肌</h3><ul>
<li>膈是由颈部的肌节迁移至胸腹腔之间而形成的<strong>向上膨隆呈穹窿形的扁肌</strong>，膈的肌纤维起自胸廓下口的周缘和腰椎前面，可分为三部：胸骨部起自剑突后面；肋部起自下6对肋骨和肋软骨；腰部以左、右两个膈脚起自上2～3个腰椎。膈肌的肌纤维在外周，腱膜(不能收缩的部分)在中心，又叫<strong>中心腱。</strong></li>
<li>膈上有<strong>三个裂孔</strong>：在第12胸椎体前方，左右两个膈脚与脊柱之间有<strong>主动脉裂孔</strong>，有主动脉和胸导管通过；<strong>主动脉裂孔</strong>的左前上方，约在第10胸椎水平，有<strong>食管裂孔</strong>，有食管和迷走神经通过；在食管裂孔的右前上方的中心腱内有<strong>腔静脉孔</strong>，约在第8胸椎水平，有下腔静脉通过。</li>
<li>膈肌三部起点之间通常留有三角形小区，无肌纤维，仅覆以结缔组织，为<strong>薄弱区</strong>，其中胸骨部与肋部起点之间的叫<strong>胸肋三角</strong>；肋部与腰部之间的叫<strong>腰肋三角</strong>，腹部脏器若经上述的三角区突入胸腔则称为<strong>膈疝</strong>。</li>
<li>作用：膈为主要的<strong>呼吸肌</strong>，<strong>收缩时，膈穹窿下降，胸腔容积扩大</strong>，以助吸气；<strong>松弛时，膈穹窿上升恢复原位，胸腔容积减小</strong>，以助呼气。膈与腹肌同时收缩，则能增加腹压，协助排便、呕吐、咳嗽、喷嚏及分娩等活动</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E8%82%8C%E5%AD%A6/09.png" class title="09.png">
<h3 id="腹肌"><a href="#腹肌" class="headerlink" title="腹肌"></a>腹肌</h3><p>腹肌位于胸廓与骨盆之间，参与腹壁的组成，按其部位可分为前外侧群、后群两部分。</p>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E8%82%8C%E5%AD%A6/10.png" class title="10.png">
<p><strong>腹肌-前外侧群：</strong><br>前外侧群构成腹腔的前外侧壁，包括带形的<strong>腹直肌</strong>和三块宽阔的扁肌：<strong>腹外斜肌</strong>、<strong>腹内斜肌</strong>和<strong>腹横肌</strong>。腹前外侧群肌的作用：三块扁肌<strong>肌纤维互相交错</strong>，结构如三合板，薄而坚韧，与腹直肌共同形成牢固而有弹性的腹壁，保护腹腔脏器，维持腹内压。腹内压对腹腔脏器位置的固定有重要意义，若这些肌张力减弱时，可使腹腔脏器下垂。当腹肌收缩时，可增加腹内压以完成排便、分娩、呕吐和咳嗽等生理功能；能使脊柱前屈、侧屈与旋转，还可降肋助呼气。</p>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E8%82%8C%E5%AD%A6/11.png" class title="11.png">
<ul>
<li><strong>腹外斜肌</strong>为宽阔扁肌，位于腹前外侧部的浅层，以8个肌齿起自下8个肋骨的外面，与前锯肌、背阔肌的肌齿交错，<strong>肌纤维斜向前下</strong>，后部肌束向下止于髂嵴前部，其余肌束向内移行于腱膜，经<strong>腹直肌的前面</strong>，并参与构成腹直肌鞘的前层，至腹正中线终于<strong>白线</strong>。腹外斜肌腱膜的下缘卷曲增厚连于髂前上棘与耻骨结节之间，称为<strong>腹股沟韧带</strong>。腹股沟韧带的内侧端有一小束腱纤维向下后方反折至耻骨梳，称腔隙韧带(陷窝韧带)，腔隙韧带延伸并附于耻骨梳的部分称耻骨梳韧带（即Cooper 韧带），腹股沟韧带和耻骨梳韧带都是腹股沟疝修补术时用来加强腹股沟管壁的重要结构。在耻骨结节外上方，腱膜形成三角形的裂孔，为<strong>腹股沟管浅(皮下)环</strong>。</li>
<li><strong>腹内斜肌</strong>在腹外斜肌深面。起始于胸腰筋膜、髂嵴和腹股沟韧带的外侧1/2，肌束呈扇形，即后部肌束几乎垂直上升止于下位3个肋骨，<strong>大部分肌束向前上方延为腱膜</strong>，在<strong>腹直肌外侧缘分为前、后两层包裹腹直肌</strong>，参与构成腹直肌鞘的前层及后层，<strong>在腹正中线终于白线</strong>。腹内斜肌下部起于腹股沟韧带的肌束行向前下，越过精索前面，延为腱膜，与腹横肌的腱膜会合形成腹股沟镰或称联合腱，止于耻骨梳的内侧端及耻骨结节附近。腹内斜肌的最下部发出一些细散的肌纤维，包绕精索、睾丸和阴囊，称为提睾肌，收缩时可上提睾丸。此肌虽属骨骼肌，但不受意志支 配。在女性，该肌非常薄弱，仅少许纤维沿子宫圆韧带表面下降，相当于男性提睾肌外侧部的纤维。</li>
<li><strong>腹横肌</strong>在腹内斜肌深面，<strong>起自下6个肋软骨的内面、胸腰筋膜、髂嵴和腹股沟韧带的外侧1/3</strong>，<strong>肌束横行向前延为腱膜</strong>，腱膜越过腹直肌后面参与组成腹直肌鞘后层，<strong>止于白线</strong>。腹横肌最下部的肌束和腱膜下缘的内侧部分分别参与构成提睾肌和腹股沟镰。</li>
<li><strong>腹直肌</strong>位于腹前壁正中线的两旁，居腹直肌鞘中，上宽下窄，<strong>起自耻骨联合和耻骨嵴</strong>，肌束向上<strong>止于胸骨剑突和第5～7肋软骨的前面</strong>。肌的全长被3～4条横行的<strong>腱划</strong>分成几个肌腹，腱划系结缔组织构成，与腹直肌鞘的前层紧密结合，为肌节愈合的痕迹。在腹直肌的后面，腱划不明显，未与腹直肌鞘的后层愈合，所以腹直肌的后面是完全游离的。</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E8%82%8C%E5%AD%A6/12.png" class title="12.png">
<ul>
<li><strong>腹直肌鞘</strong>包绕腹直肌，由腹前外侧壁<strong>三块扁肌的腱膜</strong>形成。<strong>鞘分前、后两层</strong>，前层由腹外斜肌腱膜与腹内斜肌腱膜的前层构成；后层由腹内斜肌腱膜的后层与腹横肌腱膜构成。在<strong>脐以下4～5cm处</strong>三块扁肌的腱膜全部转到腹直肌的前面构成腹直肌鞘的前层，使<strong>后层缺如</strong>，因此，腹直肌鞘的后层由于腱膜中断而形成一凸向上方的弧形边界线称<strong>弓状线</strong>或<strong>半环线</strong>，此线以下腹直肌后面与腹横筋膜相贴。</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E8%82%8C%E5%AD%A6/13.png" class title="13.png">
<ul>
<li><strong>白线</strong>位于<strong>腹前壁正中线</strong>上，<strong>为左右腹直肌鞘之间的隔</strong>，由两侧三层扁肌腱膜的纤维交织而成，<strong>上方起自剑突</strong>，<strong>下方止于耻骨联合</strong>。白线<strong>坚韧而少血管</strong>，<strong>上部较宽</strong>，约1cm，自脐以<strong>下变窄</strong>成线状。约在白线的中点有疏松的疤痕组织区即脐环，在胎儿时期，有脐血管通过，为腹壁的一个薄弱点，若腹腔脏器由此处膨出，称为脐疝。</li>
</ul>
<p><strong>腹肌-后群肌：</strong><br>后群有腰大肌和腰方肌，腰大肌将在下肢中叙述。</p>
<ul>
<li><strong>腰方肌</strong>位于腹后壁，在脊柱两侧，其内侧有腰大肌，其后方有竖脊肌，腰方肌的前后面为胸腰筋膜的深层和中层所包裹，并与其他肌肉相分割，该肌起自髂嵴的后部，向上止于第12肋和第1～4腰椎横突。作用：下降和固定第12肋，并使脊柱侧屈。</li>
</ul>
<p><strong>腹股沟管：</strong></p>
<ul>
<li>前外侧壁的下部，在腹股沟韧带内侧半的上方,由外上斜贯向内下，长约4.5cm。管的内口称<strong>腹股沟管深(腹)环</strong>，在腹股韧带中点上方约1.5cm处，为腹横筋膜向外的突口，其内侧有腹壁下动脉。管的外口即<strong>腹股沟管浅(皮下)环</strong>。<strong>管有四个壁</strong>，<strong>前壁是腹外斜肌腱膜和腹内斜肌</strong>；<strong>后壁是腹横筋膜和腹股沟镰</strong>；<strong>上壁为腹内斜肌和腹横肌的弓状下缘</strong>；<strong>下壁为腹股沟韧带</strong>。腹股沟管内，男性有精索，女性有子宫圆韧带通过。</li>
</ul>
<p><strong>腹股沟(海氏)三角</strong>      </p>
<ul>
<li>腹股沟(海氏)三角 (Hesselbach)位于腹前壁下部，是由<strong>腹直肌外侧缘</strong>、<strong>腹股沟韧带</strong>和<strong>腹壁下动脉</strong>围成的三角区。腹股沟管和腹股沟三角都是腹壁下部的<strong>薄弱区</strong>。在病理情况下，如腹膜形成的鞘突未闭合，或腹壁肌肉薄弱、长期腹内压增高等，可致腹腔内容物由此区突出，形成<strong>疝</strong>。若腹腔内容物经腹股沟管深环进入腹股沟管，再<strong>经腹股沟管浅环突出</strong>，下降入阴囊，构成<strong>腹股沟斜疝</strong>；若腹腔内容物<strong>不经腹股沟管深环</strong>，而从腹股沟三角处膨出，则为<strong>腹股沟直疝</strong>。</li>
</ul>
<h2 id="上肢肌"><a href="#上肢肌" class="headerlink" title="上肢肌"></a>上肢肌</h2><p>上肢肌分为<strong>上肢带肌（肩肌）</strong>、<strong>臂肌</strong>、<strong>前臂肌</strong>和<strong>手肌</strong>。 </p>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E8%82%8C%E5%AD%A6/15.png" class title="15.png">
<h3 id="肩肌"><a href="#肩肌" class="headerlink" title="肩肌"></a>肩肌</h3><p>上肢带肌配布于肩关节周围，均起自上肢带骨，止于肱骨，能运动肩关节并能增强关节的稳固性。肩关节盂浅头大，关节囊松弛，其稳固性主要依靠周围肌腱来维持。<strong>肩胛下肌、冈上肌、冈下肌、小圆肌腱</strong>分别止于肩关节的前方、上方、后方，腱纤维与关节囊纤维相交织，形成“<strong>肌腱袖</strong>”。这些肌虽有运动肩关节的功能，但距肩关节很近，作用力量不大。但这些肌收缩时，可保持肱骨头与关节盂相接触，从而<strong>加强肩关节的稳定性</strong>。此外，三角肌也有保持肩关节稳定的作用。</p>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E8%82%8C%E5%AD%A6/14.png" class title="14.png">
<ul>
<li><strong>三角肌</strong>：三角肌位于肩部，呈三角形。<strong>起自锁骨的外侧段、肩峰和肩胛冈</strong>，与斜方肌的止点对应，肌束逐渐向外下方集中，<strong>止于肱骨体外侧的三角肌粗隆</strong>。肱骨上端由于三角肌的覆盖，使肩部呈圆隆形。腋神经受损可致该肌瘫痪萎缩，使肩峰突出于皮下。作用：外展肩关节，前部肌束可以使肩关节屈和旋内，后部肌束能使肩关节伸和旋外。</li>
<li><strong>冈上肌</strong>：冈上肌位于斜方肌深面，起自肩胛骨的冈上窝，肌束向外经肩峰和喙肩韧带的下方，跨越肩关节，止于肱骨大结节的上部。冈上肌腱与喙肩韧带、肩峰及三角肌之间有一大的肩峰下囊，感染时，外展肩关节引起疼痛,该肌腱也是肩关节周围诸肌腱中最易断裂的肌腱之一。作用使肩关节外展。</li>
<li><strong>冈下肌</strong>：冈下肌位于冈下窝内，肌的一部分被三角肌和斜方肌覆盖。起自冈下窝，肌束向外经肩关节后面，止于肱骨大结节的中部。作用：使肩关节旋外。</li>
<li><strong>小圆肌</strong>：小圆肌位于冈下肌的下方，起自肩胛骨外侧缘背面，止于肱骨大结节的下部。作用：使肩关节旋外。</li>
<li><strong>大圆肌</strong>：大圆肌位于小圆肌的下方，其下缘后面被背阔肌遮盖。该肌起自肩胛骨下角的背面，肌束向上外方或经臂的内侧、肱三头肌长头的前面，止于肱骨小结节嵴。作用：使肩关节收和旋内。</li>
<li><strong>肩胛下肌</strong>：肩胛下肌呈三角形，起自肩胛下窝，肌束向上外经肩关节的前方，止于肱骨小结节。肌腱与肩胛颈之间有一大的与肩关节相通的肩胛下肌腱下囊。作用：使肩关节内收和旋内。</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E8%82%8C%E5%AD%A6/17.png" class title="17.png">
<h3 id="臂肌"><a href="#臂肌" class="headerlink" title="臂肌"></a>臂肌</h3><p>臂肌覆盖肱骨，以内侧和外侧两个肌间隔分隔成前、后两群，<strong>前群为屈肌</strong>，<strong>后群为伸肌</strong>。</p>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E8%82%8C%E5%AD%A6/18.png" class title="18.png">
<p><strong>前群：</strong><br>前群包括浅层的<strong>肱二头肌</strong>和深层的肱肌和喙肱肌。</p>
<ul>
<li><strong>肱二头肌</strong>呈梭形，起端有二个头，<strong>长头以长腱起自肩胛骨盂上结节</strong>，通过肩关节囊，经结节间沟下降；<strong>短头在内侧起自肩胛骨喙突</strong>。两头在臂的下部合并成一个肌腹，向下移行为肌腱，<strong>止于桡骨粗隆</strong>。作用：<strong>屈肘关节</strong>；当前臂在旋前位时，能使其旋后。此外还能协助屈肩关节。</li>
<li><strong>喙肱肌</strong>在肱二头肌短头的后内方，起自肩胛骨喙突，止于肱骨中部的内侧。作用：<strong>协助肩关节屈和内收</strong>。</li>
<li><strong>肱肌</strong>位于肱二头肌的深面，<strong>起自肱骨体下半的前面</strong>，<strong>止于尺骨粗隆</strong>。作用：<strong>屈肘关节</strong>。</li>
</ul>
<p><strong>后群：</strong></p>
<ul>
<li><strong>肱三头肌</strong>起端有三个头，长头以长腱起自<strong>肩胛骨盂下结节</strong>，向下行经大、小圆肌之间；外侧头与内侧头分别起自<strong>肱骨后面桡神经沟的外上方和内下方的骨面</strong>，三个头向下以一坚韧的肌腱止于尺骨鹰嘴。作用：<strong>伸肘关节</strong>，长头还可使肩关节后伸和内收。</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E8%82%8C%E5%AD%A6/19.png" class title="19.png">
<h3 id="前臂肌"><a href="#前臂肌" class="headerlink" title="前臂肌"></a>前臂肌</h3><p>前臂肌位于尺、桡骨的周围，<strong>分为前（屈肌）、后（伸肌）两群。前群</strong>肌主要能够<strong>屈肘、屈腕、屈指、旋前，后群</strong>主要可以<strong>伸肘、伸腕、伸指、旋后</strong>。除了屈、伸肌外，还配布有旋肌，这对于手的灵活运动有重要意义。前臂肌大多数是长肌，肌腹位于近侧，细长的腱位于远侧，所以前臂的上半部膨隆，下半部逐渐变细。</p>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E8%82%8C%E5%AD%A6/20.png" class title="20.png">
<p><strong>前群：</strong><br>前群共9块肌，分四层排列。第一层(浅层)包括肱桡肌、旋前圆肌、桡侧腕屈肌、掌长肌、尺侧腕屈肌，第二层为指浅屈肌，第三层有拇长屈肌和指深屈肌，第四层为旋前方肌。</p>
<ul>
<li><strong>肱桡肌</strong>：起自肱骨外上髁的上方，向下止于桡骨茎突，作用为屈肘关节。肱桡肌位置表浅，有较恒定的血供和神经支配，易于寻找，切除后不影响前臂功能，因此为良好的肌瓣及肌皮瓣移植供体。</li>
<li><strong>旋前圆肌</strong>：止于桡骨外侧面的中部，作用为使前臂旋前、屈肘关节。</li>
<li><strong>桡侧腕屈肌</strong>：以长腱止于第2掌骨底，作用为屈肘、屈腕和使腕外展。</li>
<li><strong>掌长肌</strong>：肌腹很小而腱细长，连于掌腱膜，作用为屈腕和紧张掌腱膜。</li>
<li><strong>尺侧腕屈肌</strong>：止于豌豆骨，作用为屈腕和使腕内收。</li>
<li><strong>指浅屈肌</strong>，肌的上端为浅层肌所覆盖。起自肱骨内上髁、尺骨和桡骨前面，肌束往下移行为四条肌腱，通过腕管和手掌，分别进入第2～5指的屈肌腱鞘，每一个腱分为二脚，止于中节指骨体的两侧。作用：屈近侧指骨间关节、屈掌指关节和屈腕。</li>
<li><strong>拇长屈肌</strong>：位于外侧半，起自桡骨前面和前臂骨间膜，以长腱通过腕管和手掌，止于拇指远节指骨底，作用为屈拇指指骨间关节和掌指关节。</li>
<li><strong>指深屈肌</strong>：位于内侧半，起自尺骨的前面和前臂骨间膜，向下分成四条肌腱，经腕管入手掌，在指浅屈肌腱的深面分别进入第2～5指的屈肌腱鞘，在鞘内穿经指浅屈肌腱二脚之间，止于远节指骨底。作用为屈第2～5指的远侧指骨间关节、近侧指骨间关节、掌指关节和屈腕。</li>
<li><strong>旋前方肌</strong>：方形的小肌，贴在桡、尺骨远端的前面，起自尺骨，止于桡骨。作用为使前臂旋前。</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E8%82%8C%E5%AD%A6/21.png" class title="21.png">
<p><strong>后群</strong><br>共10块肌，分为浅、深两层排列。浅层有5块肌，以一个共同的腱即伸肌总腱 ，起自肱骨外上髁以及邻近的深筋膜；深层也有5块肌，分别为旋后肌、拇长展肌、拇短伸肌、拇长伸肌、示指伸肌。各肌的作用同其名。</p>
<ul>
<li><strong>桡侧腕长伸肌</strong>向下以其长腱至手背，止于第2掌骨底。作用主要为伸腕，还可使腕外展。</li>
<li><strong>桡侧腕短伸肌</strong> 在桡侧腕长伸肌的后内侧，止于第3掌骨底。作用为伸腕、腕外展。</li>
<li><strong>指伸肌</strong>：肌腹向下移行为四条肌腱，经手背，分别到2～5指。在手背远侧部，掌骨头附近，四条腱之间有腱间结合相连，各腱到达指背时向两侧扩展为扁的腱膜，称指背腱膜，止于中节和远节指骨底。作用为伸指和伸腕。</li>
<li><strong>小指伸肌</strong>：是一条细长的肌，附于指伸肌内侧，肌腱移行为指背腱膜，止于小指中节和远节指骨底。作用为伸小指。</li>
<li><strong>尺侧腕伸肌</strong>止于第5掌骨底，作用为伸腕，使腕内收。</li>
<li><strong>旋后肌</strong>位置较深，起自尺骨近侧，肌纤维斜向下外并向前包绕桡骨，止于桡骨上1/3的前面。作用为使前臂旋后。其余4肌皆起自桡、尺骨和骨间膜的背面。</li>
<li><strong>拇长展肌</strong>止于第1掌骨底。</li>
<li><strong>拇短伸肌</strong>止于拇指近节指骨底。</li>
<li><strong>拇长伸肌</strong>止于拇指远节指骨底。</li>
<li><strong>示指伸肌</strong>止于示指的指背腱膜。</li>
</ul>
<p><strong>腕部表浅肌腱</strong>：</p>
<ul>
<li>当用手握拳时，在腕部前面中分，可以看到三个隆起的肌腱，位于中间的隆起最高的为<strong>掌长肌肌腱</strong>，位于桡侧的为<strong>桡侧腕屈肌肌腱</strong>，位于尺侧的为<strong>尺侧腕屈肌肌腱</strong>。桡侧腕屈肌肌腱的桡侧可以触及<strong>桡动脉</strong>的搏动。</li>
<li>在腕背侧面，当拇指伸直外展时，自桡侧向尺侧可见<strong>拇长展肌</strong>、<strong>拇短伸肌</strong>和<strong>拇长伸肌肌腱</strong>，在后二肌腱之间有深的凹陷，称<strong>鼻烟窝</strong>。窝内有<strong>桡动脉分支</strong>通过。</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E8%82%8C%E5%AD%A6/22.png" class title="22.png">
<h3 id="手肌"><a href="#手肌" class="headerlink" title="手肌"></a>手肌</h3><p>手的固有肌位于手的掌侧，全是短小的肌肉，其作用为运动手指。人类手指灵巧，除可做屈、伸、收、展的动作外，还有对掌运动；为了完成这些运动，也配布了相应的肌。手肌分为<strong>外侧、中间和内侧三群</strong>。</p>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E8%82%8C%E5%AD%A6/23.png" class title="23.png">
<p><strong>外侧群</strong><br>外侧群较为发达，在手掌拇指侧形成一隆起，称<strong>鱼际</strong>，有4块肌，分浅、深两层排列。4块肌肉作用可使拇指作展、屈、对掌和收等动作。</p>
<ul>
<li>拇短展肌位于浅层外侧。</li>
<li>拇短屈肌位于浅层内侧。</li>
<li>拇对掌肌位于拇短展肌的深面。</li>
<li>拇收肌位于拇对掌肌的内侧。</li>
</ul>
<p><strong>内侧群</strong><br>在手掌小指侧，形成一隆起称<strong>小鱼际</strong>，有3块肌，也分浅、深两层排列。上述3肌分别使小指作外展、屈和对掌等动作。</p>
<ul>
<li>小指展肌位于浅层内侧。</li>
<li>小指短屈肌位于浅层外侧。</li>
<li>小指对掌肌位于上述两肌深面。</li>
</ul>
<p><strong>中间群</strong><br>位于掌心，包括<strong>蚓状肌</strong>和<strong>骨间肌</strong>。由于骨间肌也绕至第2～5指背面，止于指背腱膜，故能协同蚓状肌屈掌指关节、伸指骨间关节。</p>
<ul>
<li><strong>蚓状肌</strong>为4条细束状小肌，起自指深屈肌腱桡侧，经掌指关节桡侧至第2～5指的背面，止于指背腱膜。作用为屈掌指关节、伸指骨间关节。</li>
<li><strong>骨间掌侧肌</strong>3块，位于2～5掌骨间隙内，起自掌骨，分别经第2指的尺侧，第4～5指的桡侧，止于第2、4、5指的指背腱膜。作用为使第2、4、5指向中指靠拢（内收）。</li>
<li><strong>骨间背侧肌</strong>4块，位于4个掌骨间隙的背侧，各有两头起自相邻骨面，止于第2指的桡侧、第3指的桡侧及尺侧、第4指尺侧的指背腱膜。作用：以中指为中心能展第2、3、4指。</li>
</ul>
<h2 id="下肢肌"><a href="#下肢肌" class="headerlink" title="下肢肌"></a>下肢肌</h2><p>下肢肌可分为<strong>髋肌</strong>、<strong>大腿肌</strong>、<strong>小腿肌</strong>和<strong>足肌</strong>。由于下肢功能主要是维持直立姿势、支持体重和行走，故下肢肌比上肢肌粗壮。  </p>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E8%82%8C%E5%AD%A6/25.png" class title="25.png">
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E8%82%8C%E5%AD%A6/26.png" class title="26.png">
<h3 id="髋肌"><a href="#髋肌" class="headerlink" title="髋肌"></a>髋肌</h3><p>髋肌又叫盆带肌，主要起自骨盆的内面和外面，跨过髋关节，止于股骨上部，主要运动髋关节。按其所在的部位和作用，可<strong>分为前、后两群</strong>。</p>
<p><strong>前群</strong>：前群有3块肌。</p>
<ul>
<li><strong>髂腰肌</strong>由<strong>腰大肌</strong>和<strong>髂肌</strong>组成。<strong>腰大肌起自腰椎体侧面和横突</strong>；<strong>髂肌</strong>呈扇形，位于腰大肌的外侧，<strong>起自髂窝</strong>。两肌向下会合，经腹股沟韧带深面，<strong>止于股骨小转子</strong>。髂腰肌与髋关节囊之间有一很大的滑膜囊，常与髋关节囊相通，故髋关节囊感染时其脓液可流入此囊。作用：<strong>使髋关节屈和旋外</strong>。下肢固定时，可使躯干屈，如仰卧起坐。</li>
<li><strong>阔筋膜张肌</strong>位于大腿上部前外侧，起自髂前上棘，肌腹在阔筋膜两层之间，向下移行于髂胫束，止于胫骨外侧髁。作用：使阔筋膜紧张并<strong>屈髋</strong>。</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E8%82%8C%E5%AD%A6/27.png" class title="27.png">
<p><strong>后群</strong>：后群肌主要位于臀部，故又称臀肌，有7块。浅层有臀大肌、臀中肌、臀小肌。</p>
<ul>
<li><strong>臀大肌</strong>位于臀部浅层、大而肥厚，<strong>形成特有的臀部隆起</strong>，覆盖臀中肌下半部及其它小肌，<strong>起自髂骨翼外面和骶骨背面</strong>，肌束斜向下外，<strong>止于髂胫束和股骨的臀肌粗隆</strong>。作用：<strong>使髋关节伸和旋外</strong>。下肢固定时，能伸直躯干，防止躯干前倾，是<strong>维持人体直立的重要肌肉</strong>。</li>
<li><strong>臀中肌</strong>前上部位于皮下，后下部位于臀大肌的深面。</li>
<li><strong>臀小肌</strong>位于臀中肌的深面。两肌都呈扇形，皆起自髂骨翼外面，肌束向下集中形成短腱，止于股骨大转子。作用：二肌作用相同，<strong>使髋关节外展，前部肌束能使髋关节旋内，后部肌束则使髋关节旋外。</strong></li>
<li><strong>梨状肌</strong>起自盆内骶骨前面，纤维向外出坐骨大孔达臀部，止于股骨大转子。作用：<strong>使髋关节外展和旋外</strong>。</li>
<li><strong>闭孔内肌</strong>起自闭孔膜内面及其周围骨面，肌束向后集中成为肌腱，由坐骨小孔出骨盆转折向外，止于转子窝。此肌腱上下各有一块小肌，分别称做上孖肌、下孖肌，与闭孔内肌一起止于转子窝。闭孔内肌腱绕坐骨小切迹处，有一恒定的闭孔内肌腱下囊。该肌<strong>使髋关节旋外</strong>。</li>
<li><strong>股方肌</strong>起自坐骨结节，向外止于转子间嵴。作用：<strong>使髋关节旋外</strong>。</li>
<li><strong>闭孔外肌</strong>在股方肌深面，起自闭孔膜外面及其周围骨面，经股骨颈的后方，止于转子窝。作用：<strong>使髋关节旋外</strong>。</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E8%82%8C%E5%AD%A6/29.png" class title="29.png">
<h3 id="大腿肌"><a href="#大腿肌" class="headerlink" title="大腿肌"></a>大腿肌</h3><p>大腿肌分为<strong>前群</strong>、<strong>后群</strong>和<strong>内侧群</strong>。<br><strong>前群</strong></p>
<ul>
<li><strong>缝匠肌</strong>是全身<strong>最长的肌</strong>，呈扁带状，<strong>起于髂前上棘</strong>，经大腿的前面，斜向下内，<strong>止于胫骨上端的内侧面</strong>。作用：屈髋和屈膝关节，并使已屈的膝关节旋内。</li>
<li><strong>股四头肌</strong>是全身<strong>最大的肌</strong>，有四个头，即<strong>股直肌</strong>、<strong>股内侧肌</strong>、<strong>股外侧肌</strong>和<strong>股中间肌</strong>。<strong>股直肌起自髂前下棘；股内侧肌和股外侧肌分别起自股骨粗线内、外侧唇；股中间肌位于股直肌的深面，在股内、外侧肌之间，起自股骨体的前面</strong>。<strong>四个头向下形成一腱</strong>，<strong>包绕髌骨的前面和两侧，向下续为髌韧带，止于胫骨粗隆。</strong>作用：是<strong>膝关节强有力的伸肌</strong>，<strong>股直肌还可屈髋关节</strong>。</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E8%82%8C%E5%AD%A6/30.png" class title="30.png">
<p><strong>后群</strong><br>后群有<strong>股二头肌、半腱肌、半膜肌</strong>，均起自坐骨结节，跨越髋、膝两个关节，常称之为“<strong>腘绳肌</strong>”。作用：后群3块肌可以<strong>屈膝关节、伸髋关节</strong>。屈膝时股二头肌可以使小腿旋外，而半腱肌和半膜肌使小腿旋内。</p>
<ul>
<li><strong>股二头肌</strong>位于股后部的外侧，有长、短两个头，长头起自坐骨结节，短头起自股骨粗线，两头会合后，以长腱止于腓骨头。</li>
<li><strong>半腱肌</strong>位于股后部的内侧，肌腱细长，几乎占肌的一半，止于胫骨上端的内侧。半腱肌亦是一块适合作转移肌瓣或肌皮瓣的良好供肌，临床常用来覆盖修补坐骨部褥疮或外伤缺损。</li>
<li><strong>半膜肌</strong>在半腱肌的深面，上部是扁薄的腱膜，几乎占肌的一半，肌的下端以腱止于胫骨内侧髁的后面。</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E8%82%8C%E5%AD%A6/31.png" class title="31.png">
<p><strong>内侧群</strong><br>内侧群共有5块肌，位于大腿的内侧，均起自闭孔周围的耻骨支、坐骨支和坐骨结节等骨面，分层排列。除股薄肌止于胫骨上端的内侧以外，其它各肌都止于股骨粗线，大收肌还有一个腱止于股骨内上髁上方的收肌结节，此腱与股骨之间形成一裂孔，称为<strong>收肌腱裂孔</strong>，有股血管通过。作用：<strong>主要使髋关节内收</strong>。</p>
<ul>
<li><strong>耻骨肌</strong>为长方形的短肌，髂腰肌的内侧。</li>
<li><strong>长收肌</strong>三角形，耻骨肌的内侧。</li>
<li><strong>股簿肌</strong>长条肌，在最内侧。</li>
<li><strong>短收肌</strong>近似三角形的扁肌，在耻骨肌和长收肌的深面。</li>
<li><strong>大收肌</strong>在上述肌的深面，大而厚，呈三角形。</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E8%82%8C%E5%AD%A6/32.png" class title="32.png">
<h3 id="小腿肌"><a href="#小腿肌" class="headerlink" title="小腿肌"></a>小腿肌</h3><p>小腿肌可分为三群：<strong>前群</strong>在小腿骨间膜的前面，<strong>后群</strong>在小腿骨间膜的后面，<strong>外侧群</strong>在腓骨的外侧面。<strong>小腿肌的后群强大，与行走或跑时足的跖屈动作、产生巨大推动力以及维持人体直立姿势有关</strong>。因小腿旋转机能甚微，故缺乏回旋肌，其旋转机能来自大腿肌。另外，小腿肌的分化程度不如前臂，所以，肌的数目较前臂为少。 </p>
<p><strong>前群</strong></p>
<ul>
<li><strong>胫骨前肌</strong>起自胫骨外侧面，肌腱向下穿经伸肌上、下支持带的深面，止于内侧楔骨内侧面和第1跖骨底。作用为伸踝关节(背屈)、使足内翻。</li>
<li><strong>趾长伸肌</strong>起自腓骨前面、胫骨上端和小腿骨间膜，向下经伸肌上、下支持带深面至足背分为四个腱到第2～5趾，成为趾背腱膜，止于中节、远节趾骨底。作用为伸踝关节、伸趾。另外，此肌分出一腱，止于第5跖骨底，称第三腓骨肌，仅见于人类，是新发生的肌，可使足外翻。</li>
<li><strong>𧿹长伸肌</strong>位于上述两肌之间，起自腓骨内侧面下2/3和骨间膜，止于𧿹趾远节趾骨底。作用为伸踝关节、伸𧿹趾。</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E8%82%8C%E5%AD%A6/38.png" class title="38.png">
<p><strong>后群</strong><br>小腿后群肌包括浅层和深层，浅层主要是小腿三头肌，包括比目鱼肌和腓肠肌。深层有腘肌、趾长屈肌、𧿹长屈肌和胫骨后肌。</p>
<ul>
<li><strong>小腿三头肌</strong>，浅表的两个头称<strong>腓肠肌</strong>，起自股骨内、外侧髁的后面，内、外侧头会合，约在小腿中点移行为腱性结构；位置较深的一个头是<strong>比目鱼肌</strong>，起自腓骨后面的上部和胫骨的比目鱼肌线，肌束向下移行为肌腱，和腓肠肌的腱合成粗大的跟腱止于跟骨。<strong>腓肠肌在行走、跑、跳中提供推动力</strong>，比目鱼肌富含慢性、抗疲劳的红肌纤维，主要与站立时小腿与足之间的稳定有关。作用：<strong>屈踝关节和屈膝关节</strong>。在站立时，能固定踝关节和膝关节，以防止身体向前倾斜。</li>
<li><strong>腘肌</strong>：斜位于腘窝底，起自股骨外侧髁的外侧部分，止于胫骨的比目肌线以上的骨面。作用：<strong>屈膝关节并使小腿旋内</strong>。</li>
<li><strong>趾长屈肌</strong>：位于胫侧，起自胫骨后面，它的长腱经内踝后方、屈肌支持带深面至足底，然后分为4条肌腱，止于第2～5趾的远节趾骨底。作用：<strong>屈踝关节</strong>和<strong>屈第2～5趾</strong>。</li>
<li><strong>𧿹长屈肌</strong>：起自腓骨后面，长腱经内踝之后、屈肌支持带深面至足底，与趾长屈肌腱交叉，止于足母趾远节趾骨底。作用：<strong>屈踝关节和屈𧿹趾</strong>。</li>
<li><strong>胫骨后肌</strong>：位于趾长屈肌和足母长屈肌之间，起自胫骨、腓骨和小腿骨间膜的后面，长腱经内踝之后、屈肌支持带深面到足底内侧，止于舟骨粗隆和内侧、中间及外侧楔骨。作用：<strong>屈踝关节和使足内翻</strong>。</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E8%82%8C%E5%AD%A6/39.png" class title="39.png">
<p><strong>外侧群</strong></p>
<ul>
<li>外侧群有<strong>腓骨长肌</strong>和<strong>腓骨短肌</strong>，两肌皆起自腓骨外侧面，长肌起点较高，并掩盖短肌。两肌的腱均经外踝后方转向前，通过腓骨肌上、下支持带的深面，腓骨短肌腱向前止于第5跖骨粗隆，腓骨长肌腱绕至足底，斜行向足内侧，止于内侧楔骨和第l跖骨底。作用：<strong>使足外翻和屈踝关节</strong>(跖屈)。此外，腓骨长肌腱和胫骨前肌腱共同形成“腱环”，对维持足横弓、调节足的内翻、外翻有重要作用。</li>
</ul>
<img src="/2022/02/02/1-Course/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%89%96%E5%AD%A6/%E4%BA%BA%E4%BD%93%E8%A7%A3%E5%89%96%E5%AD%A6-%E8%82%8C%E5%AD%A6/40.png" class title="40.png">]]></content>
      <categories>
        <category>biomechanics</category>
      </categories>
      <tags>
        <tag>人体解剖学</tag>
      </tags>
  </entry>
  <entry>
    <title>Matlab Signal Analyzer 信号分析</title>
    <url>/2021/10/08/4-Tutorials/Software/Matlab%20Signal%20Analyzer/</url>
    <content><![CDATA[<p>以跑台地反力为案列，介绍Matlab信号分析工具箱Signal Analyzer的基本使用<br><img src="/2021/10/08/4-Tutorials/Software/Matlab%20Signal%20Analyzer/6.png" class title="Untitled"></p>
<span id="more"></span>
<blockquote>
<p>参考资料：</p>
<p><a href="https://zhuanlan.zhihu.com/p/19763358">傅里叶分析之掐死教程（完整版）更新于2014.06.06</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/34989414">信号频域分析方法的理解（频谱、能量谱、功率谱、倒频谱、小波分析）</a></p>
<p><a href="https://www.zhihu.com/question/22864189/answer/40772083">如何通俗地讲解傅立叶分析和小波分析间的关系？</a></p>
</blockquote>
<h2 id="1-数据导入"><a href="#1-数据导入" class="headerlink" title="1-数据导入"></a>1-数据导入</h2><h3 id="加载数据，设置采样频率和开始时间"><a href="#加载数据，设置采样频率和开始时间" class="headerlink" title="加载数据，设置采样频率和开始时间"></a>加载数据，设置采样频率和开始时间</h3><img src="/2021/10/08/4-Tutorials/Software/Matlab%20Signal%20Analyzer/1.png" class title="截屏2021-10-20 下午7.34.59.png">
<p><img src="/2021/10/08/4-Tutorials/Software/Matlab%20Signal%20Analyzer/2.png" alt="截屏2021-10-20 下午7.35.16.png"></p>

<h2 id="功率谱分析"><a href="#功率谱分析" class="headerlink" title="功率谱分析"></a>功率谱分析</h2><blockquote>
<p><strong>频谱与功率谱密度：</strong></p>
<ul>
<li>根据信号的性质可分为确定信号和随机信号，确定信号又分为能量信号和功率信号，而随机信号只有功率信号；</li>
<li>只有能量信号才可以进行FFT得到频谱，功率信号不满足FFT的假设条件，只能进行功率谱分析（或着对信号进行有限截断进行FFT）；</li>
<li>对于确定信号而言功率谱可以简单看作是频谱模的平方（功率谱没有相频概念），对随机信号而言，可以看作是多次平均；</li>
</ul>
</blockquote>
<h3 id="进行功率分析"><a href="#进行功率分析" class="headerlink" title="进行功率分析"></a>进行功率分析</h3><img src="/2021/10/08/4-Tutorials/Software/Matlab%20Signal%20Analyzer/3.png" class title="Untitled">
<h3 id="设置坐标轴显示范围，以及其他参数"><a href="#设置坐标轴显示范围，以及其他参数" class="headerlink" title="设置坐标轴显示范围，以及其他参数"></a>设置坐标轴显示范围，以及其他参数</h3><img src="/2021/10/08/4-Tutorials/Software/Matlab%20Signal%20Analyzer/4.png" class title="Untitled">
<h2 id="3-数据平滑和滤波"><a href="#3-数据平滑和滤波" class="headerlink" title="3-数据平滑和滤波"></a>3-数据平滑和滤波</h2><h3 id="拷贝原始数据到新的变量，并进行滑动均值滤波"><a href="#拷贝原始数据到新的变量，并进行滑动均值滤波" class="headerlink" title="拷贝原始数据到新的变量，并进行滑动均值滤波"></a>拷贝原始数据到新的变量，并进行滑动均值滤波</h3><img src="/2021/10/08/4-Tutorials/Software/Matlab%20Signal%20Analyzer/5.png" class title="Untitled">
<img src="/2021/10/08/4-Tutorials/Software/Matlab%20Signal%20Analyzer/6.png" class title="Untitled">
<h3 id="拷贝原始数据到新的变量，并进行低通滤波"><a href="#拷贝原始数据到新的变量，并进行低通滤波" class="headerlink" title="拷贝原始数据到新的变量，并进行低通滤波"></a>拷贝原始数据到新的变量，并进行低通滤波</h3><img src="/2021/10/08/4-Tutorials/Software/Matlab%20Signal%20Analyzer/7.png" class title="Untitled">
<img src="/2021/10/08/4-Tutorials/Software/Matlab%20Signal%20Analyzer/8.png" class title="Untitled">
]]></content>
      <categories>
        <category>tutorials</category>
      </categories>
      <tags>
        <tag>Matlab</tag>
        <tag>信号分析</tag>
      </tags>
  </entry>
  <entry>
    <title>英语语法 1 - 名词</title>
    <url>/2022/01/10/1-Course/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/01-%E5%90%8D%E8%AF%8D/</url>
    <content><![CDATA[<img src="/2022/01/10/1-Course/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/01-%E5%90%8D%E8%AF%8D/image-20220912230300280.png" class title="image-20220912230300280">
<span id="more"></span>
<p>定义：用来表示人、事物、地点以及抽象事物的名称</p>
<p>名词短语：名词与它的修饰词一起构成名词短语，用来修饰名词的词称为定语</p>
<ul>
<li>组成规律：左二右六 - 限定词 + 形容词 + 中心名词 + 六类后置定语（介词短语、分词短语、不定式短语、形容词短语、定语从句、同位语从句）</li>
</ul>
<h2 id="1-1-名词的分类："><a href="#1-1-名词的分类：" class="headerlink" title="1.1 名词的分类："></a>1.1 名词的分类：</h2><h3 id="专有名词"><a href="#专有名词" class="headerlink" title="专有名词"></a>专有名词</h3><p>表示特定的人、物、机构、场所的名词，<strong>首字母必须大写</strong>。如Pairs, the United State</p>
<ul>
<li>1.人名与头衔，Winston Churchill, the Queen of the England, the Persident of the United States, Doctor Mathews, Professor Samuels</li>
<li>2.著作名称，War and Peace, Pride and Prejudice</li>
<li>3.月份，January, February, March, April, May, June, July, August, September, October, November, December</li>
<li>4.星期、四季，Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, winter, sunmer, spring, autumn</li>
<li>5.节日，Christmas, Easter, New Year’s Day</li>
<li>6.地理名称<ul>
<li>国家及大洲的名称，America, Africa, Europe, Asia, England, Scotland, China, Peru, Albania</li>
<li>地区城市的名称，Rome, Vancouver, Beijing, Florence, California, Florida</li>
<li>江河湖的名称，the Atlantic, the Pacific, the Dead Sea, Lake Victoria, the Rhine, the Thames, the Nile</li>
<li>山脉、沙漠，the Himalayas, the Alps, the Sahara</li>
</ul>
</li>
</ul>
<h3 id="普通名词"><a href="#普通名词" class="headerlink" title="普通名词"></a>普通名词</h3><ul>
<li>可数名词<ul>
<li>个体名词：表示同类的人或物中的个体 。student，tree</li>
<li>集体名词：表示若干人或物的总称。team，committee</li>
</ul>
</li>
<li>不可数名词<ul>
<li>物质名词：表示物质和材料的的总称。paper，water</li>
<li>抽象名词：表示动作、性质、状态或情感等抽象名词。happiness，evolution，imagination</li>
</ul>
</li>
</ul>
<hr>
<h2 id="1-2-可数名词与不可数名词"><a href="#1-2-可数名词与不可数名词" class="headerlink" title="1.2 可数名词与不可数名词"></a>1.2 可数名词与不可数名词</h2><h3 id="五类不可数名词【U】"><a href="#五类不可数名词【U】" class="headerlink" title="五类不可数名词【U】"></a>五类不可数名词【U】</h3><ul>
<li><p>Group A - 无法分隔的物质名词</p>
  <img src="/2022/01/10/1-Course/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/01-%E5%90%8D%E8%AF%8D/0.png" class title="Untitled">
</li>
<li><p>Group B - 组成成分较小的物质</p>
  <img src="/2022/01/10/1-Course/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/01-%E5%90%8D%E8%AF%8D/1.png" class title="Untitled">
</li>
<li><p>Group C - 表总称的名词（总称不可数，而总称概念下的具体事物是可数的）</p>
  <img src="/2022/01/10/1-Course/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/01-%E5%90%8D%E8%AF%8D/2.png" class title="Untitled">
<ul>
<li><p><strong>一些容易混淆的总称名词</strong></p>
<img src="/2022/01/10/1-Course/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/01-%E5%90%8D%E8%AF%8D/3.png" class title="Untitled">
<p>上面的左边一栏表示总称含义时，均为不可数名词，没有复数形式。</p>
<p>以character为例，当其表示总称时，含义为the combination of qualities or features that distinguish one person, group, or thing from others，如 a man of character ；</p>
<p>当其作为可数名词的时候，表示方块字，如a Chinese charater; </p>
<p><strong>当要表示具体的、可数的特点的时候</strong>，需要用characteristics，如the socialism with Chinese characteristics.</p>
</li>
</ul>
</li>
<li><p>Group D - 抽象名词</p>
  <img src="/2022/01/10/1-Course/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/01-%E5%90%8D%E8%AF%8D/4.png" class title="Untitled">
</li>
<li><p>Group E - 表示学科的词</p>
  <img src="/2022/01/10/1-Course/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/01-%E5%90%8D%E8%AF%8D/5.png" class title="Untitled">
</li>
</ul>
<h3 id="可数不可数的相对论"><a href="#可数不可数的相对论" class="headerlink" title="可数不可数的相对论"></a>可数不可数的相对论</h3><p>一个名词是可数还是不可数关键在于它所表达的意思，而意义又随语境的不同而改变，因此名词的可数性是与它所使用的上下文语境密切相关的，不可数名词可能会可数化，可数名词可能会变为不可数名词。这种转变有如下几种规律：</p>
<ul>
<li>规律一 - 物质名词或总称名词，若表示不同的种类，或有特定的意思，或是液体表示几杯、几瓶的数量，则可转化为不可数名词<ul>
<li>Would you like a cake? No, I don’t like cake.</li>
<li>Two beers and three coffee, please.!</li>
<li>He broke a glass.</li>
<li>The waters of the Eat Sea.</li>
</ul>
</li>
<li>规律二 - 对于抽象名词，具体化时可以转化为可数名词; 可数名词抽象化时可以变为不可数名词<ul>
<li>Knitting is an art.</li>
<li>She was a beauty in her youth.</li>
<li>There’s plenty of room for everyone to sit down in this room.</li>
<li>I pronounce this couple to be husband and wife.</li>
</ul>
</li>
<li><strong>总结：总的来说，当一个名词表示抽象的、总称的概念时，一般作为不可数名词；而当表示具体的、特定的事物时，则通常作为可数名词</strong></li>
</ul>
<h3 id="不可数名词的度量"><a href="#不可数名词的度量" class="headerlink" title="不可数名词的度量"></a>不可数名词的度量</h3><p>不可数名词不能被a(an)修饰，不能被基数词修饰，但可以用<strong>量词</strong>来表示其量的概念：</p>
<ul>
<li>常用piece来修饰一下的抽象名词和物质名词 - advice, bread, baggage, chalk, equipment, furniture, information, jewelry, luggage, music, news<ul>
<li>a piece of news</li>
<li>several pieces of furniture</li>
</ul>
</li>
<li>用bottle, cup, drop, glass修饰液态物质<ul>
<li>several drops of blood</li>
<li>a glass of milk</li>
<li>two cups of coffee</li>
</ul>
</li>
<li>其他量词<ul>
<li>a loaf of bread</li>
<li>a slice of meat</li>
</ul>
</li>
</ul>
<hr>
<h2 id="1-3-可数名词的单复数"><a href="#1-3-可数名词的单复数" class="headerlink" title="1.3 可数名词的单复数"></a>1.3 可数名词的单复数</h2><h3 id="名词的单复数"><a href="#名词的单复数" class="headerlink" title="名词的单复数"></a>名词的单复数</h3><ul>
<li>单数(sg.)与复数(pl.)<ul>
<li>英文中对一以上的数量视为复数，如one half day, one and a half days，可数名词在复数下一般需要变换形式；当然英文也有双数的概念，如both, either, neither只能用来表示两者，不能用于两者以上的复数；each可以表示两者及以上，而every只能用于三者及以上，因此只能说each sex，不能说every sex。双数和三数与复数没有关系，因此我们把数分为单数、复数、单/复数。</li>
</ul>
</li>
<li>只能用作单数的名词<ul>
<li>英语中不可数名词和专有名词只能用作单数，没有复数形式，他们作主语时谓语动词要用单数第三人称形式。</li>
</ul>
</li>
<li>只能用作复数的名词<ul>
<li>二合一的复数名词 - 表示由相等的两部分联系在一起的工具、仪器或服装，描述数量时用pair修饰，用复数的代词代指<ul>
<li>glasses, binocular, scales, clipper, scissors, jeans, shorts, trousers</li>
<li>a pair of glasses, a pair of pants</li>
<li>Where are my glasses? They are right on your nose!</li>
</ul>
</li>
<li>单行复义 - 形式上是单数，但表达复数的含义，往往也有单数的用法<ul>
<li>People - 作人民时，只有复数，作民族、部落时，有复数变化peoples</li>
<li>Cattle - 作牛群只有复数</li>
<li>Police - 通常表示警察部队、警方，为集体名词，个别、具体警官用a police officer, a policeman</li>
<li>Poultry - 作家禽时只能用复数，作家禽的肉时要当作单数名词来用</li>
</ul>
</li>
<li>the + 形容词 - 表示一类人，作复数名词<ul>
<li>The rich are being richer.</li>
</ul>
</li>
<li>复数专有名词<ul>
<li>the Alps, the Himalayas</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="名词的复数化"><a href="#名词的复数化" class="headerlink" title="名词的复数化"></a>名词的复数化</h3><ul>
<li>规则的复数名词<ul>
<li>一般名词在词尾加-s，book/books, hand/hands</li>
<li>以-s, x, -sh, -ch(发/k/时)结尾的名词加-es，classes, boxes, matches, bushes</li>
<li>以-o结尾的名词，有的加-s，有的加-es，tomatoes, heroes, kilos, pianos, photos, memos, bamboos, radios, studios, motto(e)s</li>
<li>辅音-y结尾的名词，变-y为-i加-es，原音+y结尾的名词直接加s，country/countries, baby/babies, plays, boys</li>
<li>以-f, -fe结尾的名词，有的变-v加-es，有的直接加-s，calf/calves, half/halves, life/lives, wife/wives, belifs, chiefs, safes, proofs<ul>
<li>注意：beef(牛肉，不可数)/beefs(牢骚抱怨)/beeves(菜牛)</li>
</ul>
</li>
</ul>
</li>
<li>不规则的复数名词<ul>
<li>以-a结尾的拉丁语名词，词尾变-ae或-as，formula/formulae/formulas</li>
<li>以-ex或-ix结尾的拉丁名词，在词尾直接加-es，或把-ex和-ix变为-ices，index/indexes/indices</li>
<li>以-is结尾的希腊语名词，变-is为-es，analysis/analyses, basis/bases, crisis/crises, diagnosis/diagnoses, thesis/theses</li>
<li>以-on或-um结尾的名词，变-on或-um为-a，有的可以直接加-s，criterion/criteria/criterions, datum/data, erratum/errata, medium/midia/mediums, phenomenon/phenomena</li>
<li>变-oo-为-ee-，foot/feet, tooth/teeth, goose/geese</li>
<li>变-ouse为-ice，mouse/mice, louse/lice</li>
<li>以-us结尾的拉丁语名词，变-us为-i，有的可以直接加-es，genius/genii/geniuses, nucleus/nuclei/nucleuses, stimulus/stimuli</li>
</ul>
</li>
<li>复合名词变复数<ul>
<li>man/woman + 名词构成的复合名词，两个词需均变复数，man treacher/men teachers, woman journalist/women journalists</li>
<li>以-man/-woman/-child结尾的复合名词，将-man/-woman/-child变为复数，fireman/fireman, grandchild/grandchildren policeman/policemen</li>
<li>名词+介词/介词短语构成的符合名词，将主体名词变复数，passer-by/passers-by, comrade-in-arms/comrades-in-arms, looker-on/lookers-on</li>
<li>名词+形容词构成的复合名词，变名词为复数，Attorney General/Attoneys Gernal, consul general/consuls general</li>
<li>由短语动词演变的复合名词，直接在词尾加-s，forget-me-not/forget-me-nots, take-off/take-offs, stand-by/stand-bys, grown-up/grown-ups</li>
</ul>
</li>
<li>单复数同形的名词<ul>
<li>动物名词，sheep, deer, salmon, fish, flounder</li>
<li>国籍名词，Chinese, Japanese, British, Swiss</li>
</ul>
</li>
<li>三类没有形式变化的名词<ul>
<li>不可数名词，没有词形变化，只能用单数，如music</li>
<li>复数可数名词，没有词形变化，只能用复数，如people</li>
<li>单复数同形的名词，没有词形变化，但有单复数之分，如sheep</li>
</ul>
</li>
<li>有新词义的复数名词<ul>
<li>arm(手臂)/arms(武器，军事), custom(风俗)/customs(海关), damage(损坏)/damages(赔偿金), letter(信)/letters(文学)</li>
</ul>
</li>
</ul>
<hr>
<h2 id="1-4-名词的所有格"><a href="#1-4-名词的所有格" class="headerlink" title="1.4 名词的所有格"></a>1.4 名词的所有格</h2><h3 id="‘s-所有格"><a href="#‘s-所有格" class="headerlink" title="‘s 所有格"></a>‘s 所有格</h3><ul>
<li>‘s 所有格的构成：名词所有格’s主要用来表示有生命的名词的所属关系，通常用在姓名、人称、不定代词、集体名词和高等动物等名词的后面<ul>
<li>单数名词，直接在词尾加’s，a woman’s intuition, the actress’s boyfriend</li>
<li>复数名词，不以-s或-es结尾的在词尾加’s，否则在词尾加’s，the Children’s Day, her friends’ money</li>
<li>复合名词，在最后一个词的词尾加’s，my father-in-law’s company, the Persident of America’s secretary</li>
<li>由and连接的并列名词，当表示共有含义时，在最后一个名词词尾加’s；当表示各自所有含义时，需在每个名词词尾加’s<ul>
<li>John and his wife’s bank savings. 约翰和他妻子的共有存款</li>
<li>John’s and his wife’s bank savings. 约翰和他妻子各自的存款</li>
</ul>
</li>
</ul>
</li>
<li>‘s所有格的逻辑关系<ul>
<li>所属关系，某人拥有某物，或某物属于某一类人，my sister’s boyfriend, women’s wear</li>
<li>主谓关系，the visitor’s departure = the visitor departed, Britain’s decision = Britain decided</li>
<li>动宾关系，the children’s education = educated the children, the boy’s punishment = punishd the boy</li>
<li>同位关系，Bhutoo’s loss</li>
<li>表时间或距离，tomorrow’s weather, a month’s salary, three hours’ delay,</li>
<li>表度量，two pounds’ weight, ten dollars’ worth of meat</li>
</ul>
</li>
<li><strong>‘s所有格修饰的名词被省略</strong><ul>
<li><strong>避免名词重复</strong>：若名词所有格所修饰的名词已经出现过，则第二次出现的所有格后面的名词可被省略，This bike is mine, not Mahael’s.</li>
<li>表示店铺或教堂，一般要在所有格名词前面加the，at the chemist’s = at the chemist’s shop</li>
<li>表示某人的住宅，人名后的所有格省略名词，表示某人的住宅，go to my sister’s = go to my sister’s home</li>
</ul>
</li>
</ul>
<h3 id="of-属格"><a href="#of-属格" class="headerlink" title="of 属格"></a>of 属格</h3><ul>
<li>of 属格的构成：N1+of+N2，<strong>一般表示无生命物体名词的所有关系，或有生命名词后接短语或从句修饰的属格</strong>（定语后置，方便修饰）<ul>
<li>表示无生命物体名词的所有关系，The name of the song.</li>
<li>有生命名词后接短语或从句修饰的属格，What’s the name of the boy sitting next to her?</li>
</ul>
</li>
<li><p>of属格的逻辑关系（常用）</p>
<ul>
<li>主谓关系，从右向左翻译，the arrival of the train, the growth of agriculture</li>
<li><p>动宾关系，从左向右翻译，Americia’s invasion of Iraq, a statement of face, the disicission of the plan</p>
<p>  对于及物动词一般按动宾关系理解，不及物动词一般主谓关系理解，而既及物又不及物的动词会出现问题 - the shooting of the rebels</p>
</li>
<li><p>同位关系，两者互为同位说明，the city of Rome, the news of the team’s victory</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>course</category>
      </categories>
      <tags>
        <tag>英语语法</tag>
      </tags>
  </entry>
  <entry>
    <title>英语语法 2 - 限定词</title>
    <url>/2022/01/10/1-Course/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/02-%E9%99%90%E5%AE%9A%E8%AF%8D/</url>
    <content><![CDATA[<img src="/2022/01/10/1-Course/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/02-%E9%99%90%E5%AE%9A%E8%AF%8D/image-20220912230335033.png" class title="image-20220912230335033">
<span id="more"></span>
<hr>
<h2 id="2-1-限定词的分类"><a href="#2-1-限定词的分类" class="headerlink" title="2.1 限定词的分类"></a>2.1 限定词的分类</h2><ul>
<li>冠词：the, an, a</li>
<li>基数词和序数词：one/first, two/second, three/third</li>
<li>指示限定词：this, that, these, those</li>
<li>物主限定词：my, your, his, her, our, their</li>
<li>数量限定词：a few, a little, much, many, a lot of, some, any, enough, several, most, all</li>
<li>个体限定词：each, every, either, neither, both</li>
<li>名词属格：Mary’s, John’s</li>
</ul>
<hr>
<h2 id="2-2-冠词"><a href="#2-2-冠词" class="headerlink" title="2.2 冠词"></a>2.2 冠词</h2><ul>
<li>冠词的位置与读音<ul>
<li>不定冠词：a - 用在以辅音为开头的名词前，an - 用在以元音为开头的名词前，a university, an honor</li>
<li>定冠词：the[ðə] - 用在以辅音为开头的名词前，the[ði] - 用在以元音为开头的名词前</li>
</ul>
</li>
<li>冠词用法要点<ul>
<li>区别不可数名词、单数名词和复数名词，对应不同的冠词搭配方法</li>
<li><strong>区别特指与泛指</strong>，泛指 - 表示一类事物或某类事物的总称，特指 - 表某类事物中的具体某一个或某一些</li>
<li>结合篇章和语境</li>
</ul>
</li>
</ul>
<h3 id="四种泛指表达形式"><a href="#四种泛指表达形式" class="headerlink" title="四种泛指表达形式"></a>四种泛指表达形式</h3><ul>
<li><strong>a/an+单数名词</strong>表泛指，表一类事物中任何一个有代表性的成员，可以用any替换a/an，A child needs plenty of love.</li>
<li>不可数名词不加冠词表泛指，Water is essential for life. Life is hard sometimes. Man(mankind) is social animal.</li>
<li>复数名词不加冠词表泛指，Tigers are becoming almost extinct. Young babies need a lot of sleep.</li>
<li><p><strong>the+单数名词可以</strong>表泛指， 在语气上显得正式或文雅，需结合语境理解，The tiger is becoming almost extinct.</p>
<p>  一般来说the+复数名词表特指，但如下两种情况可以表泛指：</p>
<ul>
<li>the+国籍名词 表示泛指某国、某民族的人，the Chinese, the British</li>
<li>the+形容词 表一类人， the rich, the poor, the wise</li>
</ul>
</li>
</ul>
<h3 id="定冠词the的特指用法"><a href="#定冠词the的特指用法" class="headerlink" title="定冠词the的特指用法"></a>定冠词the的特指用法</h3><p>特指，表根据说话者和听者共有的知识，或根据上下文，可以识别的独特的某物。</p>
<ul>
<li><strong>情景/文化特指</strong><ul>
<li>一般常识，表独一无二的事物，the earth, the universe, the President, the Pope, the Renaissance</li>
<li>注意：一些特殊名词前不加the，nature, socitey, space, man, history</li>
<li>具体知识/局部情景，表小范围内是独一无二的，the church, the library</li>
<li>即时情景用法，表说话时刻双方唯一听到/看到的，The roses are very beautiful. Can you find the page?</li>
</ul>
</li>
<li><p><strong>上下文共指</strong></p>
<ul>
<li><p>直接前指，第一次出现的单数名词用a/an，再次出现用the，即a与the有互指关系，I had a banana. I ate the banana.</p>
<p>  注意：在文学作品中，作者往往在一开头就the，来使读者有身临其境的感觉</p>
</li>
<li><p>间接前指，所指对象间接成为听话者知识的一部分，I went to New York last week. The traffic is awful.</p>
</li>
<li><p>后指/结构特指，被后置定语修饰的名词前面需要用定冠词the，The brick house on the corner is mine.</p>
<p>  注意：并非所有后置定语修饰的名词都需要用the，还要看名词是否表达特指含义</p>
<ul>
<li>A rich person is not one who has the most.</li>
<li>I think he is the one who can help you.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="不定冠词a-an的用法"><a href="#不定冠词a-an的用法" class="headerlink" title="不定冠词a/an的用法"></a>不定冠词a/an的用法</h3><p>不定冠词仅用于限定单数可数名词，通常用于所指事物在前并未提到或说话者/听者对其不熟悉的情况。</p>
<ul>
<li><p><strong>泛指与非泛指用法</strong></p>
<ul>
<li>在主语中，具有泛指功能，表一类事物中任何一个有代表性的成员，A tiger is a dangerous animal.</li>
<li><p>在补足语中，表示分类（职业），具有描述功能，Bill is an engineer.</p>
<p>  注意：若人或物的身份是独一无二的，则不用a/an，二用the，或常常省略冠词</p>
</li>
<li><p>在宾语中，具有所指功能，既可以表示<strong>定指</strong>，也可以表示不定指，需结合语境，I want to read a book.</p>
</li>
<li>总结：<ul>
<li>对于定冠词the，有特指和泛指，主要表特指，次要表泛指</li>
<li>对于不定冠词a/an，不表特指，主要表泛指以及定指/不定指的指代关系</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>不定冠词与不可数名词</strong></p>
<p>  特殊情况下可用不定冠词限定不可数名词</p>
<ul>
<li>a/an+不可数名词，表示一类或一种，This seems to be an excellent oil.</li>
<li>a/an+饮料类不可数名词，表一杯，I’d like a beer, please.</li>
<li>a/an+不可数名词，发生意义改变，a glass(一个玻璃杯), an iron(一个电熨斗)</li>
</ul>
</li>
<li><p><strong>不定冠词与数次one</strong></p>
<p>  <strong>在一些情况下，one可作为a的强调形式来代替a</strong></p>
<ul>
<li>强调数量“一”时用one，表加强语气和强调，David took one mouthful garlic and shot out of the room.</li>
<li>用于准确的对照数字，A hundred grams of flour to one egg.</li>
<li><p>讲故事或经历时用one，强调人或物，One night there is a terrible storm.</p>
<p><strong>在一些情况下不能用one来替换定冠词</strong></p>
</li>
<li><p>表泛指时不能替换，A shoygun is not good.</p>
</li>
<li>表度量时不能替换，The rent is $100 a week.</li>
<li>表数量的固定搭配中的不定冠词不能替换，a few, a little, a number of</li>
</ul>
</li>
<li><p><strong>不定冠词与this</strong></p>
<p>  在口头表述中，当说话者想强调某个人或某件事，并希望它们变得生动时，可以用this取代a（正式场合不能用）</p>
</li>
</ul>
<h3 id="冠词的特殊含义与用法"><a href="#冠词的特殊含义与用法" class="headerlink" title="冠词的特殊含义与用法"></a>冠词的特殊含义与用法</h3><ul>
<li><p><strong>用/不用冠词的有意义区别</strong></p>
<p>  在英文中，有一类表示家居生活和社会事业机构的名词，在有冠词修饰和没有冠词修饰的两种不同情况下，其含义是不同的</p>
<ul>
<li>go to bed(上床睡觉), go to the bed(到床边)</li>
<li>In hospital(住院), in the hosptial(在医院里)</li>
<li>go to sea(出海航行), go to the sea(去海边)</li>
<li>by sea(坐船), by the sea(在海边)</li>
<li>in office(上台执政), in the office(在办公室)</li>
<li>by day(白天), by the day(按天计算)</li>
<li>take place(发生)，take the place(代替)</li>
<li>men of age(成年人), men of an age(同龄人)</li>
<li>out of question(毫无疑问), out of the question(不可能)</li>
</ul>
</li>
<li><strong>其他使用冠词的场合</strong><ul>
<li>形容词或副词最高级、序数词以及only做形容词时，前面需要用the，the only/best way to cope with the problem</li>
<li>乐器、乐团、合唱团体前面加the，the Beatles, play the piano</li>
<li>定冠词the+姓氏s，表示夫妇或一家人，the Smiths</li>
<li>表强调时用the，Just the one.</li>
</ul>
</li>
<li><p><strong>其他不用冠词的场合</strong></p>
<ul>
<li>表示独一无二的职业，且位于补足语（主补、宾补、表语）或同位语位置，He was elected President in 1879.</li>
<li>表示球类、棋类运动项目的名词前面不加冠词，play football, play chess</li>
<li>一些特殊名词在特定泛指含义下不加the，nature, socitey, space, man, history</li>
<li>与当前时间有联系的星期前不加the，on Monday</li>
<li>一般的四季（非特指一段时间）不加the，in spring, Winter is coming.</li>
<li>表昼夜的各段时间dawn, sunrise, sunset, noon, dusk, night, midnight出现在at, by, after, before之后不加冠词，at night</li>
<li><p>一般日常惯例的用餐（非特指）不加冠词，have rice for dinner</p>
<p>  by之后的交通工具不加冠词，by bus, by bicycle, on foot</p>
<p>  by之后的通信工具不加冠词，by radio, by telephone</p>
<p>  平行结构中的名词不加冠词，face to face, back to back, hand in hand</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-3-数量限定词"><a href="#2-3-数量限定词" class="headerlink" title="2.3 数量限定词"></a>2.3 数量限定词</h2><h3 id="a-few-few-a-little-little"><a href="#a-few-few-a-little-little" class="headerlink" title="a few, few, a little, little"></a><strong>a few, few, a little, little</strong></h3><ul>
<li>与名词的搭配关系<ul>
<li>a few, few后面只能接复数名词，a few days</li>
<li>a little, little后面只能接不可数名词，a little water</li>
</ul>
</li>
<li>表达含义<ul>
<li>a few, a little为肯定，表有一些，His theory is difficult, but a few people understand it.</li>
<li>few, little为否定，表很少、几乎没有，His theory is difficult; few people understand it.</li>
</ul>
</li>
<li>与only或very的搭配关系<ul>
<li>only + a few/a little，表仅有</li>
<li>very + few/little，表强调</li>
</ul>
</li>
</ul>
<h3 id="some-any"><a href="#some-any" class="headerlink" title="some/any"></a>some/any</h3><ul>
<li>与名词的搭配关系<ul>
<li>some与any均可以不可数名词及可数名词复数连用，表示一些，I need some medicine.</li>
<li>some一般用于肯定句，any一般用于否定句，I don’t have any friends here.</li>
<li>在疑问句中若期待对方正面的回答或鼓励对方，用some，Would you like to give me some advice?</li>
</ul>
</li>
<li><p>特殊用法</p>
<ul>
<li>any + 单数名词，表任何一个，You can catch any bus.</li>
<li><p>some + 单数名词，表不确定的某一个，Some person at the gate is asking to see you.</p>
<p>  注意：some的这一用法可以表示强烈的感情色彩，往往表示缺乏兴趣，甚至是蔑视的态度</p>
<p>  I don’t want to spend my life in some lonely little village.</p>
</li>
<li><p>some + 数词 + 名词，表大约，暗指是一个给人印象深刻的很大的数字</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-4-个体限定词"><a href="#2-4-个体限定词" class="headerlink" title="2.4 个体限定词"></a>2.4 个体限定词</h2><h3 id="each-every"><a href="#each-every" class="headerlink" title="each/every"></a>each/every</h3><ul>
<li>与名词的搭配关系<ul>
<li>each和every后面都只能接单数可数名词，也因此称为个体限定词，谓语动词需要用第三人称单数</li>
<li>Each boy has a gift. Every man is the master of his own fortune.</li>
</ul>
</li>
<li>each与every的差异<ul>
<li>each可用作代词，every只能作用限定词，Each has a gift.</li>
<li>each表两个或两个以上的事物，every表三个及三个以上的事物，There are a lot of trees on each side of the street.</li>
<li>every可以与数词连用表间隔，each不可以，every two days = every other day</li>
</ul>
</li>
</ul>
<h3 id="anther-other"><a href="#anther-other" class="headerlink" title="anther/other"></a>anther/other</h3><ul>
<li>与名词的搭配关系<ul>
<li>anther只能接单数名词，不能接复数名词或不可数名词，表另一个、再一个，another day</li>
<li>other可以接单数名词、复数名词、不可数名词，表不确定的另外的、其余的人或物，the other boy</li>
</ul>
</li>
<li><p>与数词的搭配关系</p>
<ul>
<li><p>another + 数词 + 复数名词，表在原有基础上的延续，强调数量概念，We will stay here for another three days.</p>
<p>  补充：another + 数词 + 复数名词 = 数词 + more + 复数名词，three more days</p>
</li>
<li><p>数词 + other + 复数名词，表其他的、另外的，强调不同的类别，I am busy from Monday to Thursday, but I can come on three other days.</p>
</li>
</ul>
</li>
<li>Other的其他用法<ul>
<li>other前加其他限定词，some/any/every/enough/one/two/no/many/his/my + other，some other reference books, no other tools</li>
<li>other/others，other只能作限定词，后面必须接名词，others只能作代词，必须单独使用</li>
<li>the other + 名词表示限定范围内的剩下其余的，为确定的，Of all metals, only mercury is liquid and other metals are solid.</li>
</ul>
</li>
</ul>
<h3 id="either-neither"><a href="#either-neither" class="headerlink" title="either/neither"></a>either/neither</h3><ul>
<li>与名词的搭配关系<ul>
<li>两者都与单数名词连用，谓语动词用单数形式，Either day is OK. Neither day is OK.</li>
<li>两者均不能与其他限定词连用</li>
</ul>
</li>
<li>含义比较<ul>
<li>either表示两个中的任一个，或两个中的每一个，either side of the river = both sides of the river</li>
<li>neither只表示两者都不</li>
<li>either … not = neither</li>
</ul>
</li>
<li>用作代词<ul>
<li>either/neither用作代词时，不直接接名词，单独使用或接of短语，Either is OK.</li>
<li>either/neither + of + <strong>限定词</strong> + <strong>名词复数</strong> + 单数谓语动词，Either of the answers is right</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-5-限定词的总结"><a href="#2-5-限定词的总结" class="headerlink" title="2.5 限定词的总结"></a>2.5 限定词的总结</h2><h3 id="限定词中的二和三"><a href="#限定词中的二和三" class="headerlink" title="限定词中的二和三"></a>限定词中的二和三</h3><ul>
<li>都 - both(either)只表示两者都，all表示三者接以上都</li>
<li>都不 - neither表示两者都不，none表示三者及三者以上都不</li>
<li>另一个 - the other表示限定范围内两者中的另一个，通常构成 one … the other；another表示不确定的另一个，必然是指三者及以上的另一个</li>
<li>每一个 - each表示两个以上的每一个，every表示三个以上每一个</li>
</ul>
<h3 id="限定词与可数-不可数名词"><a href="#限定词与可数-不可数名词" class="headerlink" title="限定词与可数/不可数名词"></a>限定词与可数/不可数名词</h3><ul>
<li>只与单数名词搭配的限定词：a, an, each, every, either, neither, another, one</li>
<li>只与复数名词搭配的限定词：both, few, a few, fewer, a number of, many, several, these, those, two以上的基数词</li>
<li>只与不可数名词搭配的限定词：little, a little, less, much, a bit of, a great amount/deal of</li>
<li>可接不可数名词与复数名词的限定词：a lot of, lots of, plenty of, more, most, all</li>
<li>可接单数名词、复数名词与不可数名词的限定词：any, some, no, the, 物主限定词(your, my), 名词属格</li>
</ul>
<h3 id="限定词与of短语"><a href="#限定词与of短语" class="headerlink" title="限定词与of短语"></a>限定词与of短语</h3><p>英文中很多数量限定词和个体限定词可以用作代词，后面可以接of短语，结构一般为</p>
<ul>
<li>数量/个体代词 + of + <strong>特指限定词</strong> + <strong>复数名词或不可数名词</strong><ul>
<li>all/most/some/any of + 特质限定词 + 复数名词或不可数名词</li>
<li>many/a few/few/several/both/two/three of + 特质限定词 + 复数名词</li>
<li>Much/a little/little of + 特质限定词 + 不可数名词</li>
</ul>
</li>
<li>特指限定词只能为如下四类的其中之一，不能没有且不能出现两个<ul>
<li>指示限定词，this, that, these, those</li>
<li>物主限定词，my, your, his, her, its, their, our</li>
<li>名词所有格，Mike’s, Mary’s</li>
<li>定冠词，the</li>
</ul>
</li>
<li>all和both的特殊用法<ul>
<li>All students are smart = All of my students are smart = All my students are smart.</li>
<li>Both students are smart = Both of my students are smart = Both my students are smart.</li>
</ul>
</li>
<li>不定代词与of短语<ul>
<li>不定代词：none, someone, anyone, everyone以及其分开形式no one,</li>
<li>someone, anyone, everyone, no one不能接of短语</li>
<li>some one, any one, every one, none可以接of短语</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-6-限定词之间的位置关系"><a href="#2-6-限定词之间的位置关系" class="headerlink" title="2.6 限定词之间的位置关系"></a>2.6 限定词之间的位置关系</h2><p>根据限定词在名词前的位置，分为<strong>前位限定词 - 中位限定词 - 后位限定词</strong>，all my many friends, both the last students</p>
<ul>
<li>前位限定词 - 说明名词的数量，互相排斥不共存<ul>
<li>表倍数关系的数量限定词，half my salary, twice my salary</li>
<li>表几分之几的限定词，one third my salary</li>
<li>个体限定词，all my salary</li>
</ul>
</li>
<li>中位限定词 - 彼此排斥不共存<ul>
<li>冠词，the</li>
<li>指示限定词，this, that, these, those</li>
<li>物主限定词，my, your, his, her, our, their</li>
<li>名词属格，Tom’s, Jerry’s</li>
</ul>
</li>
<li>后位限定词 - 可以共存<ul>
<li>基数词或序数词，one/first, two/second, three/third, four/fourth</li>
<li>一般序数词，next, last, past, previous, subsequent, other, another</li>
<li>数量限定词，few, many, several, little, less, more</li>
<li>共存顺序：<ul>
<li>序数词/一般序数词 + 基数词/数量限定词，the first two weeks</li>
<li>基数词/数量限定词 + other，two other people</li>
<li>another + 基数词，another ten minutes</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>course</category>
      </categories>
      <tags>
        <tag>英语语法</tag>
      </tags>
  </entry>
  <entry>
    <title>英语语法 4 - 动词</title>
    <url>/2022/01/10/1-Course/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/04-%E5%8A%A8%E8%AF%8D/</url>
    <content><![CDATA[<img src="/2022/01/10/1-Course/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/04-%E5%8A%A8%E8%AF%8D/image-20220912230452661.png" class title="image-20220912230452661">
<span id="more"></span>
<h1 id="Chapter-5-动词（一）：实义动词、助动词与情态动词"><a href="#Chapter-5-动词（一）：实义动词、助动词与情态动词" class="headerlink" title="Chapter 5 动词（一）：实义动词、助动词与情态动词"></a>Chapter 5 动词（一）：实义动词、助动词与情态动词</h1><h2 id="5-1-实义动词-notional-verb"><a href="#5-1-实义动词-notional-verb" class="headerlink" title="5.1 实义动词 notional verb"></a>5.1 实义动词 notional verb</h2><ul>
<li>从词义角度，实义动词具备完整的词汇含义</li>
<li>从谓语角度，只有实义动词能够单独充当句子谓语</li>
</ul>
<h2 id="5-2-助动词-auxiliary-verb"><a href="#5-2-助动词-auxiliary-verb" class="headerlink" title="5.2 助动词 auxiliary verb"></a>5.2 助动词 auxiliary verb</h2><p>be, do, have</p>
<ul>
<li>从词义角度，助动词不具备任何含义</li>
<li><p>从谓语角度，助动词不能单独充当谓语，必须与实义动词连用，帮助构成各种时态、语态</p>
  <img src="/2022/01/10/1-Course/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/04-%E5%8A%A8%E8%AF%8D/1.png" class title="Untitled">
</li>
<li><p>助动词be, do, have也可以用作实义动词</p>
  <img src="/2022/01/10/1-Course/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/04-%E5%8A%A8%E8%AF%8D/2.png" class title="Untitled">
</li>
</ul>
<h2 id="5-3-情态动词-modal-verb"><a href="#5-3-情态动词-modal-verb" class="headerlink" title="5.3 情态动词 modal verb"></a>5.3 情态动词 modal verb</h2><ul>
<li>从词义角度，情态动词具备一定含义，表达可能、建议、愿望、允许、能力、怀疑等，以表示说话者的看法或态度</li>
<li>从谓语角度，情态动词不能单独充当谓语，必须与实义动词连用构成复合谓语</li>
<li>主要的情态动词：can/could, may/might, shall/should, will/would, must, had better, be able to, be going to, ought to, be supposed to, have to, need, dare</li>
</ul>
<h2 id="5-4-陈述句的否定"><a href="#5-4-陈述句的否定" class="headerlink" title="5.4 陈述句的否定"></a>5.4 陈述句的否定</h2><ul>
<li>谓语中含有be动词(实义动词或助动词)或情态动词时，直接在be动词或情态动词后面加not，He is not a teacher. I cannot swim.</li>
<li>谓语动词仅有实义动词，通过do/dose/did + not + 动词原形来表达否定，I do not like English.</li>
<li><p>否定缩写</p>
  <img src="/2022/01/10/1-Course/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/04-%E5%8A%A8%E8%AF%8D/3.png" class title="Untitled">
</li>
</ul>
<h2 id="5-5-一般疑问句"><a href="#5-5-一般疑问句" class="headerlink" title="5.5 一般疑问句"></a>5.5 一般疑问句</h2><ul>
<li>谓语中含有be动词(实义动词或助动词)或情态动词时，直接将其移动到句首，肯定回答用yes，Is he a teacher?</li>
<li>谓语动词是实义动词的一般疑问句，需要把do/does/did放于句首，且谓语动词变为原形，Did he like English?</li>
</ul>
<h2 id="5-6-特殊疑问句"><a href="#5-6-特殊疑问句" class="headerlink" title="5.6 特殊疑问句"></a>5.6 特殊疑问句</h2><p>特殊疑问词 + 一般疑问句 + ？</p>
<ul>
<li>不与名词连用的疑问词，who, what, when, where, how, why, What are you doing?</li>
<li>需与名词连用的疑问词，which, whose, Which one do you like?</li>
<li>how的用法<ul>
<li>单独使用，对动作方式进行提问，How do you go to work?</li>
<li>与形容词或副词连用，How old are you?</li>
<li>对动作发生频率提问，how often, how many times</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>course</category>
      </categories>
      <tags>
        <tag>英语语法</tag>
      </tags>
  </entry>
  <entry>
    <title>英语语法 3 - 形容词</title>
    <url>/2022/01/10/1-Course/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/03-%E5%BD%A2%E5%AE%B9%E8%AF%8D/</url>
    <content><![CDATA[<img src="/2022/01/10/1-Course/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/03-%E5%BD%A2%E5%AE%B9%E8%AF%8D/image-20220912230413676.png" class title="image-20220912230413676">
<span id="more"></span>
<p>形容词是名词短语的最后一个组成成分，用来表示名词的性质和特征。</p>
<h2 id="4-1-形容词在名词短语中的位置"><a href="#4-1-形容词在名词短语中的位置" class="headerlink" title="4.1 形容词在名词短语中的位置"></a>4.1 形容词在名词短语中的位置</h2><ul>
<li><p><strong>前置修饰</strong></p>
<ul>
<li>单个形容词作定语修饰名词，位于名词之前，形式为限定词+形容词+名词，I am reading an interesting book.</li>
<li><p>多个形容词修饰名词时的排序，限定词+观点形容词(beautiful, famous)+尺寸大小+形状+新旧+颜色+国籍/出处/产地+用途+中心名词</p>
<p>  This beautiful, big, old, red, Chinese, wooden table was my grandmother’s.</p>
<p>  The man was carrying a small black plastic bag.</p>
</li>
</ul>
</li>
<li><p><strong>后置修饰</strong></p>
<ul>
<li><strong>形容词+补足语 构成的形容词短语</strong><ul>
<li>形容词+介词短语，a jacket similar to yours.</li>
<li>形容词+不定式短语，parents eager to support their children’s effort</li>
<li>形容词+动名词短语，a waiter busy serving the guests</li>
<li>形容词后接that从句，If a dimond is heated without oxygen, it will turn to graphite, a from of carbon so soft that it is used as a lubricant.</li>
<li>形容词与补足语分隔，Vitamins are organic compounds necessary in small amounts in the diet for the normal growth and maintenance of life.</li>
<li>形容词在名词前，补足语在名词后，a taller man than John.</li>
</ul>
</li>
<li>多个形容词并列 构成的形容词短语<ul>
<li>两个或两个以上的形容词(短语)并列作定语，一般放在修饰名词后面，且用逗号将形容词与句子其他部分分隔开；此时作定语的形容词通常是对所修饰名词的补充性解释或说明<ul>
<li>All countries, large or small, should be equal.</li>
<li>Each person has his or her own purpose and distinct path, unique and separate from anyone else’s.</li>
</ul>
</li>
<li>有时这样的并列形容词短语不是修饰名词，而是修饰整个句子，具有状语的意味<ul>
<li>Flying the F-16 straight and level is easy.</li>
<li>A man approached the official, timid and hesitant.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-2-形容词的比较级和最高级"><a href="#4-2-形容词的比较级和最高级" class="headerlink" title="4.2 形容词的比较级和最高级"></a>4.2 形容词的比较级和最高级</h2><ul>
<li><p>比较级和最高级的构成形式</p>
<p>  一般来说，形容词（副词）具有原级、比较级和最高级的形式，形式的变化方式与形容词的音节数目有关。</p>
<ul>
<li>单音节词<ul>
<li>一般直接在词尾加-er和-est，bright/brighter/brightest, strong/stronger/strongest</li>
<li>以-e结尾的词，直接在词尾加-r和-st，brave/braver/bravest, large/larger/largest</li>
<li>以-y结尾的词变-y为-i，再加-er和-est，shy/shier/shiest</li>
<li>以一个元音+辅音结尾的词，需双写词尾辅音，再加-er和-est，fat/fatter/fattest, sad/sadder/sddest, big/bigger/biggest</li>
</ul>
</li>
<li>双音节词<ul>
<li>以-y结尾的双音节词变-y为-i(不包括副词，如slowly)，再加-er和-est，happy/happier/happiest, silly/sillier/silliest, early/earlier/earliest</li>
<li>大部分双音节词分别在词前加more和most构成比较级，tiring/more tiring/most tiring, slowly/more slowly/most slowly</li>
<li>少数双音节词可以采用两种变化形式，包括common, cruel, friendly, funny, handsome, mature,noisy, pleasant, polite, quiet, stupid, tired, hollow, narrow, shallow, clever, tender, feeble, gentle, noble</li>
</ul>
</li>
<li>多音节词<ul>
<li>三个及三个以上音节的词只能通过more和most来构成比较级和最高级，interesting/more interesting/most interesting, excited, successful</li>
</ul>
</li>
<li>特殊变化形式<ul>
<li>good-well/better/best, bad-ill/worse/worst, far/farther-further/farthest-furthest, old/older-elder/oldest-eldest, little/less/least,</li>
<li>many-much/more/most, late/later-latter/latest-last, up/upper/uppermost-upmost</li>
<li>farther/farthest表实际距离，further/furthest可以表进一步、更深入的，常与抽象名词连用，further discussion, further study</li>
<li>older/oldest表年龄大小，elder/elsest主要表家庭成员之间的长幼关系(一般不接than)，my elder brother</li>
<li>later表时间上的前后，latter表顺序的前后，与former相对；latest表最新的，last表最后一个</li>
</ul>
</li>
<li><p>不具有等级的形容词</p>
<ul>
<li><p><strong>英语中的一小部分词表示绝对含义，因此没有比较级和最高级形式</strong>，包括如下</p>
<p>  absolute, alone, dead, empty, equal, eternal, horizontal, perfect, primary, pregnant, round, square, straight, supreme, unique, unanimous</p>
</li>
<li><p><strong>可以用表接近的副词来对上面的词进行修饰</strong>，nearly perfect, almost fatal</p>
</li>
</ul>
</li>
</ul>
</li>
<li>比较级的用法<ul>
<li>than的比较句型，被比较的两个事物之间应具有可比性，如下<ul>
<li>两个同类事物的比较，A + 比较级 + than + B，This question is less difficult than that question.</li>
<li>同一事物自身的比较，A + 比较级 + 情形1 + than + 情形2，He did much better in the finals this term than last term.</li>
<li>若比较的事物具有包含所属关系，应当用other或else加以区分，Iron is more useful than any other metal.</li>
</ul>
</li>
<li>比较级与the<ul>
<li>比较级前面一般不需要the，但在有介词短语of the two出现时需要加the，I think this painting is the more interesting of the two.</li>
</ul>
</li>
<li>more and more句型<ul>
<li>more and more + 形容词，双重比较表示事物的不断变化，The city is becoming more and more beautiful.</li>
<li>不可用在单音节词之前，That singer is getting fatter and fatter.</li>
</ul>
</li>
<li>可以修饰比较级的词<ul>
<li>形容词比较级可以用表程度的词进行修饰，a bit, a little bit, a little, a lot, a great deal, any, even, far, by far, much, very much, no, rather, still, slightly, Are you feeling any better?</li>
<li>如下的词一般不能修饰比较级，very, much, quiet, fairly</li>
</ul>
</li>
<li>否定词+比较级<ul>
<li>否定词+比较级 表最高级，否定词包括 few, nothing, never, not，It couldn’t be worse. I have never heared a better song.</li>
</ul>
</li>
</ul>
</li>
<li><p>最高级的用法</p>
<ul>
<li>the + (序数词) + 最高级 + in + 地方，The Huanghe River is the second longest river in China.</li>
<li><p>the + 最高级 + of + 所属范围，Gold is the least useful of all metals.</p>
<p>  of + 所属范围 可以前置句首，Of all forms of energy, electricity is the most widely used.</p>
</li>
<li><p>most有时用在形容词前，表非常、很，相当于very, very much，此时前面不用加the，It is a most difficult problem.</p>
</li>
</ul>
</li>
</ul>
<h2 id="4-3-ing与-ed"><a href="#4-3-ing与-ed" class="headerlink" title="4.3 -ing与-ed"></a>4.3 -ing与-ed</h2><ul>
<li>基本用法<ul>
<li>ing形容词主要用来描述事物给人的感觉，主语通常是事物或作定语来修饰事物，the exciting news</li>
<li>ed形容词主要用来描述生命体的情绪神态，主语通常是生命体或作定语来修饰生命体，the excited man</li>
</ul>
</li>
<li>高级用法<ul>
<li>ing可以用来修饰人，表这个人给人的感觉，a boring man, He is interesting to listen to.(听他讲话很有意思)</li>
<li>ed可以用来修饰物，表示人的主管感受，Tom has a frightened look on his face.</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>course</category>
      </categories>
      <tags>
        <tag>英语语法</tag>
      </tags>
  </entry>
  <entry>
    <title>英语语法 7 - 动名词</title>
    <url>/2022/01/10/1-Course/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/07-%E5%8A%A8%E5%90%8D%E8%AF%8D/</url>
    <content><![CDATA[<img src="/2022/01/10/1-Course/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/07-%E5%8A%A8%E5%90%8D%E8%AF%8D/image-20220912230609235.png" class title="image-20220912230609235">
<span id="more"></span>
<p>动名词的构成是在动词后面加-ing，意义上相当于一个名词，但又保留有动词的特征</p>
<h2 id="21-1-动名词的作用"><a href="#21-1-动名词的作用" class="headerlink" title="21.1 动名词的作用"></a>21.1 动名词的作用</h2><ul>
<li><strong>做主语，一般位于句首</strong>，但在特定句型中可以置于句末(it is no good/use doing sth, there is no point/use/good in doing sth, there is no doing sth)<ul>
<li>Being deeply loved by someone gives you strength; while loving someone deeply gives you courage.</li>
<li>There is no telling what will happen tomorrow.</li>
</ul>
</li>
<li><strong>作宾语，在部分动词、介词、部分句型中做宾语</strong><ul>
<li>Many of the things we do involve taking some risk in order to achieve a satisfactory result.</li>
<li>The book is worth reading.</li>
</ul>
</li>
<li><strong>作表语</strong><ul>
<li>His hobby is collecting stamps.</li>
</ul>
</li>
</ul>
<h2 id="21-2-动名词的逻辑主语"><a href="#21-2-动名词的逻辑主语" class="headerlink" title="21.2 动名词的逻辑主语"></a>21.2 动名词的逻辑主语</h2><ul>
<li>动名词的复合结构，<strong>通过名词所有格、名词主格来引出逻辑主语</strong>，其中做主语时最好采用所有格，逻辑主语为物、不定代词或为较长的词组时，最好采用主格形式<ul>
<li>He disliked <strong>his wife’s working late.</strong></li>
<li><strong>There</strong> is no point <strong>any of us arguing with him</strong>.</li>
</ul>
</li>
</ul>
<h2 id="22-2-动名词的时态和语态"><a href="#22-2-动名词的时态和语态" class="headerlink" title="22.2 动名词的时态和语态"></a>22.2 动名词的时态和语态</h2><p><strong>动名词只有一般式和完成式的主动和被动形式</strong>，即doing, being done, having done, having been done</p>
<ul>
<li>被动式，<strong>动名词所修饰的名词或代词是动名词的逻辑宾语</strong>，但在<strong>demand, deserve, need, require, want等词后面</strong>，<strong>动名词主动表被动</strong><ul>
<li>I have not the least objection to the child being punished.</li>
<li>He deserves shooting first. 他应该第一个被枪毙</li>
<li>He deserves to shoot first. 他应该第一个开始射击</li>
</ul>
</li>
<li><strong>完成式，强调动名词动作发生在谓语动词之前，尤其是较长一段时间持续的情况</strong><ul>
<li>He denied <strong>having been there</strong>.</li>
<li>I appreciate <strong>having been given the opportunity</strong> to study abroad two years ago.</li>
</ul>
</li>
</ul>
<h2 id="22-3-there-be的不定式与动名词形式"><a href="#22-3-there-be的不定式与动名词形式" class="headerlink" title="22.3 there be的不定式与动名词形式"></a>22.3 there be的不定式与动名词形式</h2><ul>
<li><strong>there being</strong>表示有，常用与介词之后<ul>
<li>No one would have dreamed of <strong>there being</strong> such a good place.</li>
</ul>
</li>
<li><strong>there to be</strong>，常用在接不定式做宾语的动词或介词for后面<ul>
<li>I don’t mean <strong>there to be</strong> any unpleasantness.</li>
<li>For there to be life, there must be air and water.</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>course</category>
      </categories>
      <tags>
        <tag>英语语法</tag>
      </tags>
  </entry>
  <entry>
    <title>英语语法 6 - 分词</title>
    <url>/2022/01/10/1-Course/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/06-%E5%88%86%E8%AF%8D/</url>
    <content><![CDATA[<img src="/2022/01/10/1-Course/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/06-%E5%88%86%E8%AF%8D/image-20220912230534426.png" class title="image-20220912230534426">
<span id="more"></span>
<p>分词包含现在分词和过去分词，主要需要掌握意义、作用和用法。</p>
<h2 id="23-1-分词的意义"><a href="#23-1-分词的意义" class="headerlink" title="23.1 分词的意义"></a>23.1 分词的意义</h2><ul>
<li><strong>现在分词表主动的、正在进行的动作，或是主动的一般的动作</strong><ul>
<li>the sleeping boy, falling leaves, the rising sun</li>
<li>the exploiting class, a puzzling problem</li>
</ul>
</li>
<li><strong>及物动词的过去分词表被动一般或被动完成，不及物动词的过去分词表主动完成</strong><ul>
<li>the exploited class, a respected writer, the broken cup</li>
<li>the sunken ship, fallen leaves, departed friends, a developed country</li>
</ul>
</li>
<li>从语态角度，现在分词表主动意义，与被修饰名词构成主谓关系，而过去分词通常表被动意义，与所修饰名词构成动宾关系</li>
<li>从时态角度，现在分词往往表示正在进行的动作，或是一般动作，而过去分词表示一般的动作或完成的动作，若表示被动进行要用being done</li>
</ul>
<h2 id="23-2-分词的作用"><a href="#23-2-分词的作用" class="headerlink" title="23.2 分词的作用"></a>23.2 分词的作用</h2><ul>
<li><strong>分词做状语</strong><ul>
<li><strong>单独的分词作状语位于句首、句中、句尾，分词的最主要用法，分词的逻辑主语必须与句子主语一致，否则会变成垂悬分词</strong><ul>
<li>Good relationships are hard to find and once developed should be nurtured.</li>
</ul>
</li>
<li><strong>名词+分词作状语，名词表分词的逻辑主语</strong><ul>
<li>Weather permitting, we’ll be going fishing tomorrow.</li>
</ul>
</li>
<li><strong>With+名词+分词作状语，一般只表示伴随状况、补充说明、具体举例，或表示原因</strong><ul>
<li>The old man often takes a walk after supper with his fog following him.</li>
</ul>
</li>
<li><strong>固定结构，可以不满足主语一致性</strong><ul>
<li>副词+speaking，generally speaking, strictly speaking</li>
<li>分词+介词，judging from, allowing for</li>
<li>分词+that，considering that, supposing that</li>
</ul>
</li>
<li><strong>分词短语做状语可保留相应的连词，相当于简化了的状语从句</strong><ul>
<li>Once deprived of oxygen, the brain dies.</li>
<li>After talking to you, I always feel much better.</li>
</ul>
</li>
</ul>
</li>
<li><strong>分词作定语</strong><ul>
<li><strong>单个分词作定语需要前置，分词短语作定语需要后置</strong><ul>
<li>Please enclose a stamped addressed envelope.</li>
<li>Police hunting the killer of a part-time police officer stabbed outside her home in northwest London are seeking a man wearing a hooded top seen running away from the scene.</li>
</ul>
</li>
<li><strong>后置定语的三种被动结构</strong>：to be done表将来，being done表进行，done表一般过去或完成</li>
</ul>
</li>
<li><strong>分词作补足语</strong><ul>
<li>作补足语的分词一般用于感觉分词后，如find, hear, smell, observe, watch, notice<ul>
<li>We saw the sun rising from behind the trees.</li>
</ul>
</li>
<li>不定式做补足语强调动作的正在进行，而不定式强调动作的全过程<ul>
<li>I watched them climb the tower.</li>
<li>I watched them climbing the tower.</li>
</ul>
</li>
</ul>
</li>
<li>分词作句子成分的注意点<ul>
<li><strong>注意区分分词作定语还是状语</strong><ul>
<li>The government is to ban payment to witnesses by newspapers seeking to(定语修饰newpapers) buy up people involved in prominent cases such as the trial of Rosemary West.</li>
</ul>
</li>
<li><strong>分词的完成式having done和having been done不能做定语</strong>，<strong>不及物动词(grow)的过去分词只能做前置定语</strong>，不能做状语(其完成式可以)<ul>
<li>Grown in a small village, I developed a great interest in …</li>
<li>Having grown in a small village, I developed a great interest in …</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="23-3-分词的完成式"><a href="#23-3-分词的完成式" class="headerlink" title="23.3 分词的完成式"></a>23.3 分词的完成式</h2><p>由于过去分词本身包含了被动含义，因此分词只有时态变化，而且仅有一种完成式having done, having been done。</p>
<p><strong>当分词所表示的动作或状态在谓语动词所表示的动作之前发生，则需要使用分词的完成，一般表现为持续性或重复性</strong></p>
<ul>
<li>Having been bitten twice, the postman refused to deliver our letters unless we chained our dog up.</li>
</ul>
<h2 id="23-4-分词构成的复合形容词"><a href="#23-4-分词构成的复合形容词" class="headerlink" title="23.4 分词构成的复合形容词"></a>23.4 分词构成的复合形容词</h2><p><strong>可以用分词和名词、形容词、副词构成复合形容词</strong>，在进行构造时，必须搞清楚两类逻辑关系：<strong>外部关系和内部关系</strong>。</p>
<p>外部关系表示分词与其所修饰名词之间的关系，<strong>外部关系</strong>为主动关系应使用现在分词，被动关系应使用过去分词；</p>
<p>内部关系表示构成复合名词之间的关系。</p>
<ul>
<li><strong>现在分词构成的复合形容词</strong><ul>
<li>名词+及物动词的现在分词，名词为分词的逻辑宾语，ice-thawing visit, peace-keeping force</li>
<li>名词+不及物动词的现在分词，名词作为分词的逻辑状语，a night-walking animal, a winter-blooming plant</li>
<li>形容词+系动词的现在分词，形容词做形式表语，a good-looing man, a easy-going person</li>
<li>副词+不及物动词的现在分词，副词作形式状语，hard-working people, naturally-occuring substances</li>
</ul>
</li>
<li><strong>过去分词构成的复合形容词</strong><ul>
<li>名词+及物动词的过去分词，名词作形式主语，password-protected files, man-made fibers, state-owned enterprises(国有企业)</li>
<li>形容词+及物动词的过去分词，形容词做形式补语，a democratically-elected prime minister, a newly-built library</li>
</ul>
</li>
<li>其他形式的复合形容词<ul>
<li>形容词+名词+ed，warm-hearted people, narrow-minded people, blue-eyed boy, long-haired girl</li>
<li>名词+数词+e，two-faced person, three-legged table,</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>course</category>
      </categories>
      <tags>
        <tag>英语语法</tag>
      </tags>
  </entry>
  <entry>
    <title>英语语法 8 - 基本句型</title>
    <url>/2022/01/10/1-Course/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/08-%E5%9F%BA%E6%9C%AC%E5%8F%A5%E5%9E%8B/</url>
    <content><![CDATA[<img src="/2022/01/10/1-Course/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/08-%E5%9F%BA%E6%9C%AC%E5%8F%A5%E5%9E%8B/image-20220912235244994.png" class title="image-20220912235244994">
<span id="more"></span>
<h2 id="否定句与疑问句"><a href="#否定句与疑问句" class="headerlink" title="否定句与疑问句"></a>否定句与疑问句</h2><h3 id="5-4-陈述句的否定"><a href="#5-4-陈述句的否定" class="headerlink" title="5.4 陈述句的否定"></a>5.4 陈述句的否定</h3><ul>
<li>谓语中含有be动词(实义动词或助动词)或情态动词时，直接在be动词或情态动词后面加not，He is not a teacher. I cannot swim.</li>
<li>谓语动词仅有实义动词，通过do/dose/did + not + 动词原形来表达否定，I do not like English.</li>
<li><p>否定缩写</p>
  <img src="/2022/01/10/1-Course/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/08-%E5%9F%BA%E6%9C%AC%E5%8F%A5%E5%9E%8B/Untitled.png" class title="Untitled">
</li>
</ul>
<h3 id="5-5-一般疑问句"><a href="#5-5-一般疑问句" class="headerlink" title="5.5 一般疑问句"></a>5.5 一般疑问句</h3><p>一个完整陈述句的真伪进行提问，只调整动词的位置</p>
<ul>
<li>谓语中含有<strong>be动词(实义动词或助动词)</strong>或情态动词时，直接将其移动到句首，肯定回答用yes，<ul>
<li>Is he a teacher?</li>
</ul>
</li>
<li>谓语动词是实义动词的一般疑问句，需要把do/does/did放于句首，且谓语动词变为原形，<ul>
<li>Did he like English?</li>
</ul>
</li>
</ul>
<h3 id="5-6-特殊疑问句"><a href="#5-6-特殊疑问句" class="headerlink" title="5.6 特殊疑问句"></a>5.6 特殊疑问句</h3><p>对句子成分进行提问，用特殊疑问词代指句子成分，格式为：特殊疑问词 + 一般疑问句 + ？</p>
<ul>
<li>不与名词连用的疑问词，who, what, when, where, how, why<ul>
<li>What are you doing?</li>
</ul>
</li>
<li>需与名词连用的疑问词，which, whose<ul>
<li>Which one do you like?</li>
</ul>
</li>
<li>how的用法<ul>
<li>单独使用，对动作方式进行提问，How do you go to work?</li>
<li>与形容词或副词连用，How old are you?</li>
<li>对动作发生频率提问，how often, how many times</li>
</ul>
</li>
</ul>
<hr>
<h2 id="五种基本句型"><a href="#五种基本句型" class="headerlink" title="五种基本句型"></a>五种基本句型</h2><p><strong>动词是句子的核心，决定了一个句子的骨架结构。</strong></p>
<h3 id="6-1-主语-系动词-表语"><a href="#6-1-主语-系动词-表语" class="headerlink" title="6.1 主语 + 系动词 + 表语"></a>6.1 主语 + 系动词 + 表语</h3><ul>
<li><p>系动词，又称连系动词，不表具体的动作，只用于连接主语和表语，</p>
<p>  常用系动词有be, look, sound, smell, taste, feel, seem, appear, become, turn</p>
</li>
<li><p>表语，用于表明主语的性质特征，又称为主语补足语，<strong>一般是名词或形容词</strong></p>
</li>
<li><strong>He looks happy.</strong></li>
</ul>
<h3 id="6-2-主语-谓语-状语"><a href="#6-2-主语-谓语-状语" class="headerlink" title="6.2 主语 + 谓语 ( + 状语 )"></a>6.2 主语 + 谓语 ( + 状语 )</h3><ul>
<li>谓语为不及物动词，没有宾语，表动作没有对象，本身意义完整。</li>
<li>谓语后面可以接副词或介词短语来说明动作的方式、地点、时间，修饰动作的成分称为状语</li>
<li><strong>He shouted loudly.</strong></li>
</ul>
<h3 id="6-3-主语-谓语-宾语-状语"><a href="#6-3-主语-谓语-宾语-状语" class="headerlink" title="6.3 主语 + 谓语 + 宾语( + 状语 )"></a>6.3 主语 + 谓语 + 宾语( + 状语 )</h3><ul>
<li>谓语为及物动词(vt.)，连接主语动作的承受对象即宾语，宾语后面可以加副词或介词短语作状语。</li>
<li><strong>I like chatting on the Internet.</strong></li>
</ul>
<h3 id="6-4-主语-谓语-间接宾语-直接宾语"><a href="#6-4-主语-谓语-间接宾语-直接宾语" class="headerlink" title="6.4 主语 + 谓语 + 间接宾语 + 直接宾语"></a>6.4 主语 + 谓语 + 间接宾语 + 直接宾语</h3><ul>
<li><strong>谓语为双宾动词</strong>，所接成分既有人又有物；一般来说<strong>人表示动作的接受者，为间接宾语</strong>；<strong>物是动作的承受者，为直接宾语</strong>。<ul>
<li>I made John a cake.</li>
</ul>
</li>
<li><strong>谓语为宾补动词</strong>，接宾语和宾语补足语<ul>
<li>宾语补足语是对宾语的补充说明，而非动作的承受者，类似主语与主语补足语，<strong>可通过添加系动词be和双宾语进行区分</strong></li>
<li>I made John our chairman.</li>
</ul>
</li>
</ul>
<h3 id="6-5-主语-谓语-宾语-宾语补足语"><a href="#6-5-主语-谓语-宾语-宾语补足语" class="headerlink" title="6.5 主语 + 谓语 + 宾语 + 宾语补足语"></a>6.5 主语 + 谓语 + 宾语 + 宾语补足语</h3><ul>
<li>谓语为宾补动词，宾语与宾语补足语合成复合宾语，<ul>
<li>常见的宾补动词有：appoint, believe, call, choose, consider, elect, fell, find, keep</li>
<li>The chairman declared the meeting over.</li>
</ul>
</li>
<li><strong>区别双宾语与复合宾语：是否能构成主系表结构</strong></li>
</ul>
<hr>
<h2 id="简单句与复合句"><a href="#简单句与复合句" class="headerlink" title="简单句与复合句"></a>简单句与复合句</h2><p>一个完整的句子都是由两部分组成：陈述对象+陈述内容，即主语加谓语。谓语决定了一个句子的骨架结构。在分析复杂的难句结构式首先需要找到句子的谓语，包括主句的谓语和各个从句的谓语；同时在写作时，一定需要知道谓语动词的用法特点，能否接宾语以及接何种形式的宾语。</p>
<h3 id="9-1-主语-系动词-表语"><a href="#9-1-主语-系动词-表语" class="headerlink" title="9.1 主语 + 系动词 + 表语"></a>9.1 主语 + 系动词 + 表语</h3><p>系动词没有实际含义，只用来连接主语和后面的表语，副词不能做表语</p>
<ul>
<li>系动词分类<ul>
<li>表主语的特征/状态，feel, look, sound, taste, small, seem, appear<ul>
<li>The iron feels not hot.</li>
</ul>
</li>
<li>表主语从一种状态转化为另一种状态，become, grow, get, turn, fall, go, come<ul>
<li>The leaf will turn yellow in autumn.</li>
<li>go作为系动词，表主语像坏的方向发展，go hungry, go mad, go bad, go crazy</li>
</ul>
</li>
<li>表主语保持某种状态，continue, remain, stay, keep, hold, rest, prove<ul>
<li>He held silent for the whole day.</li>
</ul>
</li>
<li>近于不及物动词的系动词，sit, act, arrive, blush, marry, die, be born<ul>
<li>Lei Feng died young. (Lei Feng was young when he died.)</li>
</ul>
</li>
</ul>
</li>
<li><p>简单句叠加成复杂句</p>
<p>  <strong>Vitamins are organic compounds necessary in small amounts in the diet(定语) for the normal growth and maintenance of life(定语) of animals, including man.</strong></p>
</li>
</ul>
<h3 id="9-2-主语-谓语-状语"><a href="#9-2-主语-谓语-状语" class="headerlink" title="9.2 主语 + 谓语 ( + 状语 )"></a>9.2 主语 + 谓语 ( + 状语 )</h3><ul>
<li><p>简单句叠加成复杂句</p>
<p>  <strong>This trend began during the Second World War(状语), when several governments came to the conclusion(定从) that the specific demands that a government wants to make of its scientific establishment(定从) cannot generally be foreseen in detail(同从).</strong></p>
</li>
</ul>
<h3 id="9-3-主语-谓语-宾语-状语"><a href="#9-3-主语-谓语-宾语-状语" class="headerlink" title="9.3 主语 + 谓语 + 宾语( + 状语 )"></a>9.3 主语 + 谓语 + 宾语( + 状语 )</h3><ul>
<li><p>简单句叠加成复杂句</p>
<p>  <strong>The emphasis given by both scholars and statesmen(定语) to the presumed disappearance of the American frontier(定语) helped to obscure the great importance of changes in the conditions and consequences of international trade(定语) that occurred during the second half of the nineteenth century(定从).</strong></p>
</li>
</ul>
<h3 id="9-4-主语-谓语-间接宾语-直接宾语"><a href="#9-4-主语-谓语-间接宾语-直接宾语" class="headerlink" title="9.4 主语 + 谓语 + 间接宾语 + 直接宾语"></a>9.4 主语 + 谓语 + 间接宾语 + 直接宾语</h3><ul>
<li><p>简单句叠加成复杂句</p>
<p>  <strong>Her work in genetics won United States scientist Barbara McClintock the Nobel Prize in 1983.</strong></p>
</li>
</ul>
<h3 id="9-5-主语-谓语-宾语-宾语补足语"><a href="#9-5-主语-谓语-宾语-宾语补足语" class="headerlink" title="9.5 主语 + 谓语 + 宾语 + 宾语补足语"></a>9.5 主语 + 谓语 + 宾语 + 宾语补足语</h3><ul>
<li><p>简单句叠加成复杂句</p>
<p>  <strong>Willa Cather considered her novel of life in nineteenth-century Nebraska(定语), My Antonia(同位语) her best work.</strong></p>
</li>
</ul>
<h3 id="9-6-从简单句到复杂句"><a href="#9-6-从简单句到复杂句" class="headerlink" title="9.6 从简单句到复杂句"></a>9.6 从简单句到复杂句</h3><p>英文中各种复杂的难句都是由这五种基本句型通过扩展、组合、省略、倒装等各种形式变化而来的。一个句子除了主语和谓语外，还可能有宾语、表语、定语、状语、补语和同位语，<strong>除了谓语只能由动词充当外，其余成分均可以由词、短语或句子来充当</strong>。</p>
<ul>
<li><strong>主语从句、宾语从句、表语从句、同位语从句</strong>都在主句中充当名词，因此统称为名词从句</li>
<li><strong>定语从句用来修饰名词</strong>，又称为形容词从句</li>
<li><strong>状语从句用来修饰动词、形容词和副词</strong>，又称为副词从句</li>
</ul>
]]></content>
      <categories>
        <category>course</category>
      </categories>
      <tags>
        <tag>英语语法</tag>
      </tags>
  </entry>
  <entry>
    <title>英语语法 10 - 定语从句</title>
    <url>/2022/01/10/1-Course/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/10-%E5%AE%9A%E8%AF%AD%E4%BB%8E%E5%8F%A5/</url>
    <content><![CDATA[<img src="/2022/01/10/1-Course/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/10-%E5%AE%9A%E8%AF%AD%E4%BB%8E%E5%8F%A5/image-20220912235506530.png" class title="image-20220912235506530">
<span id="more"></span>
<p><strong>定语从句用来修饰名词或名词短语，表达复杂的限定与修饰含义。</strong></p>
<h2 id="11-1-先行词与关系词"><a href="#11-1-先行词与关系词" class="headerlink" title="11.1 先行词与关系词"></a>11.1 先行词与关系词</h2><ul>
<li><strong>先行词</strong>：被定语从句修饰的对象</li>
<li><strong>关系词</strong>：重复代指先行词、起连接主句和从句的作用，并在从句中充当一定成分的连接词<ul>
<li>关系代词：重复代指先行词并在从句中充当一定成分，who, whom, which, that, whose</li>
<li>关系副词：连接主语和从句，起副词作用，when, where, why</li>
</ul>
</li>
</ul>
<hr>
<h2 id="11-2-关系代词在定语从句中充当的成分"><a href="#11-2-关系代词在定语从句中充当的成分" class="headerlink" title="11.2 关系代词在定语从句中充当的成分"></a>11.2 关系代词在定语从句中充当的成分</h2><ul>
<li>关系词作从句主语，从句谓语动词的形式由关系词代指的先行词来决定<ul>
<li>The woman who lives next door is a famous dancer.</li>
</ul>
</li>
<li>关系词做从句宾语，或介词宾语，此时关系词可省略<ul>
<li>I’d really like to find a friend (who) I can trust him completely.</li>
<li>I’m talking about the friends (who) you can share almost everything with.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="11-3-关系代词与先行词的搭配关系"><a href="#11-3-关系代词与先行词的搭配关系" class="headerlink" title="11.3 关系代词与先行词的搭配关系"></a>11.3 关系代词与先行词的搭配关系</h2><ul>
<li><strong>who与whom</strong><ul>
<li>who为主格形式，可以在从句中做主语、宾语和表语，不能用于介词之后</li>
<li>whom不能在从句中做主语，可以用在介词之后<ul>
<li>I’m talking about friends who you can share almost everything with.</li>
<li>I’m talking about friends with whom you can share almost everything.</li>
</ul>
</li>
</ul>
</li>
<li><strong>表示人或物的所有关系，用whose</strong><ul>
<li>When I looked through the window, I saw a girl whose beauty took my breath away.</li>
</ul>
</li>
<li><strong>先行词指物，用which，可以用来指代词、短语和句子</strong><ul>
<li>Anger is a wind which blows out the lamp of the mind.</li>
<li>He likes climbing mountains, which is a good exercise.</li>
<li>He tore up the photo, which upset me.</li>
</ul>
</li>
<li><strong>that可代指人，也可以代指物，不能用在非限制定语从句，不能用在介词之后，在以下情况下使用that更为合适</strong><ul>
<li><strong>当先行词中同时出现人和物时</strong><ul>
<li>The writer and his novels that the article deals with are quite familiar to us.</li>
</ul>
</li>
<li><strong>先行词为指物的all, little, few, much, none, the first</strong><ul>
<li>All that glitters is not gold.</li>
<li>This book contains little that is useful.</li>
<li>There is not much that can be done.</li>
</ul>
</li>
<li><strong>先行词被any, only, all, every, no, some, much, few, little, 序数词, 最高级, the only, the one, the very, the right等修饰</strong><ul>
<li>Tell us all things that you know.</li>
<li>There is no difficulty that they can’t overcome.</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="11-4-关系副词"><a href="#11-4-关系副词" class="headerlink" title="11.4 关系副词"></a>11.4 关系副词</h2><ul>
<li><strong>When引导定语从句，先行词必须为表时间的名词，且关系副词必须在从句中做时间状语</strong><ul>
<li>I’ll never forget the day when I met you.</li>
</ul>
</li>
<li><strong>Where引导定语从句，先行词一般为表示地点的名词，且关系副词必须在从句中做地点状语</strong><ul>
<li>This is the town where I spent my childhood.</li>
</ul>
</li>
<li><strong>Why用来引导表原因的限定性定语从句， 先行词是如reason等表原因的名词</strong><ul>
<li>This is the reason why I didn’t come here.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="11-5-限制性定语从句与非限制定语从句"><a href="#11-5-限制性定语从句与非限制定语从句" class="headerlink" title="11.5 限制性定语从句与非限制定语从句"></a>11.5 限制性定语从句与非限制定语从句</h2><ul>
<li><strong>限制性定语从句</strong><ul>
<li><strong>用来附一个名词提供必要的信息</strong>，说明先行词的身份或性质，或限制先行词的所知范围，若去掉从句则主句部分的含义不明确，或意义不完整，<strong>因此不用逗号隔开</strong></li>
<li>He is a man who is of value to the people.</li>
</ul>
</li>
<li><strong>非限制定语从句</strong><ul>
<li><strong>用来提供附加而必要的信息</strong>，只是对先行词作进一步的解释、补充或说明，若去掉并不会影响主句的含义，<strong>因此要用逗号将从句和主句隔开</strong></li>
<li>My mother, who is 50 this year, lives with me now.</li>
<li>An elephant, which is the earth’s largest land mammal, has few natural enemies other than human beings.</li>
</ul>
</li>
<li><strong>非限制定语从句与限制定语从句有不同的含义，两者的强调的侧重点不同</strong><ul>
<li>He has a daughter who works in a hospital. 表示他有多个女儿，其中一个在医院工作</li>
<li>He has a daughter, who works in a hospital. 强调他有一个女儿，而不是儿子，在医院工作只是补充信息</li>
</ul>
</li>
<li>非限制定语从句一般按照各种状语进行翻译<ul>
<li>The food, which wasn’t in the fridge, all went off. 食物都坏了，因为没有放在冰箱里。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="11-6-定语从句与同位语从句的区别"><a href="#11-6-定语从句与同位语从句的区别" class="headerlink" title="11.6 定语从句与同位语从句的区别"></a>11.6 定语从句与同位语从句的区别</h2><ul>
<li><p><strong>结构区别：that是否作句子成分</strong></p>
<p>  that在定语从句中需要充当成分，而在同位语从句中仅为连接作用</p>
<ul>
<li>The rumor that he spread everywhere turned to be untrue.</li>
<li>The rumor that Tom was a thief turned out to be untrue.</li>
</ul>
</li>
<li><p><strong>意义区别：that引导的从句的意义不同</strong></p>
<p>  定语从句相当于形容词，对先行词起修饰作用，同位语从句相当于一个名词，是对前面名词的具体表述</p>
<ul>
<li>The news that you heard is not true.</li>
<li>The news that Lincoln was murdered at a theater is true.</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>course</category>
      </categories>
      <tags>
        <tag>英语语法</tag>
      </tags>
  </entry>
  <entry>
    <title>英语语法 11 - 状语从句</title>
    <url>/2022/01/10/1-Course/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/11-%E7%8A%B6%E8%AF%AD%E4%BB%8E%E5%8F%A5/</url>
    <content><![CDATA[<img src="/2022/01/10/1-Course/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/11-%E7%8A%B6%E8%AF%AD%E4%BB%8E%E5%8F%A5/image-20220912235524340.png" class title="image-20220912235524340">
<span id="more"></span>
<p>英语中的状语从句主要有九种，分别为时间、地点、原因、目的、结果、条件、让步、比较和方式</p>
<h2 id="12-1-时间状语从句"><a href="#12-1-时间状语从句" class="headerlink" title="12.1 时间状语从句"></a>12.1 时间状语从句</h2><ul>
<li><strong>when，意思相当于at the time 在…时刻，因此从句的谓语动词通常是短暂动词，表某一时刻的动作，在接延续动词时往往采用过去进行时，表示过去一段时间发生的动作</strong><ul>
<li>主句一般过去时+从句一般过去时，表从句先发生<ul>
<li>I started my dinner when he left.</li>
<li>He left when I got there. 我到了之后他才开</li>
</ul>
</li>
<li>主句一般过去时+从句过去完成时，更强调从句先发生<ul>
<li>I started my dinner when he had left.</li>
<li>He left when I had got there.</li>
</ul>
</li>
<li>主语过去进行时+从句一般过去时，用于描述过去的一个长动作中发生的短动作<ul>
<li>I was walking along the road when suddenly someone patted me on the shoulder from behind.</li>
</ul>
</li>
<li>主句一般将来时+从句一般现在时，从句用一般现在时表将来<ul>
<li>I’ll tell him when he comes back.</li>
</ul>
</li>
</ul>
</li>
<li><strong>while，作时间连词时，表during that time，在一段时间发生动作，因此谓语通常为延续动词</strong><ul>
<li>The doorbell rang while we were watching TV.</li>
</ul>
</li>
<li><strong>until，可以作时间连词接从句，也可以作介词接时间名词，表主句动作一直持续到某个时间点，因此从句谓语必须为短暂性动词</strong><ul>
<li>延续动词+until+短暂动词或时间点<ul>
<li>Until I came back, he was waiting for me at my home.</li>
<li>We will be away from my office until next Tuesday.</li>
</ul>
</li>
<li>否定词+短暂动词+until+短暂动词或时间点<ul>
<li>He didn’t leave the office until his boss came back.</li>
<li>I did not realize how special my mother was until I become an adult.</li>
</ul>
</li>
</ul>
</li>
<li><strong>表示 一…就… 的结构</strong><ul>
<li>从句动作先于主语动作(从句动作发生后，主句动作紧跟发生)，主句从句时态一般一致(如主句过去从句过去，主句将来从句现在)，as soon as, once, the minute, the moment, the instant, immediately, directly, instantly<ul>
<li>We will leave as soon as it stops raining.</li>
<li>It began to rain immediately I arrived home.</li>
</ul>
</li>
<li>主句动作先于从句动作，hardly…when, no sooner…than, 一般表过去动作，主句多用过去完成时，且常倒装，从句一般用过去时<ul>
<li>No sooner had I arrived home than it began to rain.</li>
<li>Hardly had the storm started when all the lights went out.</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="12-2-地点状语从句"><a href="#12-2-地点状语从句" class="headerlink" title="12.2 地点状语从句"></a>12.2 地点状语从句</h2><ul>
<li>通常由where引导，用来表达主句动作发生的场所，<strong>注意区别关系副词引导的定语从句</strong><ul>
<li>Stay where you are.</li>
<li>A driver should slow down where there are schools.</li>
<li>Where there is a will , there is a way.</li>
</ul>
</li>
</ul>
<h2 id="12-3-原因状语从句"><a href="#12-3-原因状语从句" class="headerlink" title="12.3 原因状语从句"></a>12.3 原因状语从句</h2><ul>
<li>常见连词的用法<ul>
<li><strong>because语气最强，可以回答why的问句，所引出的原因往往是听话人所不知道或最感兴趣的</strong><ul>
<li>My friends dislike me because I’m handsome and successful.</li>
</ul>
</li>
<li><strong>since, as表示人们已知的事实，是不需要强调的原因，通常放在句首，翻译为既然</strong><ul>
<li>Since you are an English major, I guess you can help me with this sentence.</li>
</ul>
</li>
<li><strong>for表推断的理由，是对前面分句的内容加以解释或说明</strong><ul>
<li>It rained last night, for the ground is wet this morning.</li>
</ul>
</li>
</ul>
</li>
<li><strong>用介词表示因果关系</strong><ul>
<li>常用介词有<strong>because of, due to, owing to</strong>, <strong>后面只能接名词，不能接从句</strong><ul>
<li>We had an accident due to his carelessness.</li>
<li>Owing to his carelessness we have an accident.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="12-4-目的状语从句"><a href="#12-4-目的状语从句" class="headerlink" title="12.4 目的状语从句"></a>12.4 目的状语从句</h2><ul>
<li>英文中常用来<strong>引导目的状语从句</strong>的连词有<strong>so that, in order that, that</strong>, 且在从句中常含有情态动词。<strong>目的状语从句一般置于句尾</strong>，<strong>但为了强调目的状语从句时</strong>，可将so that, in order that引导的从句置于句首<ul>
<li>We climbed high (so) that we might get a better view.</li>
<li><strong>In order that</strong> my roommate could study in peace and quiet, I turned off the TV.</li>
</ul>
</li>
</ul>
<h2 id="12-5-结果状语从句"><a href="#12-5-结果状语从句" class="headerlink" title="12.5 结果状语从句"></a>12.5 结果状语从句</h2><ul>
<li>常用的引导结果状语从句的连词有<strong>so…that, such…that</strong><ul>
<li><strong>连词so…that引发结果状语从句，so后面接形容词或副词</strong><ul>
<li>The moon is so large that several million people could live there.</li>
<li>He has put forward unquestioned claims so consistently that he convinced industrial and business management that they are true.</li>
</ul>
</li>
<li><strong>连词such…that引导结果状语从句， such后面接名词</strong><ul>
<li>He is such a good teacher that everyone likes him.</li>
</ul>
</li>
</ul>
</li>
<li><strong>结果状语从句一般置于主句之后，为了强调可以将主句中so/such引导的部分提到句首并倒装</strong><ul>
<li><strong>So fast does the light travel</strong> that it is difficult for us to imagine its speed.</li>
</ul>
</li>
</ul>
<h2 id="12-6-条件状语从句"><a href="#12-6-条件状语从句" class="headerlink" title="12.6 条件状语从句"></a>12.6 条件状语从句</h2><ul>
<li><strong>常见连词if表如果, unless表如果不、除非</strong><ul>
<li>Giving someone all your love is never an assurance that they’ll love you back. Don’t expect love in return, just wait for it to grow in their heart, but if it doesn’t be glad it grew in yours.</li>
<li>This will be useless unless you carry them out.</li>
</ul>
</li>
<li>其他连词引导的条件状语从句，<strong>suppose (that), supposing (that), providing/provided(that), so/as long as, on condition that</strong><ul>
<li>A man is not old as long as he is seeking something. A man is not old until regrets take the place of dreams.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="12-7-让步状语从句"><a href="#12-7-让步状语从句" class="headerlink" title="12.7 让步状语从句"></a>12.7 让步状语从句</h2><ul>
<li><strong>表让步的连词，though, although, even though, even if, 此时主句前不可用but，但可以用yet或still</strong><ul>
<li>Although he tried out, (yet/still) he failed.</li>
<li>Though he was inexperienced, he did a very good job.</li>
</ul>
</li>
<li><strong>表让步的介词，despite, in spite of, for all, 后面接名词</strong><ul>
<li>In spite of his inexperience, he did a very good job.</li>
</ul>
</li>
<li><strong>置于句首的while一般表示尽管</strong><ul>
<li>While the government pushed for a total breakup of the software maker, Microsoft fought fiercely against any positions that would affect its ability to compete in the marketplace.</li>
</ul>
</li>
<li><strong>as引导的倒转句表让步，倒装部分可以是形容词、副词、分词、名词</strong><ul>
<li>Young as he is, he is knowledgeable.</li>
<li>Again as he failed in doing this experiment, he didn’t lose his heart.</li>
<li>Praised as he was, he remained modest.</li>
<li>Lazy a boy as he is, he is kind to help others.</li>
<li>Odd though it sounds(让步状语从句), cosmic inflation is a scientifically plausible(定语) consequence(主句1) of some respected ideas(限定词) in elementary particle physics(定语), and many astrophysicists have been convinced(主句2) for the better part of the of a decade(时间状语从句) that it is true(宾语从句).</li>
</ul>
</li>
</ul>
<h2 id="12-8-比较状语从句"><a href="#12-8-比较状语从句" class="headerlink" title="12.8 比较状语从句"></a>12.8 比较状语从句</h2><ul>
<li><strong>连词as引导的比较状语从句</strong><ul>
<li>as+形容词+as，其中前一个as为副词，后一个as为连词(或介词)<ul>
<li>The work is not as difficult as you think.</li>
</ul>
</li>
<li>as+形容词+a(n)+可数名词单数+as，其中第一个as作为副词来修饰形容词，注意形容词要置于不定冠词之前<ul>
<li>Rarely has a technological development had as great an impact on so many aspects of social as the growth of electronics.</li>
</ul>
</li>
<li>从句可以采用倒转以保持句子平衡，as…as+助动词+主语<ul>
<li>The computer revolution may well change society as fundamentally as did the Industrial Revolution.</li>
</ul>
</li>
</ul>
</li>
<li><strong>连词than引导的比较状语从句</strong><ul>
<li>可比性问题，两个同类事物才可以比较</li>
<li>主句中必须要有比较级形式出现</li>
<li>从句可以用全部或部分倒转以保持句子平衡<ul>
<li>Ambitious students are more likely to succeed in their studies than are those with little ambition.</li>
</ul>
</li>
</ul>
</li>
<li><strong>表示倍数比较的三种句型</strong><ul>
<li>倍数+比较级，A is three times bigger than B</li>
<li>倍数+as…as，A is three times as big as B</li>
<li>倍数+名词，A is three times the size of B</li>
</ul>
</li>
<li><strong>The more…, the more句型结构</strong><ul>
<li>比较级部分在各自的分句中都充当一定成分，相当于将分句中的某个成分变为比较级之后提到句首</li>
<li>从结构上来看，前半部分为从句，后半部分为主句，因此前半句常用现在时，后半句常用将来时</li>
<li>翻译时，一般按照正常的语序，先翻译从句，再翻译主句<ul>
<li>The more exactly you use your words, the more easily people will understand you.</li>
<li>The more exact your words are, the easier it is for people to understand you.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="12-9-方式状语从句"><a href="#12-9-方式状语从句" class="headerlink" title="12.9 方式状语从句"></a>12.9 方式状语从句</h2><ul>
<li>常用引导词有<strong>as, like, as if, as though, the way</strong>等<ul>
<li>He looks as if he is an actor.</li>
<li>When in Rome, do as the Romans do.</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>course</category>
      </categories>
      <tags>
        <tag>英语语法</tag>
      </tags>
  </entry>
  <entry>
    <title>英语语法 9 - 名词性从句</title>
    <url>/2022/01/10/1-Course/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/09-%E5%90%8D%E8%AF%8D%E6%80%A7%E4%BB%8E%E5%8F%A5/</url>
    <content><![CDATA[<img src="/2022/01/10/1-Course/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/09-%E5%90%8D%E8%AF%8D%E6%80%A7%E4%BB%8E%E5%8F%A5/image-20220912235439719.png" class title="image-20220912235439719">
<span id="more"></span>
<h2 id="10-1-三种句型充当名词性从句"><a href="#10-1-三种句型充当名词性从句" class="headerlink" title="10.1 三种句型充当名词性从句"></a>10.1 三种句型充当名词性从句</h2><p>英语中相当于名词的句子有三类：<strong>陈述句、一般疑问句以及特殊疑问句</strong>，它们分别可以充当句子中的主语、宾语、表语、同位语。</p>
<ul>
<li><strong>陈述句做句子成分</strong><ul>
<li><strong>陈述句做句子成分需要在句首增加that引导词，以帮助理解</strong><ul>
<li>That the plates are moving is not beyond dispute.</li>
<li>My concern is that the child should be sent to school.</li>
</ul>
</li>
<li><strong>陈述句做宾语从句时可以不加that，因为不会影响句子理解，但增加that可以帮助理解</strong><ul>
<li>The criminal confessed (that) his sins harmed many people.</li>
<li>I think you are right.</li>
</ul>
</li>
</ul>
</li>
<li><strong>一般疑问句做句子成分</strong><ul>
<li><strong>一般疑问句做句子成分时需要将一般疑问句的倒装语序变为陈述语序，并用whether或if引导，其中if只能引导宾语从句</strong><ul>
<li>Weather he will come to my party makes no difference to me.</li>
<li>I don’t know if/whether he needs my help.</li>
</ul>
</li>
<li><strong>weather可以和or not连用，if不可以</strong><ul>
<li>I don’t know whether or not he will come.</li>
</ul>
</li>
</ul>
</li>
<li><strong>特殊疑问句做句子成分</strong><ul>
<li><strong>特殊疑问句做句做句子成分时，需将倒装语序变为陈述语序</strong>，<strong>不需要引导词(特殊疑问词即为引导词)</strong><ul>
<li>I don’t know how many letters there are in the English alphabet.</li>
<li>Money is what we are badly in need of.</li>
</ul>
</li>
<li><strong>当特殊疑问词在从句中做主语时，不用调整语序，因为此时的疑问句已经是陈述语序</strong><ul>
<li>Who will chair the meeting has not yet been decided.</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="10-2-主语从句"><a href="#10-2-主语从句" class="headerlink" title="10.2 主语从句"></a>10.2 主语从句</h2><ul>
<li><strong>陈述句做主语，可以用it做形式主语置于句首，而将主语从句置于句末</strong><ul>
<li><strong>That the sea are being overfished</strong> has been known for years.</li>
<li><strong>It</strong> has been known for years <strong>that the sea are being overfished</strong>.</li>
<li>It is common knowledge that the moon itself does not give off light.</li>
<li>It is reported that, It is believed that, It is generally thought that, It should be noted that, It must be point out that</li>
<li>It is clear that, It is possible that, It is likely that, It is certain that</li>
<li>It is fact that, It is an honor that, It is my belief that</li>
</ul>
</li>
<li>一般疑问句做主语<ul>
<li>Weather he will come to my party makes no difference to me.</li>
</ul>
</li>
<li>特殊疑问句做主语<ul>
<li>I don’t know how many letters there are in the English alphabet.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="10-3-宾语从句"><a href="#10-3-宾语从句" class="headerlink" title="10.3 宾语从句"></a>10.3 宾语从句</h2><ul>
<li>陈述句做宾语<ul>
<li>I think (that) a sound knowledge of grammar is indispensable to good writing.</li>
</ul>
</li>
<li>一般疑问句做宾语<ul>
<li>I don’t know if/weather he needs my help .</li>
<li>No one knew whether or not interest rates would rise.</li>
</ul>
</li>
<li>特殊疑问句做宾语<ul>
<li>I have not decided whom I should vote for.</li>
<li>You should vote for which candidate you assume best.</li>
<li>Could you tell me where the post office is?</li>
<li>They give who came to the meeting a pamphlet.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="10-4-表语从句"><a href="#10-4-表语从句" class="headerlink" title="10.4 表语从句"></a>10.4 表语从句</h2><ul>
<li>陈述句做表语<ul>
<li>My ideal is that the child should be sent to school.</li>
</ul>
</li>
<li>一般疑问句做表语<ul>
<li>My concern is whether he comes or not.</li>
</ul>
</li>
<li>特殊疑问句做表语<ul>
<li>This is where our basic interest lies.</li>
<li>Change is what keeps us fresh and innovative.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="10-5-同位语从句"><a href="#10-5-同位语从句" class="headerlink" title="10.5 同位语从句"></a>10.5 同位语从句</h2><ul>
<li>陈述句做同位语<ul>
<li>He was prepared to prove <strong>his theory</strong> <strong>that two different weights would fall to the ground at the same time</strong>.</li>
<li>A <strong>saying</strong> goes <strong>that practice makes perfect</strong>.</li>
</ul>
</li>
<li>一般疑问句做同位语<ul>
<li>They are faced with the <strong>problem</strong> <strong>whether they should continue to work.</strong></li>
</ul>
</li>
<li>特殊疑问句做同位语<ul>
<li>I have no <strong>idea</strong> <strong>when he will return.</strong></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>course</category>
      </categories>
      <tags>
        <tag>英语语法</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenSim源码安装</title>
    <url>/2021/06/01/4-Tutorials/OpenSim/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<p>Windows环境下OpenSim源码安装记录</p>
<img src="/2021/06/01/4-Tutorials/OpenSim/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/Snipaste_2021-11-11_22-29-52-7844452.png" class title="Snipaste_2021-11-11_22-29-52">
<span id="more"></span>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://github.com/opensim-org/opensim-core#for-the-impatient-windows">官方文档</a></li>
<li><a href="https://blog.csdn.net/lrm15659833890/article/details/88576891">中文博客</a></li>
<li><a href="https://blog.csdn.net/wopt00/article/details/91430023">中文博客2</a></li>
</ul>
<h2 id="Step1-安装依赖软件"><a href="#Step1-安装依赖软件" class="headerlink" title="Step1 安装依赖软件"></a>Step1 安装依赖软件</h2><ul>
<li><p>安装VS2015或VS2017</p>
<ul>
<li>VS2017的安装选项<img src="/2021/06/01/4-Tutorials/OpenSim/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/1586142260410.png" class>
<img src="/2021/06/01/4-Tutorials/OpenSim/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/1586142274169.png" class>
<img src="/2021/06/01/4-Tutorials/OpenSim/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/1586142312200.png" class>
</li>
</ul>
</li>
<li><p>安装<a href="https://git-scm.com/downloads">git</a></p>
</li>
<li>安装<a href="https://cmake.org/download/">cmake</a></li>
<li>安装<a href="https://chocolatey.org/">chocolatey</a></li>
<li>以管理员打开<strong>PowerShell</strong>，运行一下代码（本步骤需科学上网）<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">choco</span> install python<span class="number">2</span> jdk<span class="number">8</span> swig</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Step2-编译依赖项"><a href="#Step2-编译依赖项" class="headerlink" title="Step2 编译依赖项"></a>Step2 编译依赖项</h2><ul>
<li>打开<strong>PowerShell</strong>，且切换至合适路径，下载源码<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/opensim-org/</span>opensim-core.git</span><br></pre></td></tr></table></figure></li>
<li>新建编译文件夹，并进入<figure class="highlight dos"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> opensim_dependencies_build</span><br><span class="line"><span class="built_in">cd</span> .\opensim_dependencies_build</span><br></pre></td></tr></table></figure></li>
<li>生成编译配置文件<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">cmake</span></span> ..\opensim-core\dependencies -G<span class="string">&quot;Visual Studio 15 2017 Win64&quot;</span> -DCMAKE_INSTALL_PREFIX=<span class="string">&quot;..\opensim_dependencies_install&quot;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>对于VS2015，输入以下指令</p>
</blockquote>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">cmake</span></span> ..\opensim-core\dependencies -G<span class="string">&quot;Visual Studio 14 2015 Win64&quot;</span> -DCMAKE_INSTALL_PREFIX=<span class="string">&quot;..\opensim_dependencies_install&quot;</span></span><br></pre></td></tr></table></figure>
<img src="/2021/06/01/4-Tutorials/OpenSim/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/1586143165609.png" class>
<ul>
<li>开始编译依赖项（包括Simbody 、Biomechanical-ToolKit Core、docopt.cpp等）<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">cmake</span> --<span class="comment">build</span> <span class="string">.</span> --<span class="comment">config</span> <span class="comment">RelWithDebInfo</span> -- <span class="comment">/maxcpucount:8</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>这一步可能会出现如下错误</p>
</blockquote>
<img src="/2021/06/01/4-Tutorials/OpenSim/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/1592020228095.png" class>
<blockquote>
<p>这个错误是由于源码中的部分文件含有中文系统无法识别的字符，打开查看如下文件</p>
</blockquote>
<img src="/2021/06/01/4-Tutorials/OpenSim/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/1592020209417.png" class>
<blockquote>
<p>所有和加速度有关的符合都有乱码。在不改系统语言的情况下，可以将文件中的乱码删除，重新编译即可</p>
</blockquote>
<img src="/2021/06/01/4-Tutorials/OpenSim/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/1592020274065.png" class>
<h2 id="Step3-编译源码"><a href="#Step3-编译源码" class="headerlink" title="Step3 编译源码"></a>Step3 编译源码</h2><ul>
<li>移动路径，并新建源码编译文件夹<figure class="highlight dos"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">mkdir</span> opensim_build</span><br><span class="line"><span class="built_in">cd</span> .\opensim_build</span><br></pre></td></tr></table></figure></li>
<li>编译配置<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">cmake <span class="built_in">..</span>\opensim-core -G<span class="string">&quot;Visual Studio 15 2017 Win64&quot;</span> <span class="attribute">-DCMAKE_INSTALL_PREFIX</span>=<span class="string">&quot;..\opensim_install&quot;</span> <span class="attribute">-DOPENSIM_DEPENDENCIES_DIR</span>=<span class="string">&quot;..\opensim_dependencies_install&quot;</span> <span class="attribute">-DBUILD_JAVA_WRAPPING</span>=ON <span class="attribute">-DBUILD_PYTHON_WRAPPING</span>=ON <span class="attribute">-DWITH_BTK</span>=ON</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>出现错误</p>
</blockquote>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Could NOT <span class="keyword">find</span> PythonInterp: Found unsuitable <span class="keyword">version</span> <span class="string">&quot;2.7.17&quot;</span>, but</span><br><span class="line">  required <span class="keyword">is</span> at least <span class="string">&quot;3&quot;</span> (found C:/Python27/<span class="keyword">python</span>.<span class="keyword">exe</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>貌似对Python版本的要求不一样了，再装一下Python3，并写在Python2</p>
</blockquote>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">choco</span> install python<span class="number">3</span></span><br><span class="line"><span class="attribute">choco</span> uninstall python<span class="number">2</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>重新配置</p>
</blockquote>
<p>4.OpenSim源码编译<img src="/2021/06/01/4-Tutorials/OpenSim/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/1586144793154.png" alt></p>
<ul>
<li>开始编译 <figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">cmake</span> --<span class="comment">build</span> <span class="string">.</span> --<span class="comment">config</span> <span class="comment">RelWithDebInfo</span> -- <span class="comment">/maxcpucount:8</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>又出现错误</p>
<img src="/2021/06/01/4-Tutorials/OpenSim/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/1586147266768.png" class>
</blockquote>
</li>
</ul>
<blockquote>
<p>看起来是Java的问题，发现swig版本为4.0.1，要求是3.0.8以上，因此重装swig3.0.8版本</p>
</blockquote>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">choco</span> install swig --version <span class="number">3</span>.<span class="number">0</span>.<span class="number">8</span> --force</span><br></pre></td></tr></table></figure>
<blockquote>
<p>删除<code>opensim_build</code>文件夹内容后，重新配置并编译，通过（耗时较长）</p>
</blockquote>
<img src="/2021/06/01/4-Tutorials/OpenSim/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/1586158357360.png" class>
<ul>
<li>进行测试<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">ctest</span> --<span class="comment">build</span><span class="literal">-</span><span class="comment">config</span> <span class="comment">RelWithDebInfo</span> --<span class="comment">parallel</span> <span class="comment">8</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>Matlab部分的是没问题，Python好像有点问题，暂时不用Python，不管它</p>
</blockquote>
<img src="/2021/06/01/4-Tutorials/OpenSim/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/1586158893776.png" class>
<ul>
<li>安装到指定文件夹<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">cmake</span> --<span class="comment">build</span> <span class="string">.</span> --<span class="comment">config</span> <span class="comment">RelWithDebInfo</span> --<span class="comment">target</span> <span class="comment">install</span> -- <span class="comment">/maxcpucount:8</span></span><br></pre></td></tr></table></figure>
<img src="/2021/06/01/4-Tutorials/OpenSim/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/1586159090955.png" class>
</li>
</ul>
<blockquote>
<p>安装完成</p>
</blockquote>
<h2 id="Step4-添加环境变量"><a href="#Step4-添加环境变量" class="headerlink" title="Step4 添加环境变量"></a>Step4 添加环境变量</h2><ul>
<li>将<code>&lt;FULL-DIR&gt;\opensim_install\bin</code>路径添加到系统的全局变量<img src="/2021/06/01/4-Tutorials/OpenSim/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/1586159421732.png" class>
<img src="/2021/06/01/4-Tutorials/OpenSim/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/1586159461057.png" class>
<img src="/2021/06/01/4-Tutorials/OpenSim/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/1586159495841.png" class>
<img src="/2021/06/01/4-Tutorials/OpenSim/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/1586159953211.png" class>
<img src="/2021/06/01/4-Tutorials/OpenSim/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/1586160055552.png" class>
</li>
</ul>
<h2 id="Step5-配置Matlab"><a href="#Step5-配置Matlab" class="headerlink" title="Step5 配置Matlab"></a>Step5 配置Matlab</h2><p>在Matlab运行如下文件配置OpenSim，之后重新打开Matlab即可调用OpenSim接口<br><img src="/2021/06/01/4-Tutorials/OpenSim/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/1592216470893.png" class></p>
<h2 id="Step6-简单测试"><a href="#Step6-简单测试" class="headerlink" title="Step6 简单测试"></a>Step6 简单测试</h2><ul>
<li><p>测试MATLAB调用</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">import org.opensim.modeling.*<span class="comment">;</span></span><br><span class="line"><span class="attribute">model</span> = Model()<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<img src="/2021/06/01/4-Tutorials/OpenSim/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/1586160641438.png" class>
</li>
<li><p>测试示例程序</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">opensim_install<span class="symbol">\R</span>esources<span class="symbol">\C</span>ode<span class="symbol">\M</span>atlab<span class="symbol">\D</span>ynamic_Walker_Challenge<span class="symbol">\D</span>esignMainStarter.m</span><br></pre></td></tr></table></figure>
<img src="/2021/06/01/4-Tutorials/OpenSim/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/1586160796721.png" class>
</li>
</ul>
]]></content>
      <categories>
        <category>tutorials</category>
      </categories>
      <tags>
        <tag>OpenSim</tag>
      </tags>
  </entry>
  <entry>
    <title>英语语法 5 - 不定式</title>
    <url>/2022/01/10/1-Course/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/05-%E4%B8%8D%E5%AE%9A%E5%BC%8F/</url>
    <content><![CDATA[<img src="/2022/01/10/1-Course/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/05-%E4%B8%8D%E5%AE%9A%E5%BC%8F/image-20220912230512184.png" class title="image-20220912230512184">
<span id="more"></span>
<p>英文中的非谓语包括三种：不定式、动名词和分词(过去分词、现在分词)。</p>
<p>不定式，<strong>即不一定是什么词性的成分</strong>，可以当名词、形容词和副词来使用，<strong>能够在句子充当除谓语外的任何成分</strong>。</p>
<h2 id="20-1-不定式的作用"><a href="#20-1-不定式的作用" class="headerlink" title="20.1 不定式的作用"></a>20.1 不定式的作用</h2><ul>
<li><strong>做主语，一般采用it作形式主语，而将to do表示的主语置于句尾，用for来引出不定式的逻辑主语</strong><ul>
<li>It is impossible for us to master English in a short time.</li>
<li>英文思维中没有“we are impossible…”的表达，improssible只能用来形容物，因此要用it is impossible for us to do结构</li>
</ul>
</li>
<li><strong>作宾语</strong><ul>
<li>动词+to do，不定式的逻辑主语与主句主语一致<ul>
<li>I hope to see you again.</li>
<li>This company refused to cooperate with us.</li>
</ul>
</li>
<li>动词+疑问词+to do<ul>
<li>I wonder who to invite.</li>
</ul>
</li>
<li>动词+it+宾补+to do，动+宾+宾补结构必须用it作形式宾语（动词不定式或that从句都需要用it，名词短语和what从句则不用）<ul>
<li>I think it hard to answer the question in one go.</li>
<li>The anthropological concept of “culture”, like the concept of “set” in mathematics, is an abstract concept which makes possible immense amounts of concrete research and understanding.</li>
</ul>
</li>
</ul>
</li>
<li><strong>作宾语补足语</strong><ul>
<li>Allow me to drink to your success!</li>
</ul>
</li>
<li><strong>作定语，名词+to do</strong><ul>
<li>宾语关系，修饰名词逻辑上充当不定式的宾语<ul>
<li>I have a letter to write.</li>
<li>She has four children to take care of.</li>
</ul>
</li>
<li>主语关系，修饰名词逻辑上充当不定式动词的主语<ul>
<li>The man to help to you is Johnson.</li>
<li>The next train to arrive is from New York.</li>
</ul>
</li>
<li>同位语关系，名词与不定式短语构成相互说明关系，所修饰名词应当是由与不定式搭配的词演化而来<ul>
<li>The need to love and to be loved seems universal.</li>
</ul>
</li>
<li>状语关系，所修饰名词在逻辑上充当不定式的状语<ul>
<li>There are two basic ways to see growth: one as a product, the other as a process.</li>
</ul>
</li>
<li>补语关系，所修饰名词在逻辑上充当不定式的补语<ul>
<li>The thing (for you) to be these days is a gold-collar.</li>
</ul>
</li>
</ul>
</li>
<li><strong>形容词+to do</strong>，需要根据形容词的语义特点来分析句子主语和to do之间的逻辑语义关系<ul>
<li>宾语关系，<strong>形容词侧重于事，但表层结构为人作主语，深层结构为不定式做逻辑主语</strong>，可以根据深层结构对句子进行变换<ul>
<li>He is interesting to listen to. = It’s interesting to listen to him.</li>
<li>He is easy to fool. = It’s easy to fool him.</li>
<li><strong>不定式动词不用被动（仅限形容词+to do的形式）！ He is easy to be fooled.</strong></li>
<li><strong>不定式后面不能再加宾语! He is easy to fool him.</strong></li>
</ul>
</li>
<li>宾语关系，形容词侧重事件特性，物做主语，不能进行句子变换<ul>
<li>The book is interesting to buy.</li>
<li>The book is interesting to read.</li>
</ul>
</li>
<li>主语关系，形容词通常为对人的评价，可以用it is句型改写<ul>
<li>He is kind to help us. = It is kind of him to help us.</li>
</ul>
</li>
<li>主语关系，形容词表情感态度，无法改写<ul>
<li>He is glad to help us.</li>
</ul>
</li>
<li>主语关系，形容词用来说明不定式动词，可作为副词修饰不定式动词<ul>
<li>He is show to react.</li>
</ul>
</li>
</ul>
</li>
<li><strong>作状语，主要是目的状语</strong>，<strong>注意不定式的逻辑主语和主句主语应当一致，或用for引出逻辑主语</strong>；only to do, so…as to do/such as to do, too…to do引导的不定式表结果状语<ul>
<li>I quate others in order better to express my own self.</li>
<li>For any adhesive to make a really strong bond, the surfaces to be glued must be absolutely clean and free from moisture or grease.</li>
<li>We hurried to the railway station, only to find the train had just left.</li>
</ul>
</li>
<li><strong>独立使用的不定式</strong><ul>
<li>不定式作独立成分，修饰整个句子，to begin with, to tell the truth, to make a long story short, so to speak, to be breif/exact/frank/honest, to say the lesat, to say nothing of<ul>
<li>To begin with, on behalf of all your American guests, I wish to thank you for the incomparable hospitality.</li>
</ul>
</li>
<li>不定式引导独立的句子，表达愿望、担心、惊讶等强烈情感，to think, to imagine<ul>
<li>To imagine even for a minute that I would do a thing like that on purpose.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="20-2-不定式的逻辑主语"><a href="#20-2-不定式的逻辑主语" class="headerlink" title="20.2 不定式的逻辑主语"></a>20.2 不定式的逻辑主语</h2><p><strong>逻辑主语都是针对非谓语而言，表示非谓语的执行者</strong>，区别与句子结构上的句法主语</p>
<ul>
<li><strong>for+名词/代词+to do</strong><ul>
<li>The father will be proud for his son to win the gold medal.</li>
</ul>
</li>
<li><strong>在部分形容词+to do结构中，需要使用of+名词/代词+to do</strong><ul>
<li>It’s wise of you <strong>not to argue</strong> with your boss.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="20-3-不定式的时态和语态"><a href="#20-3-不定式的时态和语态" class="headerlink" title="20.3 不定式的时态和语态"></a>20.3 不定式的时态和语态</h2><p>不定式的六种形式：to do, to be done, to have done, to have been done, to be doing, to have been doing</p>
<ul>
<li>被动式，<strong>当主句中没有出现执行者或不定式所修饰的成分是不定式动作的承受者，则不定式用被动式</strong><ul>
<li>It’s an honor for me to be invited to address the international conference.</li>
<li>The book is not allowed to be taken out of the library.(双重被动)</li>
</ul>
</li>
<li>完成式，<strong>表示不定式是在谓语动作之前的动作，通常谓语表态度情感、观点、推断</strong><ul>
<li>I’m sorry to have kept you waiting so long.</li>
<li>Humans are believed <strong>to have evolved from the primate species.</strong></li>
<li>The rain seems to have stopped.</li>
</ul>
</li>
<li>进行时，<strong>表示与谓语动作同时发生动作，通常谓语为seem, happen, pretend</strong><ul>
<li>He <strong>pretended to be sleeping</strong> when she came in.</li>
</ul>
</li>
<li>完成进行时，<strong>表不定式动作在谓语动词之前已经开始并一直在持续</strong><ul>
<li>He seems to have been sitting there all day.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="20-4-省略to的不定式"><a href="#20-4-省略to的不定式" class="headerlink" title="20.4 省略to的不定式"></a>20.4 省略to的不定式</h2><ul>
<li><strong>在某些动词的复合宾语中</strong>，如使役动词let, make, have, 感觉动词see, hear, watch, notice, feel, observe<ul>
<li>The minister had his secretaries <strong>arrange</strong> a press conference.</li>
</ul>
</li>
<li><strong>在特定的句型结构中</strong><ul>
<li>部分固定短语：had better, would rather, would sooner, would just as soon, cannot but, cannot choose but, cannot help but<ul>
<li>You looked so beautiful and lovely I couldn’t help but fall in love with you.</li>
</ul>
</li>
<li>More than, rather than, other than, than后面不加to的不定式<ul>
<li>She preferred to give herself up rather than hide herself.</li>
</ul>
</li>
<li>do nothing/anything/everything but do句型中<ul>
<li>I have nothing to do but wait.</li>
</ul>
</li>
<li>在why(not)+do句子中<ul>
<li>Why not take a holiday?</li>
</ul>
</li>
<li>在并列结构中，to经常被省略，但若两个不定式之间有对比含义时，需要保留<ul>
<li>Do you want to have lunch now or wait till later?</li>
<li>The need to love and to be loved seems universal.</li>
</ul>
</li>
<li>在一些固定的动词搭配中，make do, make believe, let drop, let fall, let fly, let slip, let go of, hear say, leave go of</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>course</category>
      </categories>
      <tags>
        <tag>英语语法</tag>
      </tags>
  </entry>
  <entry>
    <title>轨迹优化与直接配点法</title>
    <url>/2020/04/24/4-Tutorials/OpenSim/5.%E8%BD%A8%E8%BF%B9%E4%BC%98%E5%8C%96%E4%B8%8E%E7%9B%B4%E6%8E%A5%E9%85%8D%E7%82%B9%E6%B3%95/</url>
    <content><![CDATA[<p>本文主要讨论轨迹优化问题中的直接配点法，希望通过此教程帮助理解轨迹优化问题的基本概念与直接配点法的相关理论基础，最后我们还会讨论一些具体实现问题。直接配点法最终是通过非线性规划求解器来得到最终结果，因此在阅读本文之间可以先了解NLP问题相关基础知识，当然这并不影响对本文的理解，本文仅需要一些简单的高等数学与微分方程的知识。</p>
<span id="more"></span>
<h2 id="轨迹优化问题"><a href="#轨迹优化问题" class="headerlink" title="轨迹优化问题"></a>轨迹优化问题</h2><h3 id="问题简介"><a href="#问题简介" class="headerlink" title="问题简介"></a>问题简介</h3><p>轨迹用来描述一个物体的运动过程，通常是关于时间的变量。轨迹优化一种用于寻找最佳轨迹选择的方法，通常是通过选择合适的系统输入或控制量，是系统完成期望的运动过程。在控制领域，轨迹优化近似于最优控制，但从更广的概念上来讲，轨迹优化更具一般性。</p>
<p>下面我们用一个例子来进一步说明轨迹优化问题。</p>
<img src="/2020/04/24/4-Tutorials/OpenSim/5.%E8%BD%A8%E8%BF%B9%E4%BC%98%E5%8C%96%E4%B8%8E%E7%9B%B4%E6%8E%A5%E9%85%8D%E7%82%B9%E6%B3%95/1587399082007.png" class>
<p>如图所示，一个滑块放置在光滑地面上，并受到一个水平方向的作用力。我们想要滑块在里的作用下，在1s的时间内从开始位置运动到指定位置，并刚好停在该处。这个问题存在着无数种可能的运动轨迹，进一步，我们希望从中确定一条最优的轨迹，如图所示。</p>
<img src="/2020/04/24/4-Tutorials/OpenSim/5.%E8%BD%A8%E8%BF%B9%E4%BC%98%E5%8C%96%E4%B8%8E%E7%9B%B4%E6%8E%A5%E9%85%8D%E7%82%B9%E6%B3%95/1587400040884.png" class>
<img src="/2020/04/24/4-Tutorials/OpenSim/5.%E8%BD%A8%E8%BF%B9%E4%BC%98%E5%8C%96%E4%B8%8E%E7%9B%B4%E6%8E%A5%E9%85%8D%E7%82%B9%E6%B3%95/1587400055329.png" class>
<p>我们可以把这个问题用数学语言形式化。系统满足如下的动力学方程：</p>
<script type="math/tex; mode=display">
\dot{x}=\nu, \quad \dot{\nu}=u</script><p>并要求满足如下的边界约束：</p>
<script type="math/tex; mode=display">
\begin{array}{ll}
x(0)=0, & x(1)=1 \\
\nu(0)=0, & \nu(1)=0
\end{array}</script><p>轨迹优化关心在一定指标下的最优轨迹，这样的指标可以用如下的目标函数来描述：</p>
<script type="math/tex; mode=display">
\min _{u(t), x(t), \nu(t)} \int_{0}^{1} u^{2}(\tau) d \tau</script><h3 id="形式化描述"><a href="#形式化描述" class="headerlink" title="形式化描述"></a>形式化描述</h3><p>一般来说，轨迹优化问题通过在一定的约束条件下优化如下的目标函数来得到最优轨迹：</p>
<script type="math/tex; mode=display">
\min _{t_{0}, t_{F}, \boldsymbol{x}(t), \boldsymbol{u}(t)} \underbrace{J\left(t_{0}, t_{F}, \boldsymbol{x}\left(t_{0}\right), \boldsymbol{x}\left(t_{F}\right)\right)}_{\text {Mayer Term }}+\underbrace{\int_{t_{0}}^{t_{F}} w(\tau, \boldsymbol{x}(\tau), \boldsymbol{u}(\tau)) d \tau}_{\text {Lagrange Term }}</script><p>其中的约束条件包含如下形式：<br>系统的动力学约束：</p>
<script type="math/tex; mode=display">
\dot{\boldsymbol{x}}(t)=\boldsymbol{f}(t, \boldsymbol{x}(t), \boldsymbol{u}(t))</script><p>路径约束：</p>
<script type="math/tex; mode=display">
\boldsymbol{h}(t, \boldsymbol{x}(t), \boldsymbol{u}(t)) \leq \mathbf{0}</script><p>边界约束：</p>
<script type="math/tex; mode=display">
\boldsymbol{g}\left(t_{0}, t_{F}, \boldsymbol{x}\left(t_{0}\right), \boldsymbol{x}\left(t_{F}\right)\right) \leq \mathbf{0}</script><p>和状态量与控制量边界：</p>
<script type="math/tex; mode=display">
\begin{array}{l}
\boldsymbol{x}_{\mathrm{low}} \leq \boldsymbol{x}(t) \leq \boldsymbol{x}_{\mathrm{upp}} \\
\boldsymbol{u}_{\mathrm{low}} \leq \boldsymbol{u}(t) \leq \boldsymbol{u}_{\mathrm{upp}}
\end{array}</script><p>由于最终我们想要求得的是控制量关于时间的具体函数形式，而非一个值或一个参数，因此轨迹优化问题也可以理解为在一定约束或大量约束下的泛函问题。</p>
<h3 id="变分法求解"><a href="#变分法求解" class="headerlink" title="变分法求解"></a>变分法求解</h3><p>（对变分法不熟悉的可以跳过本部分）<br>针对泛函问题，可以采用变分法进行求解。以滑块移动的问题为例，由于其目标函数可以表示为如下形式：</p>
<script type="math/tex; mode=display">
J=\int_{0}^{1} u^{2}(\tau) d \tau=\int_{0}^{1} \ddot{x}^{2}(\tau) d \tau</script><p>因此可以构建拉格朗日方程：</p>
<script type="math/tex; mode=display">
\mathcal{L}(t, x, \dot{x}, \ddot{x})=\mathcal{L}(\ddot{x})=\ddot{x}^{2}</script><p>对此应用推广的欧拉-拉格朗日方程：</p>
<script type="math/tex; mode=display">
\frac{\partial \mathcal{L}}{\partial x^{*}}-\frac{d}{d t} \frac{\partial \mathcal{L}}{\partial \dot{x}^{*}}-\frac{d^{2}}{d t^{2}} \frac{\partial \mathcal{L}}{\partial \dot{x}^{*}}=0</script><p>可得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
(0)-(0)-\frac{d^{2}}{d t^{2}}\left(2 \ddot{x}^{*}\right) &=0 \\
\frac{d^{4}}{d t^{4}} x^{*} &=0
\end{aligned}</script><p>因此$x$具有三次函数的形式，将相应的边界条件代入，得到最优轨迹：</p>
<script type="math/tex; mode=display">
u^{*}(t)=6-12 t, \quad x^{*}(t)=3 t^{2}-2 t^{3}</script><h2 id="直接配点法-direct-collocation-methods"><a href="#直接配点法-direct-collocation-methods" class="headerlink" title="直接配点法-direct collocation methods"></a>直接配点法-direct collocation methods</h2><p>对于简单问题，使用变分法可以很快的求解出最优轨迹，但对于复杂的轨迹优化问题，状态变量或控制变量有可能达到几十万的维度，约束条件也会非常复杂。因此有必要研究通过数值方法求解轨迹优化问题，接下来我们介绍其中一种数值求解的思想，也就是直接配点法。对于一些其他的方法，例如shooting methods，则不在本文的讨论范围之内。接下来我们先通过滑块移动的问题来说明直接配点法的思想，之后再详细介绍梯形聚点法。</p>
<p>直接配点法的核心思想是将连续时间曲线离散为有限时间序列，从而把轨迹规划问题转化大规模非线性规划问题。首先，我们对轨迹进行离散化，将状态变量$x(t)$和$v(t)$表示为一系列离散时刻上的值，也称为配置点：</p>
<script type="math/tex; mode=display">
\begin{array}{l}
t \rightarrow t_{0} \ldots t_{k} \ldots t_{N} \\
x \rightarrow x_{0} \ldots x_{k} \ldots x_{N} \\
\nu \rightarrow \nu_{0} \ldots \nu_{k} \ldots \nu_{N}\\
u \rightarrow u_{0} \ldots u_{k} \ldots u_{N} \\
\end{array}</script><p>这些配置点实际上就是最终转化的NLP问题优化变量，$N$表示离散的细化程度，N越大则离散化误差越小，但优化单独越大。接下来我们要把原始问题用这些配置点进行近似表示，其核心思想是两个配置点之间的状态变化等于系统动力学的积分：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\dot{x} &=\nu \\
\int_{t_{k}}^{t_{k+1}} \dot{x} d t &=\int_{t_{k}}^{t_{k+1}} \nu d t \\
x_{k+1}-x_{k} & \approx \frac{1}{2}\left(h_{k}\right)\left(\nu_{k+1}+\nu_{k}\right)
\end{aligned}</script><p>由于位置的微分等于速度，对等式两侧进行积分，从时刻$t_k$积分到时刻$t_{k+1}$。等式左侧自然等于两个状态之间的差值，而对于等式右侧我们用梯形积分公式进行近似。这里$h_k=(t_{k+1}-t_k)$。</p>
<p>我们把速度与作用力的动力学关系同样转化成上面的形式，忽略由梯形积分近似的误差，得到以下由配置点表示的约束方程：</p>
<script type="math/tex; mode=display">
\begin{array}{l}
x_{k+1}-x_{k}=\frac{1}{2}\left(h_{k}\right)\left(\nu_{k+1}+\nu_{k}\right) \\
\nu_{k+1}-\nu_{k}=\frac{1}{2}\left(h_{k}\right)\left(u_{k+1}+u_{k}\right)
\end{array}</script><p>注意到通过离散化，我们把原来连续的动力学方程，转化为N个等式约束。当然为了满足题目要求，配置点还要满足以下的约束：</p>
<script type="math/tex; mode=display">
\begin{array}{ll}
x_{0}=0, & x_{N}=1 \\
\nu_{0}=0, & \nu_{N}=0
\end{array}</script><p>最后，通过采用梯形积分近似的方法，将目标函数也用配置点进行表示：</p>
<script type="math/tex; mode=display">
\min _{u(t)} \int_{t_{0}}^{t_{N}} u^{2}(\tau) d \tau \quad = \min _{u_{0} \ldots u_{N}} \sum_{k=0}^{N-1} \frac{1}{2}\left(h_{k}\right)\left(u_{k}^{2}+u_{k+1}^{2}\right)</script><p>至此，滑块移动问题被完全转化为一个3N个优化参数（配置点），2N+4个约束的非线性规划问题，采用类似内点法的非线性规划求解器（IPOPT）进行求解，就可以得到问题数值结果。</p>
<h2 id="梯形配点法"><a href="#梯形配点法" class="headerlink" title="梯形配点法"></a>梯形配点法</h2><p>在上面的例子中，我们采用梯形公式来近似积分，将问题中的所用连续问题转化为离散问题，这种方法称为梯形配点法，下面对其进行详细说明。</p>
<h3 id="积分方程的近似"><a href="#积分方程的近似" class="headerlink" title="积分方程的近似"></a>积分方程的近似</h3><p>积分方程一般出现在目标函数中，梯形配点法中采用被积函数两个时刻之间的梯形面积来近似积分：</p>
<script type="math/tex; mode=display">
\int_{t_{0}}^{t_{F}} w(\tau, \boldsymbol{x}(\tau), \boldsymbol{u}(\tau)) d \tau \quad \approx \sum_{k=0}^{N-1} \frac{1}{2} h_{k} \cdot\left(w_{k}+w_{k+1}\right)</script><h3 id="微分方程的近似"><a href="#微分方程的近似" class="headerlink" title="微分方程的近似"></a>微分方程的近似</h3><p>微分方程一般出现在动力学方程中。直接配点法的关键特征之一是，它将系统动力学表示为一组约束，称为配点约束。梯形配点法将动力学方程写成积分形式，然后用梯形求积法来近似积分：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\dot{\boldsymbol{x}} &=\boldsymbol{f} \\
\int_{t_{k}}^{t_{k+1}} \boldsymbol{x} d t &=\int_{t_{k}}^{t_{k+1}} \boldsymbol{f} d t \\
\boldsymbol{x}_{k+1}-\boldsymbol{x}_{k} & \approx \frac{1}{2} h_{k} \cdot\left(\boldsymbol{f}_{k+1}+\boldsymbol{f}_{k}\right)
\end{aligned}</script><p>然后在每对配置点之间都建立这种近似的约束关系：</p>
<script type="math/tex; mode=display">
\boldsymbol{x}_{k+1}-\boldsymbol{x}_{k}=\frac{1}{2} h_{k} \cdot\left(\boldsymbol{f}_{k+1}+\boldsymbol{f}_{k}\right), \quad k \in 0, \ldots,(N-1)</script><h3 id="原始约束"><a href="#原始约束" class="headerlink" title="原始约束"></a>原始约束</h3><p>离散后的配置点，应当满足原问题的状态约束、控制约束、路径约束、边界约束：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\boldsymbol{x}<\mathbf{0} \quad &\rightarrow \quad \boldsymbol{x}_{k}<\mathbf{0} \quad \forall k\\
\boldsymbol{u}<\mathbf{0} \quad &\rightarrow \quad \boldsymbol{u}_{k}<\mathbf{0} \quad \forall k\\
\boldsymbol{g}(t, \boldsymbol{x}, \boldsymbol{u})<\mathbf{0} \quad &\rightarrow \quad \boldsymbol{g}\left(t_{k}, \boldsymbol{x}_{k}, \boldsymbol{u}_{k}\right)<\mathbf{0} \quad \forall k\\
\boldsymbol{h}\left(t_{0}, \boldsymbol{x}\left(t_{0}\right), \boldsymbol{u}\left(t_{0}\right)\right)<\mathbf{0} \quad &\rightarrow \quad \boldsymbol{h}\left(t_{0}, \boldsymbol{x}_{0}, \boldsymbol{u}_{0}\right)<\mathbf{0} \quad 
\end{aligned}</script><h3 id="曲线插值"><a href="#曲线插值" class="headerlink" title="曲线插值"></a>曲线插值</h3><p>为了从配置点恢复连续轨迹，需要进行曲线插值。梯形配点法的将控制轨迹和系统动力学近似为分段线性函数，也称为线性样条。构造样条曲线时，术语结点<em>knot point </em>用来表示连接两个多项式段的任何点，对于梯形配点法而言，样条的结点与配置点是重合的。首先通过分段线性插值重建控制轨迹（$\tau=t-t_{k}$，$h_{k}=t_{k+1}-t_{k}$）：</p>
<script type="math/tex; mode=display">
\boldsymbol{u}(t) \approx \boldsymbol{u}_{k}+\frac{\tau}{h_{k}}\left(\boldsymbol{u}_{k+1}-\boldsymbol{u}_{k}\right)</script><img src="/2020/04/24/4-Tutorials/OpenSim/5.%E8%BD%A8%E8%BF%B9%E4%BC%98%E5%8C%96%E4%B8%8E%E7%9B%B4%E6%8E%A5%E9%85%8D%E7%82%B9%E6%B3%95/1587487370709.png" class>
<p>之后重建状态变量的轨迹，需要说明的是，状态变量的轨迹是二次样条曲线的形式。因为在梯形配点法中，系统动力学是用线性样条近似，而状态轨迹是动力学方程的积分，因此具有二次形式。显然这样重建出的状态轨迹更准确，如下图所示。</p>
<script type="math/tex; mode=display">
\boldsymbol{f}(t)=\dot{\boldsymbol{x}}(t) \approx \boldsymbol{f}_{k}+\frac{\tau}{h_{k}}\left(\boldsymbol{f}_{k+1}-\boldsymbol{f}_{k}\right)</script><script type="math/tex; mode=display">
\boldsymbol{x}(t)=\int \dot{\boldsymbol{x}}(t) d \tau \approx \boldsymbol{c}+\boldsymbol{f}_{k} \tau+\frac{\tau^{2}}{2 h_{k}}\left(\boldsymbol{f}_{k+1}-\boldsymbol{f}_{k}\right)</script><script type="math/tex; mode=display">
\boldsymbol{x}(t) \approx \boldsymbol{x}_{k}+\boldsymbol{f}_{k} \tau+\frac{\tau^{2}}{2 h_{k}}\left(\boldsymbol{f}_{k+1}-\boldsymbol{f}_{k}\right)</script><img src="/2020/04/24/4-Tutorials/OpenSim/5.%E8%BD%A8%E8%BF%B9%E4%BC%98%E5%8C%96%E4%B8%8E%E7%9B%B4%E6%8E%A5%E9%85%8D%E7%82%B9%E6%B3%95/1587487392318.png" class>
<h2 id="实现问题"><a href="#实现问题" class="headerlink" title="实现问题"></a>实现问题</h2><p>接下来我们来讨论一些配点法实际实现时可能遇到的问题和解决方法。</p>
<h3 id="初始化问题"><a href="#初始化问题" class="headerlink" title="初始化问题"></a>初始化问题</h3><p>几乎所有的轨迹优化技术都需要一个良好的初始猜测来开始优化。良好的初始化将确保求解器快速地得到全局最优解，一个糟糕的初始化会导致非线性规划求解器无法解决一个正确的优化问题。初始猜测的选择会影响优化最终收敛到哪一个局部最小值，不合适的初始值会使求解器优化到一个局部极小值，而约束的存在使情况变得更糟，优化器甚至无法找到一个可行的解决方案。</p>
<p>轨迹优化的最佳初始化通常需要一些特定的知识，但也有一些通用的方法可以采用。通常建议尝试集中不同的初始化策略，检查他们是否都优化到同一个结果。最简单的初始方法是假设轨迹是状态空间的一条直线，当然也可以设计为可能预想到的结果。</p>
<p>对于更复杂的轨迹优化问题，我们建议先从一个简单的问题开始优化，以优化结果作为下一个优化问题的初始猜测，然后构造一系列优化问题，逐渐接近最终的问题。举例来说，让一个双足行走机器人以3.0m/s的速度奔跑或许是一个比较复杂的优化问题，你可以先从1.0m/s的行走开始优化，逐渐增加前进速度，直至达到期望的速度，在这过程中每次优化的结果都作为下一次优化的初始估计。</p>
<h3 id="网格细化"><a href="#网格细化" class="headerlink" title="网格细化"></a>网格细化</h3><p>直接配点法采用分段多项式样条函数来对轨迹曲线进行近似，显然离散的时间越短、多项式的阶数越高，则近似的精度越高。网格细分是在一系列不同的配置网格上求解轨迹优化问题的过程，也称为配置网格。一般情况下，初始的网格比较粗糙，配置点数量较少，并采用较低阶的配置方法，而后续的网格有更多的点和更高阶的配置方法。这种迭代策略是为了以最少的计算工作量获得最精确的解决方案：初始的粗网格位置计算量小，并能给出一个比较好的初始估计，之后通过更精细的网格配置得到更准确的结果。</p>
<img src="/2020/04/24/4-Tutorials/OpenSim/5.%E8%BD%A8%E8%BF%B9%E4%BC%98%E5%8C%96%E4%B8%8E%E7%9B%B4%E6%8E%A5%E9%85%8D%E7%82%B9%E6%B3%95/1587490201492.png" class>
<h3 id="误差分析"><a href="#误差分析" class="headerlink" title="误差分析"></a>误差分析</h3><p>在所述的轨迹优化方法中存在两种形式的数值误差：转换误差和求解误差，这里我们主要关注前一种误差，即量化离散所带来的误差。衡量误差的标准有很多，这里我们用候选轨迹的动力学误差进行评价。由于在任何时刻系统都要满足动力学方程，因此有:</p>
<script type="math/tex; mode=display">
\dot{\boldsymbol{x}}^{*}(t)=\boldsymbol{f}\left(t, \boldsymbol{x}^{*}(t), \boldsymbol{u}^{*}(t)\right)</script><p>公式中的变量都可以由配置点插值得到，因此动力学方程误差为：</p>
<script type="math/tex; mode=display">
\varepsilon(t)=\dot{\boldsymbol{x}}(t)-\boldsymbol{f}(t, \boldsymbol{x}(t), \boldsymbol{u}(t))</script><p>上式在配置点处应该严格等于零，但在配置点之间一般不为零。通过误差的积分可以量化转化误差：</p>
<script type="math/tex; mode=display">
\boldsymbol{\eta}_{k}=\int_{t_{k}}^{t_{k+1}}|\varepsilon(\tau)| d \tau</script><p>若转化误差大于一定水平，则需要进一步进行网格细化。</p>
]]></content>
      <categories>
        <category>仿真研究</category>
      </categories>
      <tags>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>非线性规划</title>
    <url>/2020/04/22/4-Tutorials/OpenSim/6.%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>优化是自然界和人类社会最为普遍行为，物理系统趋于较低的能量，化学分子相互作用以达到最小的电子势能，投资者寻求最佳收益，工程师寻求最佳性能，优化是宇宙运行的本质之一。在本文中，我们将主要讨论非线性规划的数值方法。</p>
<p>根据函数性质，优化问题可分为线性优化和非线性优化；根据是否含有约束，可以分为无约束优化和有约束优化。一般来说，有约束优化问题要比无约束优化问题更难求解，因此本文将先介绍非线性优化的求解算法，再介绍非线性规划的内点法。</p>
<span id="more"></span>
<h2 id="非线性优化"><a href="#非线性优化" class="headerlink" title="非线性优化"></a>非线性优化</h2><h3 id="问题描述与必要性条件"><a href="#问题描述与必要性条件" class="headerlink" title="问题描述与必要性条件"></a>问题描述与必要性条件</h3><p>非线性优化问题是指，对于一个给定的非线性函数$f(x)$，确定出使函数值最小的自变量$x$：</p>
<script type="math/tex; mode=display">\min _{x} f(x)</script><p>其中$f(x)$称为目标函数，$x$称为未知量或参数。实际情况中的最大化问题一般都可以通过简单的变换转化为最小值问题，因此我们仅考虑最小化一种情况。由高等数学可知，在无约束的情况下，该问题的解应满足如下一阶条件和二阶条件：</p>
<p>一阶必要条件：$\nabla f\left(x^{*}\right)=0$</p>
<p>二阶必要条件：$\nabla f(x^<em>)=0, \nabla^2 f(x^</em>)\ge 0$</p>
<p>对于参数为多维的情况，$\nabla f\left(x^{<em>}\right)$表示梯度向量，$\nabla^2 f\left(x^{</em>}\right)$表示海森矩阵，而符号$\ge$表示海森矩阵半正定。一阶必要条件表明目标函数达到极值点，而二阶必要条件进一步将其限定为极小值点。对于一般情况，二阶必要条件只能判定其为局部最优解，而不一定为全局最小值；只有当目标函数为凸函数时，局部极小才等价为全局极小值。</p>
<h3 id="非线性优化的数值方法"><a href="#非线性优化的数值方法" class="headerlink" title="非线性优化的数值方法"></a>非线性优化的数值方法</h3><p>对于复杂的非线性函数，计算机没办法根据必要条件直接得到解，而是一般通过数值迭代的方法从一个初始点一步步逼近问题的解$x^<em>$。用数学的语言表述为，从一个初始点$x_0$，通过构造一个迭代序列$\left\{x_{k}\right\}_{k=0}^{\infty}$，使$x_k\to x^</em>$。这种迭代的思路可以分为两种：线搜索算法和置信域算法。在本文中我们主要讨论线搜索的方法。</p>
<p>在线搜索策略中，算法每次迭代会先在当前参数$x_k$处确定一个参数的<strong>迭代方向</strong>$d_k$，然后让参数在该方向上移动一定<strong>步长</strong>$\alpha_k$，即：</p>
<script type="math/tex; mode=display">
x_{k+1}=x_k+\alpha_k d_k</script><h4 id="迭代步长"><a href="#迭代步长" class="headerlink" title="迭代步长"></a>迭代步长</h4><p>假定我们已经确定了一个迭代方向$d_k$，则原优化问题可以转化为一个一维搜索问题：</p>
<script type="math/tex; mode=display">\min _{\alpha>0} f\left(x_{k}+\alpha d_{k}\right)</script><p>我们可以进行精确一维搜索，采用例如二分法、黄金分割法来求出该一维问题的最佳步长；当然我们也可以采用非精确一维搜索来确定$\alpha_k$，只要其满足：</p>
<script type="math/tex; mode=display">f(x_k+\alpha_k d_k) < f(x_k)</script><p>实际上，在现代优化算法中，一般采取非精确一维搜索的策略，虽然其每次迭代目标函数的下降幅度不如精确一维搜索，但整体的优化效率更高。</p>
<h4 id="梯度法"><a href="#梯度法" class="headerlink" title="梯度法"></a>梯度法</h4><p>非线性优化的主要问题在于确定一个适当的迭代方向$d_k$。<strong>最速下降方向</strong>，即负梯度方向$-\nabla f(x_k)$是最明显的迭代方向，它本身就描述目标函数下降最快的方向。除了最速下降方向，任何与其夹角小于$\pi/2$的方向，都可以作为迭代方向，都能够保证目标函数下降。即$d_k=-B_k \nabla f_k$，$B_k$为·正定矩阵。如图所示，灰色表示原函数的等高线，蓝色向量表示目标函数梯度，同样指向了等高线的法向，红色表示一种可行的迭代方向。</p>
<img src="/2020/04/22/4-Tutorials/OpenSim/6.%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/1587611833869.png" class>
<p>上面我们已经说过，在确定了迭代方向后，可以采用线搜索的方法来确定合适的迭代步长。由于精确一维搜索比较耗时，因此往往采用非精确一维搜索策略，使$f_{k+1}&lt;f_k$：</p>
<script type="math/tex; mode=display">
x_{k+1}=x_k-\alpha_k\nabla f_k</script><p>梯度下降法简单直观，但对复杂问题的求解效果往往不太理想，尤其是当迭代点接近最优点时，函数梯度会变得很小，优化速度也因而变得很慢，下图所示。</p>
<img src="/2020/04/22/4-Tutorials/OpenSim/6.%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/1587611935345.png" class>
<h4 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a>牛顿法</h4><p>另一种更常用的方法是<strong>Newtown法</strong>。考虑对目标函数$f(x)$在$x=x_k$处进行二阶泰勒近似：</p>
<script type="math/tex; mode=display">
f\left(x_{k}+d\right) \approx f_{k}+d^{T} \nabla f_{k}+\frac{1}{2} d^{T} \nabla^{2} f_{k} d \stackrel{\text { def }}{=} m_{k}(d)</script><p>我们将其看作为关于步长$d$的函数。假定海森矩阵$\nabla^2 f_k$是整定的，对$m_k(d)$求导并令导数等于零可得：</p>
<script type="math/tex; mode=display">
d_{k}=-\left(\nabla^{2} f_{k}\right)^{-1} \nabla f_{k}</script><p>本质上来说牛顿法是通过在迭代点处，利用目标函数的一阶导和二阶导的信息来对目标函数进行估计，并用估计函数的最小值作为参数迭代的方向。下图展示了这种优化思路，绿色为所估计的函数。在牛顿法中，迭代方向$d_k$由迭代点$x_k$指向估计函数的最小值，因此有一个自然步长$\alpha=1$：</p>
<script type="math/tex; mode=display">
x_{k+1}=x_k-\left(\nabla^{2} f_{k}\right)^{-1} \nabla f_{k}</script><img src="/2020/04/22/4-Tutorials/OpenSim/6.%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/1587614043275.png" class>
<p>因为利用了目标函数更多的信息，因此牛顿法是一种比梯度法更有“远见”的算法。当估计函数比较接近目标函数时，尤其是接近最优解时，牛顿法的下降速度很快，具有二阶收敛性，也就是对于二次形式的目标函数，牛顿法可以通过一次迭代得到结果。</p>
<p>同时牛顿法也存在着一些的问题。一方面在优化初期时，对于目标函数的估计往往不太准确，导致优化性能大大下降；另一方面，二阶海森矩阵的计算非常困难。为了避免海森矩阵的计算问题，实际中更多的使用<strong>拟牛顿法</strong>，通过在迭代过程中目标函数和梯度信息来近似估计海森矩阵或海森矩阵的逆矩阵，再用该估计来计算迭代方向，例如<strong>BFGS</strong>算法等。</p>
<h2 id="非线性规划"><a href="#非线性规划" class="headerlink" title="非线性规划"></a>非线性规划</h2><p>非线性规划是指在一定约束条件下的优化问题，对于有约束优化我们一般用Programming来表示，其标准数学表述如下，其中约束包含等式约束和不等式约束：</p>
<script type="math/tex; mode=display">
\min _{x \in \mathbb{R}^{n}} f(x) \quad \text { subject to }\left\{\begin{array}{ll}
c_{i}(x)=0, & i \in \mathcal{E} \\
c_{i}(x) \geq 0, & i \in \mathcal{I}
\end{array}\right.</script><h3 id="必要性条件"><a href="#必要性条件" class="headerlink" title="必要性条件"></a>必要性条件</h3><p>在讨论具体的算法之前，我们要先研究一下约束优化的必要性条件。不同于无约束优化，有约束优化的最优值往往在约束边界上，因此不能采用无约束优化的必要性条件来判断约束优化。</p>
<p>对于只有等式约束$c_i(x)=0, i \in \mathcal{E}$的情况，我们可以构造Lagrange函数：</p>
<script type="math/tex; mode=display">
\mathcal{L}(x, \lambda)= f\left(x\right)-\lambda_E^T c_{E}\left(x\right)</script><p>$c_E(x)$表示等式约束构成的向量函数，$\lambda_E$表示Lagrange乘子构成参数向量。从而原约束优化问题的必要性条件可以由Lagrange函数的一阶导数给出：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\nabla_{x}\mathcal{L}(x, \lambda)&= \nabla f\left(x\right)- \lambda_E^T \nabla c_{E}\left(x\right) = 0\\
\nabla_{\lambda}\mathcal{L}(x, \lambda)&= c_E(x)=0
\end{aligned}</script><p>对于更一般的含有不等式约束的情况，这里给出其一阶必要性条件，即<strong>KKT条件</strong>：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\nabla_{x}\mathcal{L}(x, \lambda)= \nabla f\left(x\right)- \lambda_E^T \nabla c_{E}\left(x\right)- \lambda_I^T \nabla c_{I}\left(x\right) &= 0\\
c_{E}\left(x\right) &=0\\
c_{I}\left(x\right) & \geq 0 \\
\lambda_I & \geq 0 \\
\lambda^T c\left(x\right) &= 0
\end{aligned}</script><p>KKT条件中比较难理解的是最后一个等式，该等式主要针对不等式约束，也称为互补条件<strong>complementarity conditions</strong>。观察该等式可以看出，$\lambda$和$c(x)$其中必定有一个需要等于零，当$\lambda \ne 0$时，$c(x)=0$，则该约束处于“激活”状态，不等式约束退化成等式约束；当$c(x)\ne 0$时，$\lambda = 0$，则KKT条件的第一个等式将不包含该约束，即该约束“未激活”。</p>
<p>KKT条件为必要性条件，也就是用来判断所求参数是否为优化问题的解。其在约束优化中有非常重要的意义，几乎所有的约束优化算法的收敛性都需要借助KKT条件进行证明。</p>
<h3 id="序列二次型规划"><a href="#序列二次型规划" class="headerlink" title="序列二次型规划"></a>序列二次型规划</h3><p>我们先来研究一种相对简单的约束优化问题，即等式约束下的优化问题：</p>
<script type="math/tex; mode=display">
\begin{array}{c}
\min _{x} f(x) \\
\text { s.t. } \quad c(x)=0 \\
\end{array}</script><p>首先我们构造拉格朗日函数，将该约束优化问题转化为无约束优化问题：</p>
<script type="math/tex; mode=display">
\min _{x, \lambda} \mathcal{L}(x, \lambda)= f\left(x\right)-\lambda^T c\left(x\right)</script><p>之后采用牛顿法进行求解，对于一个初始估计$(x_0,\lambda_0)$，通过构造序列$\left\{\left(x_{k}, \lambda_{k}\right)\right\}$来逼近问题的解：</p>
<script type="math/tex; mode=display">
\left(x_{k+1}, \lambda_{k+1}\right)=\left(x_{k}, \lambda_{k}\right)+\left(d_{k}, d_{k}^{\lambda}\right)</script><p>正如我们在非线性优化里讨论的那样，下面公式左侧矩阵为拉格朗日函数的海森矩阵，右侧为拉格朗日函数的梯度向量：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{cc}
W_{k} & -A_{k}^{T} \\
-A_{k} & 0
\end{array}\right]\left(\begin{array}{c}
d_{k} \\
d_{k}^{\lambda}
\end{array}\right)=-\left(\begin{array}{c}
\nabla f_{k}- \lambda_{k} A_{k} \\
c_{k}
\end{array}\right)</script><script type="math/tex; mode=display">
W_{k}=\nabla_{x x}^{2} \mathcal{L}\left(x_{k}, \lambda_{k}\right), A_{k} = \nabla c(x)</script><p>接下来我们用一个例子来说明约束优化。首先考虑如下的约束优化问题：</p>
<script type="math/tex; mode=display">
\begin{array}{c}
\min _{x, y} f(x, y) = (x-4)^2+y^2 \\
\text { s.t. } \quad c(x, y) = y-x^2-1 =0 \\
\end{array}</script><p>为了方便理解，这里将该问题进行了可视化，蓝色表示约束轨迹或可行域，绿色表述目标函数，红色点表示该问题的解。在使用拉格朗日乘子法进行优化迭代时，参数$x$的最速下降方向为$d_k=-\nabla f_{k} + \lambda_{k} A_{k}$，即由目标函数梯度$\nabla f_{k}$和约束函数梯度$\lambda_{k} A_{k}$组合而成，由于梯度方向与等高线方向垂直，因此$-\nabla f_{k}$指向目标函数下降方向，而$\lambda_{k} A_{k}$垂直约束方程并指向可行域，如图中蓝点处所示。实际的迭代方向由这两个方向合成，使得参数向着目标函数下降方向，又逐渐靠近约束轨迹。当最终参数到达解的位置，也是时图中的红点处，约束轨迹与目标函数等高线相切，这两个梯度方向反相共线，也就是满足了KKT条件：$\nabla_{x}\mathcal{L}(x, \lambda)= \nabla f\left(x\right)- \lambda^T \nabla c\left(x\right) = 0$。</p>
<img src="/2020/04/22/4-Tutorials/OpenSim/6.%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/1587653797241.png" class>
<h3 id="内点法优化"><a href="#内点法优化" class="headerlink" title="内点法优化"></a>内点法优化</h3><p>不等式约束下的优化求解比等式约束更加复杂，因为当$c(x)&gt;0$时，该约束实际不对目标函数产生影响，只有$c(x)=0$时，才真正起到约束作用。</p>
<p>内点法又称障碍函数法，它通过在目标函数中添加障碍项，来消去不等式约束，并通过迭代减小障碍权重，不断逼近最优解的方法。对于含有不等式约束的情况，考虑为优化问题添加一个参数向量$s$，并构造如下形式的优化问题：</p>
<script type="math/tex; mode=display">
\begin{array}{c}
\min _{x, s} f(x)-\mu \sum_{i=1}^{m} \ln s_{i} \\
\text { s.t. } \quad c_{\mathrm{E}}(x)=0 \\
c_{I}(x)-s=0
\end{array}</script><p>其中$\mu$是一个大于零的参数。我们用新增加的参数$s$与函数$c_{I}(x)$构成等式约束，来取代之前的不等式约束，由于采用了自然对数$\ln s$，因此$s$被限制严格大于0，因而约束函数$c_I(x)&gt;0$，同时当参数$s$接近0时，目标函数值会迅速增大，使得参数$s$无法减小。函数$\ln s$像是屏障一样限制的参数$s$的变化，因此被称为障碍函数法。这样构造出来的优化问题成为原问题的对偶问题。</p>
<p>还是考虑上面的例子，在原问题的基础上再增加一个$y\ge 3$的不等式约束。我们绘出对偶问题中$\mu =18$时的目标函数图像，如下所示。可以看出对偶问题的目标函数和原问题的目标函数存在很大的差异，且对偶问题的最优解$x^<em>_{dual}$也显然不同于原问题的最优解$x^</em>$。</p>
<img src="/2020/04/22/4-Tutorials/OpenSim/6.%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/1587974512275.png" class>
<p>显然参数$\mu$会影响问题的解。当$\mu$越大时，$-\mu \sum_{i=1}^{m} \ln s_{i}$所占的比重也越大，因此参数$s$趋于增大，即约束函数$c_I(x)$趋于增大，表明参数$x$趋向于远离$c_I(x)=0$的边界。反之当$\mu$减小时，参数$x$才有可能靠近$c_I(x)=0$所表示的边界，但当$\mu_k \to 0$时，对偶问题会逐渐接近于原问题。</p>
<p>内点法通过构造一个$\mu$序列$\{\mu_k\}$，使$\mu_k\to 0$，并在每个$\mu_k$上求解上述优化问题，求解结果作为下一次优化的初值，得到与$\{\mu_k\}$对应解序列$\{x^<em>_k\}$，且有$x^</em>_k\to x^*$，该解序列始终在原问题的可行域内，并逐渐靠近问题的最优解，因此也称为内点法。</p>
<img src="/2020/04/22/4-Tutorials/OpenSim/6.%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/1587975500963.png" class>
<p>为了求解上面的优化问题，定义拉格朗日函数：</p>
<script type="math/tex; mode=display">
\mathcal{L}(x, s, y, z)=f(x) -\mu \sum_{i=1}^{m} \ln s_{i}-y^{T} c_{\mathrm{E}}(x)-z^{T}\left(c_{\mathrm{l}}(x)-s\right)</script><p>其中$x, s$为参数，$y, z$为拉格朗日乘子。对该函数使用牛顿法：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{cccc}
\nabla_{x x}^{2} \mathcal{L} & 0 & -A_{\mathrm{E}}^{T}(x) & -A_{I}^{T}(x) \\
0 & Z & 0 & S \\
A_{\mathrm{E}}(x) & 0 & 0 & 0 \\
A_{1}(x) & -I & 0 & 0
\end{array}\right]\left[\begin{array}{c}
d_{x} \\
d_{s} \\
d_{y} \\
d_{z}
\end{array}\right]=-\left[\begin{array}{c}
\nabla f(x)-A_{\mathrm{E}}^{T}(x) y-A_{I}^{T}(x) z \\
S z-\mu e \\
c_{\mathrm{E}}(x) \\
c_{I}(x)-s
\end{array}\right]</script><p>$A_E(x), A_I(x)$表示约束函数的梯度，定义$S$和$Z$为对角矩阵且其对角元素由向量$s$和$z$给出。</p>
<p>最后给出内点法的伪代码，算法分为外循环和内循环，外循环迭代障碍参数，内循环迭代问题参数：<br><img src="/2020/04/22/4-Tutorials/OpenSim/6.%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/1587660896699.png" class></p>
]]></content>
      <categories>
        <category>仿真研究</category>
      </categories>
      <tags>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>基于肌肉骨骼模型的预测仿真</title>
    <url>/2020/04/26/4-Tutorials/OpenSim/7.%E5%9F%BA%E4%BA%8E%E8%82%8C%E8%82%89%E9%AA%A8%E9%AA%BC%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%A2%84%E6%B5%8B%E4%BB%BF%E7%9C%9F/</url>
    <content><![CDATA[<img src="/2020/04/26/4-Tutorials/OpenSim/7.%E5%9F%BA%E4%BA%8E%E8%82%8C%E8%82%89%E9%AA%A8%E9%AA%BC%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%A2%84%E6%B5%8B%E4%BB%BF%E7%9C%9F/img001.png" class title="img001">
<span id="more"></span>
<h2 id="肌肉骨骼模型"><a href="#肌肉骨骼模型" class="headerlink" title="肌肉骨骼模型"></a>肌肉骨骼模型</h2><h3 id="骨骼的刚体动力学模型"><a href="#骨骼的刚体动力学模型" class="headerlink" title="骨骼的刚体动力学模型"></a>骨骼的刚体动力学模型</h3><img src="/2020/04/26/4-Tutorials/OpenSim/7.%E5%9F%BA%E4%BA%8E%E8%82%8C%E8%82%89%E9%AA%A8%E9%AA%BC%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%A2%84%E6%B5%8B%E4%BB%BF%E7%9C%9F/1587749146996.png" class>
<p>首先基于刚体动力学对于人体骨骼系统进行建模。首先确定系统的广义坐标$q$，对于图中所示的二维模型为例，广义坐标包含躯干的水平、数值方向位移和姿态角，以及每条腿三个关节角，一共$3+2*3=9$个自由度。之后通过这些广义变量和广义变量的导数，表示出系统的动能和势能，并构造拉格朗日函数：</p>
<script type="math/tex; mode=display">L=T-V</script><p>考虑骨骼系统仅收到地反力和肌肉力的作用，通过拉格朗日方程得到系统的动力学模型：</p>
<script type="math/tex; mode=display">\frac{\mathrm{d}}{\mathrm{d} t}\left(\frac{\partial L}{\partial \dot{q}_{j}}\right)-\frac{\partial L}{\partial q_{j}}=\tau^{j}_{contact}+\tau^{j}_{muscle}</script><script type="math/tex; mode=display">\mathbf{M}(\mathbf{q}) \cdot \ddot{\mathbf{q}}+\mathbf{B}(\mathbf{q}, \dot{\mathbf{q}})=\mathbf{J(q)}^T\mathbf{F}_{contact}+\mathbf{R(q)}\mathbf{F}_{muscle}</script><p>其中$\mathbf{M(q)}$为质量矩阵，$\mathbf{B}(\mathbf{q}, \dot{\mathbf{q}})$包含重力、离心力和科氏力，$\mathbf{J(q)}$表示雅克比矩阵，将地反力转化为对每个广义坐标的等效力矩，$\mathbf{R(q)}$表示肌肉力对广义坐标的等效力矩。下面我们主要讨论等式右侧的肌肉力与地反力。</p>
<h3 id="肌肉动力学"><a href="#肌肉动力学" class="headerlink" title="肌肉动力学"></a>肌肉动力学</h3><h4 id="肌肉激活动力学"><a href="#肌肉激活动力学" class="headerlink" title="肌肉激活动力学"></a>肌肉激活动力学</h4><p>尽管各个文献里的描述不尽一致，但一般来说<strong>excitation</strong>用来描述神经信号，是肌肉的控制输入（整流滤波归一化的EMG信号就是这个），而<strong>activation</strong>用来表示肌肉的活跃度，是肌肉的内部状态。在静态状态下，这两者可能相等，但在动态变化中，两者一般不同，存在由excitation到activation动态过程，即肌肉激活动力学。各方学者建立了不同的激活动力学模型，一般包含一个微分方程和一些非线性变换，其中<strong>Winters</strong>开发的一种激活动力学如下：</p>
<script type="math/tex; mode=display">
f=0.5 \tanh (b(e-a))</script><script type="math/tex; mode=display">
\frac{d a}{d t}=\left[\frac{1}{\tau_{a}(0.5+1.5 a)}(f+0.5)+\frac{0.5+1.5 a}{\tau_{d}}(-f+0.5)\right](e-a)</script><h4 id="肌肉收缩动力学"><a href="#肌肉收缩动力学" class="headerlink" title="肌肉收缩动力学"></a>肌肉收缩动力学</h4><img src="/2020/04/26/4-Tutorials/OpenSim/7.%E5%9F%BA%E4%BA%8E%E8%82%8C%E8%82%89%E9%AA%A8%E9%AA%BC%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%A2%84%E6%B5%8B%E4%BB%BF%E7%9C%9F/1587817529399.png" class>
<p>肌肉收缩的特性可以用如上的<strong>Hill肌肉模型</strong>来描述，它由肌肉收缩单元CE与被动弹性单元PE并联，并与一个肌腱弹性单元T串联，肌肉与肌腱之间还存在一个角度成为羽状角。由于根据上面的模型，肌肉实际产生的力不仅受到收缩单元CE的激活度的影响，还受到肌肉的长度、收缩速度的影响。由肌肉纤维产生的力具有如下关系：</p>
<script type="math/tex; mode=display">\begin{aligned}
F^{\mathrm{mt}}(t) &=F^{\mathrm{t}} \\
&=F^{\max }\left[a(t)f(l) f(v) +f_{\mathrm{p}}(l)\right] \cos (\phi(t))
\end{aligned}</script><p>$F^{\max }$表示最大等长收缩力，$f(l),f(v),f(p)$分别表示力-长度、力-速度、被动力-长度的关系。这些函数由下图所示的实验曲线所描述，一般可以通过多项式函数拟合来近似表示。</p>
<img src="/2020/04/26/4-Tutorials/OpenSim/7.%E5%9F%BA%E4%BA%8E%E8%82%8C%E8%82%89%E9%AA%A8%E9%AA%BC%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%A2%84%E6%B5%8B%E4%BB%BF%E7%9C%9F/1587721929270.png" class>
<p>注意到上式公式中，实际输入为激活度$a$、归一化肌肉长度$l$、和归一化收缩速度$v$，而肌肉长度与收缩速度之间存在关系，收缩动力学的状态量仅有$a$和$l$，且上述方程描述的是一个微分方程。我们将整个肌肉动力学表示为如下形式，但这种表示并不严谨，实际上每块肌肉包含着两个微分方程：</p>
<script type="math/tex; mode=display">
\mathbf{F}_{muscle} = \mathbf{F}_{muscle}(\mathbf{q},\mathbf{a} , \mathbf{\dot a},\mathbf{L}_{CE},\mathbf{\dot L}_{CE},\mathbf{e})</script><h3 id="地反力模型"><a href="#地反力模型" class="headerlink" title="地反力模型"></a>地反力模型</h3><p>OpenSim中采用<strong>Hunt-Crossley</strong>模型来表示接触力，接触力由刚度项、阻尼项和摩擦项组合而成，其表达式为：</p>
<script type="math/tex; mode=display">
\mathbf{f}_{\text {contact}}=\mathbf{f}_{\text {stiffness}}+\mathbf{f}_{\text {dissipation}}+\mathbf{f}_{\text {friction}}</script><img src="/2020/04/26/4-Tutorials/OpenSim/7.%E5%9F%BA%E4%BA%8E%E8%82%8C%E8%82%89%E9%AA%A8%E9%AA%BC%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%A2%84%E6%B5%8B%E4%BB%BF%E7%9C%9F/1587819399557.png" class>
<p>接触力模型中的第一项表示弹性力。如上图所示，我们可以用两个弹性小球来描述接触，当小球接触时会发生弹性变形，变形的程度与各自的弹性模量$E$有关，总的变形为$x$。当变形发生时，每个小球都会受到一个弹性力：</p>
<script type="math/tex; mode=display">
f_{\text {stiffness}}=f_{H z}=\left(\frac{4}{3} \sigma R^{1 / 2} E^{*}\right) x^{3 / 2}</script><p>$R$表示合成相对曲率，$E^*$表示合成弹性模量，它们都可以通过两个小球的参数计算出来；$\sigma$表示偏心系数，当$\sigma=1$的时候为圆接触，$x$为总的变形量。</p>
<p>接触力模型中的第二项表示损耗力，或是阻尼力。碰撞的发生往往伴随着能量的损耗，单纯的弹性力无法表示这一点，因此引入Hunt-Crossley耗散力：</p>
<script type="math/tex; mode=display">
f_{dissipation}=\frac{3}{2} f_{stiffness} c^{*} \dot{x}</script><p>$c^{*}$表示等效耗散系数，而$\dot{x}$表现出耗散力的阻尼特性。刚度力和耗散力都垂直接触面。</p>
<script type="math/tex; mode=display">
f_{\text {normal}}=f_{\text {stiffness}}+f_{\text {dissipation}}</script><p>接触力模型中的最后一项表示摩擦力，方向平行接触面：</p>
<script type="math/tex; mode=display">
f_{\text {friction}}=\mu(v) f_{\text {normal}}</script><p>$\mu(v)$表示等效摩擦因数，是关于相对运动速度的函数。</p>
<p>在使用上述的Hunt-Crossley模型来计算地反力时，地面的刚度认为无穷大，则相对弹性变形$x$可以通过接触小球圆心相对地面的距离计算得到，即：</p>
<script type="math/tex; mode=display">
\mathbf{F}_{contact} = \mathbf{F}_{contact}(\mathbf{q}, \dot{\mathbf{q}})</script><h3 id="综合模型"><a href="#综合模型" class="headerlink" title="综合模型"></a>综合模型</h3><p>综上所述，肌骨模型的动力学可以统一表示为：</p>
<script type="math/tex; mode=display">
\mathbf{M}(\mathbf{q}) \cdot \ddot{\mathbf{q}}+\mathbf{B}(\mathbf{q}, \dot{\mathbf{q}})=\mathbf{J(q)}^T \mathbf{F}_{contact}(\mathbf{q}, \dot{\mathbf{q}})+\mathbf{R(q)}\mathbf{F}_{muscle}(\mathbf{q},\mathbf{a} , \mathbf{\dot a},\mathbf{L}_{CE},\mathbf{\dot L}_{CE},\mathbf{e})</script><p>定义状态变量：</p>
<script type="math/tex; mode=display">
\mathbf{x}=\left(\mathbf{q}, \dot{\mathbf{q}}, \mathbf{L}_{C E}, \mathbf{a}\right)^{T}</script><p>在定义$u$为16块肌肉的控制量（excitations），上面的动力学方程可表示为：</p>
<script type="math/tex; mode=display">
\mathbf{f}(\mathbf{x}, \dot{\mathbf{x}}, \mathbf{u})=0</script><h2 id="肌骨模型的仿真应用"><a href="#肌骨模型的仿真应用" class="headerlink" title="肌骨模型的仿真应用"></a>肌骨模型的仿真应用</h2><h3 id="前向仿真"><a href="#前向仿真" class="headerlink" title="前向仿真"></a>前向仿真</h3><img src="/2020/04/26/4-Tutorials/OpenSim/7.%E5%9F%BA%E4%BA%8E%E8%82%8C%E8%82%89%E9%AA%A8%E9%AA%BC%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%A2%84%E6%B5%8B%E4%BB%BF%E7%9C%9F/1587828690595.png" class>
<h3 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h3><p>逆向分析是指，在已有运动学、地反力数据后，根据实验数据推断出产生相应运动的肌肉活动，也就是OpenSim中的<strong>CMC</strong>。由于肌肉之间存在和比较严重的耦合问题，多块肌肉连接同一个关节，同一块肌肉连接着不同关节，因此逆向分析最重要的是解决肌肉冗余 - Solving the Muscle Redundancy Problem。</p>
<p>在这个问题中，已有运动学数据$\mathbf{q}_k$和地反力$\mathbf{F}_{\mathbf{C}k}$序列，$k=1, \ldots, K$表示离散时间。我们先计算逆动力学得到关节力矩$T_{\mathbf{ID}k}$，关节力矩应当等于有肌肉收缩的等效力矩：</p>
<script type="math/tex; mode=display">
T_{\mathrm{ID} k}=\sum_{m=1}^{M} r_{m k} F_{\mathrm{T} m}+e_{\mathrm{T} k} T_{\mathrm{max}}</script><p>$m$表示肌肉序号，$r$表示肌肉对关节等效力矩。有时候关节力矩和肌肉里橘无法严格相等，因此我们添加了公式中的最后一项来表示力矩的残差，而$e_{\mathrm{T} k}$表示残差系数，在后面我们会设计优化目标是残差力尽可能的小。</p>
<p>由此建立逆向分析的优化框架：</p>
<img src="/2020/04/26/4-Tutorials/OpenSim/7.%E5%9F%BA%E4%BA%8E%E8%82%8C%E8%82%89%E9%AA%A8%E9%AA%BC%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%A2%84%E6%B5%8B%E4%BB%BF%E7%9C%9F/1587828542736.png" class>
]]></content>
      <categories>
        <category>仿真研究</category>
      </categories>
      <tags>
        <tag>肌肉骨骼模型</tag>
      </tags>
  </entry>
  <entry>
    <title>An Introduction for IMU 1 - IMU原理与MPU6050数据采集</title>
    <url>/2021/03/01/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/1-IMU%E5%8E%9F%E7%90%86%E4%B8%8EMPU6050%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/</url>
    <content><![CDATA[<p>本系列博客将从IMU的基础概念和基本原理出发，基于Arduino单片机和MPU6050传感器，介绍数据采集、数据融合、姿态解算，进一步设计无线IMU模块，开发人体姿态测量系统，并同步到生物力学分析软件OpenSim中进行逆运动学分析，等。</p>
<span id="more"></span>
<h2 id="IMU的测量原理"><a href="#IMU的测量原理" class="headerlink" title="IMU的测量原理"></a>IMU的测量原理</h2><p>IMU全称Inertial Measurement Unit，惯性测量单元，主要用来检测和测量加速度与旋转运动的传感器。根据测量原理不同，可分为微机电传感器(MEMS)和光纤陀螺仪，其中光纤陀螺主要用于航空航天与军事领域，民用IMU大都是基于惯性原理的MEMS传感器。IMU根据所能感知状态量的个数(DOF)进行区分，其中6DOF的IMU最为常见，也就是可以测量三轴加速度和三轴角速度。9DOF的IMU会多一个三轴磁力计，10DOF的IMU再多一个气压计。</p>
<img src="/2021/03/01/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/1-IMU%E5%8E%9F%E7%90%86%E4%B8%8EMPU6050%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/1.png" class width="1">
<p>加速度计的物理实现是利用牛顿第二定律，如上左图所示，中间红色物体为一个质量块，两头通过具有弹簧性质的长条结构与基底相连，红色的短栅与绿色的短栅分别为电容的极板。当基底在双箭头方向有加速度a时，由$f=ma=kx$，质量块会沿加速度相反的方向移动，红色极板与绿色极板之间的距离会发生变化，通过测量极板电容$C$的变化就可以得到加速度的大小。在三轴加速度计中，这样的结构在三个方向各有一个，且做到了微米的尺寸，并配合相应的测量电路集成在一个芯片中，构成一个微机电系统。</p>
<p><img src="/2021/03/01/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/1-IMU%E5%8E%9F%E7%90%86%E4%B8%8EMPU6050%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/3.png" alt="3" style="zoom:30%;"></p>
<p>角速度测量的原理比加速度要复杂一些，利用了在旋转坐标系下运动的物体会受到科里奥里力(Coriolis Force)的特性。科里奥里力是由坐标系的转动与物体在动坐标系中的相对运动引起的，其本质是物体的惯性。如果图示模块置于绝对静止的坐标系中，当在x方向施加一个驱动力使质量块运动时，根据牛顿第二定律，质量块只会在x方向上运动，而在y方向上不会运动。但如果将图示模块置于一个旋转坐标系下，由于坐标系的旋转，使得当质量块沿x方向运动时，在y方向上会受到一个力，即科里奥里力<code>F=-2mvω</code>，从而使质量块沿y方向运动。地球上的很多自然现象，如热带气旋、季风带、河道两侧冲刷程度不同，都源于科里奥里力。</p>
<p>陀螺仪的物理实现如上右图所示，外侧的蓝色与黄色部分为驱动电极，它们在模块的驱动方向施加交变电压，使内部的质量块以及红色的测量电极沿着驱动方向运动。当整个平台发生旋转时，质量块受科里奥里力影响会在垂直方向上发生运动，且周期运动的幅值与平台的角速度成正比，通过测量质量块上的红色电极和固定在底座上蓝色电极之间的电容，便可以得到角速度的大小。</p>
<hr>
<h2 id="MPU6050"><a href="#MPU6050" class="headerlink" title="MPU6050"></a>MPU6050</h2><p><img src="/2021/03/01/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/1-IMU%E5%8E%9F%E7%90%86%E4%B8%8EMPU6050%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/2.png" width="80%"></p>
<p>MPU6050是InvenSense公司推出的一款高性能三轴加速度+三轴陀螺仪的六轴传感器芯片， 该芯片内部整合了 3 轴陀螺仪和 3 轴加速度传感器，并可利用自带的数字运动处理器（DMP: Digital Motion Processor）硬件加速引擎，体积较小，减少了大量的封装空间。主要特性如下：</p>
<ul>
<li>6位ADC和信号调理的三轴MEMS陀螺仪，具有 131 LSBs/° /sec 敏感度与全格感测范围为±250、±500、±1000 与±2000°/sec 的 3 轴角速度感测器(陀螺仪)；</li>
<li>16位ADC和信号调理的三轴MEMS加速度计，范围为±2g、±4g、±8g 和±16g 的 3 轴加速度传感器；</li>
<li>自带数字运动处理(DMP: Digital Motion Processing)引擎，内建运作时间偏差与磁力感测器校正演算技术，以数字形式输出 6 轴或 9 轴（需外接磁传感器）的旋转矩阵、四元数、欧拉角格式的融合演算数据，可减少 MCU 复杂的融合演算数据、感测器同步化、姿势感应等的负荷；</li>
<li>VDD 供电电压为 2.5V±5%、 3.0V±5%、 3.3V±5%； VLOGIC 可低至 1.8V± 5%；</li>
<li>陀螺仪工作电流： 5mA，陀螺仪待机电流： 5uA；加速度计工作电流： 500uA，加速度计省电模式电流： 40uA@10Hz；</li>
<li>支持最高 400Khz 的 IIC 通信，IIC地址为 0X68（AD0接GND）或0x69（AD0接VDD）；</li>
</ul>
<h2 id="MPU6050数据读取"><a href="#MPU6050数据读取" class="headerlink" title="MPU6050数据读取"></a>MPU6050数据读取</h2><p>本篇博客通过Arduino Nano读取MPU6050的数据，相同的程序也适用于其他的Arduino开发版。程序主要通过调用现有的MPU6050库，同时将数据通过匿名上位机以波形的方式显示出来，相关的库函数、上位机软件、上位机的Arduino通信函数可以到<a href="https://download.csdn.net/download/qq_35007540/16595570?spm=1001.2014.3001.5503">CSDN资源</a>下载，也可以在<a href="https://github.com/JYChenNK/IMU_SYS/tree/main/1-readMPU-Arduino/ref_lib">GITHUB</a>上下载，本部分读取IMU数据的程序请在<a href="https://download.csdn.net/download/qq_35007540/16595587?spm=1001.2014.3001.5503">此处</a>下载。库函数的安装方法，以及匿名上位机的使用方法请参考其他论坛和博客，若使用存在问题烦请给我留言。</p>
<p><img src="/2021/03/01/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/1-IMU%E5%8E%9F%E7%90%86%E4%B8%8EMPU6050%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/7.png" alt="7" style="zoom:80%;"></p>
<p>Arduino通过I2C于MPU6050进行通信，因此除了供电引脚外，还需要连接I2C引脚。根据上面的Arduino Nano引脚图，需要将MPU6050的SCL连接到Arduino Nano的A5引脚，SDA连接到Arduino的A4引脚。具体连线图如下所示：</p>
<p><img src="/2021/03/01/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/1-IMU%E5%8E%9F%E7%90%86%E4%B8%8EMPU6050%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/5.jpeg" alt="5" style="zoom:35%;"></p>
<p>程序主要调用了MPU6050的库，同时为了能够通过上位机显示数据波形，还调用了项目文件下的<code>ANO.h</code>里的函数来向上位机发送数。调用部分包括如下内容：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;I2Cdev.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MPU6050.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ANO.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Wire.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>在setup之前需要先定义一些MPU6050的相关变量，包括MPU6050对象的定义，以及三轴的加速度与角速度：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MPU6050 IMU;</span><br><span class="line"><span class="keyword">int16_t</span> ax, ay, az;</span><br><span class="line"><span class="keyword">int16_t</span> gx, gy, gz;</span><br></pre></td></tr></table></figure>
<p>在setup函数中，分别对串口、I2C总线以及MPU6050进行初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Initialize Serial</span></span><br><span class="line">  Serial.begin(<span class="number">115200</span>);</span><br><span class="line">  <span class="comment">// Initialize I2C &amp; IMU</span></span><br><span class="line">  <span class="comment">// By default, the measurement range of acc is 2g, and the gyro&#x27;s range is 250 deg/s</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE</span></span><br><span class="line">      Wire.begin();</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">elif</span> I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_FASTWIRE</span></span><br><span class="line">      Fastwire::setup(<span class="number">400</span>, <span class="literal">true</span>);</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  IMU.initialize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里有两点需要注意：</p>
<ul>
<li>I2C初始化的时候会和硬件存在一定关系，大部分开发版通过软件的方式进行I2C通信，也就是<code>Wire.h</code>库，但有些开发版具有硬件I2C，可以更快的速度通信（400kHz）。</li>
<li>MPU6050的<code>initialize</code>函数默认将MPU6050的测量范围设置为加速度2g，角速度250deg/s。因此初始化之后还需合理的设置传感器的测量范围，以及offset。</li>
</ul>
<p>初始化完成后便可以通过<code>getMotion6</code>函数读取MPU6050的数据，这里进一步将读取的数据用<code>ANO_DT_Send_Senser</code>函数通过串口发送给上位机：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Get IMU Raw Data</span></span><br><span class="line">  IMU.getMotion6(&amp;ax, &amp;ay, &amp;az, &amp;gx, &amp;gy, &amp;gz);</span><br><span class="line">  <span class="comment">// Send Data to PC</span></span><br><span class="line">  ANO_DT_Send_Senser(ax,ay,az,gx,gy,gz,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">  delay(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图为上下移动传感器时上位机的波形曲线，黄色为竖直方向Z轴的加速度，完整的程序请在<a href="https://download.csdn.net/download/qq_35007540/16595587?spm=1001.2014.3001.5503">此处</a>下载。</p>
<p><img src="/2021/03/01/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/1-IMU%E5%8E%9F%E7%90%86%E4%B8%8EMPU6050%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/4.gif" alt="4" style="zoom: 80%;"></p>
<h2 id="MPU6050的DMP数据读取"><a href="#MPU6050的DMP数据读取" class="headerlink" title="MPU6050的DMP数据读取"></a>MPU6050的DMP数据读取</h2><p>MPU6050得到的原始数据仅有加速度与角速度，但很多时候我们最需要用的是三轴的姿态角信息。通过加速度和角速度估计姿态角叫做IMU的姿态解算，下一篇博客将介绍姿态解算的原理与两种姿态计算的方法-互补滤波与卡尔曼滤波。其实MPU6050内部自带了姿态解算算法，也就是DMP。DMP是MPU6050内部的运动引擎，全称Digital Motion Processor，直接输出姿态解算后的四元数，可以减轻外围微处理器的工作负担且避免了繁琐的滤波和数据融合。Invensense提供了DMP的数据接口，但并非完全开源，Arduino平台下也有DMP读取的库，本篇博客也直接调用库函数来实现DMP数据的读取，相关的库和依赖还是在上文的链接中下载。</p>
<p>DMP的数据需要采用中断的方式进行读取，当DMP数据准备完成后，MPU6050的INT引脚会输出一个高电平脉冲，因此除了I2C引脚外，还需要将MPU6050的INT引脚接到Arduino Nano的0号中断通道，也就是数字引脚D2（中断通道序号和物理引脚序号的映射关系参考Arduino论坛），连线图如下：</p>
<p><img src="/2021/03/01/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/1-IMU%E5%8E%9F%E7%90%86%E4%B8%8EMPU6050%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/6.jpeg" alt="5" style="zoom:35%;"></p>
<p>读取DMP数据需要加载DMP的支持，因此用<code>MPU6050_6Axis_MotionApps20.h</code>代替<code>MPU6050.h</code>。同时为了对读取DMP数据的频率进行评估，以及向上位机定时发送数据，还另外调用了定时中断库，所有的调用如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MsTimer2.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;I2Cdev.h&quot;</span></span></span><br><span class="line"><span class="comment">//#include &quot;MPU6050.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MPU6050_6Axis_MotionApps20.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ANO.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Wire.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>程序首先需要定义一些MPU6050相关的对象和变量，包括MPU6050对象、DMP相关的状态变量、传感器的数据变量、以及用于计算DMP返回频率的变量等。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MPU6050 Object</span></span><br><span class="line">MPU6050 IMU;</span><br><span class="line"><span class="comment">// DMP state variables</span></span><br><span class="line"><span class="keyword">bool</span> dmpReady = <span class="literal">false</span>;  <span class="comment">// set true if DMP init was successful</span></span><br><span class="line"><span class="keyword">bool</span> mpuInterrupt = <span class="literal">false</span>;     <span class="comment">// indicates whether MPU interrupt pin has gone high</span></span><br><span class="line"><span class="keyword">uint8_t</span> mpuIntStatus;   <span class="comment">// holds actual interrupt status byte from MPU</span></span><br><span class="line"><span class="keyword">uint8_t</span> devStatus;      <span class="comment">// return status after each device operation (0 = success, !0 = error)</span></span><br><span class="line"><span class="keyword">uint16_t</span> packetSize;    <span class="comment">// expected DMP packet size (default is 42 bytes)</span></span><br><span class="line"><span class="keyword">uint16_t</span> fifoCount;     <span class="comment">// count of all bytes currently in FIFO</span></span><br><span class="line"><span class="keyword">uint8_t</span> fifoBuffer[<span class="number">64</span>]; <span class="comment">// FIFO storage buffer</span></span><br><span class="line"><span class="comment">// Measurement Data </span></span><br><span class="line"><span class="keyword">int16_t</span> acc[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int16_t</span> gyro[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">float</span> euler[<span class="number">3</span>];</span><br><span class="line">Quaternion q;</span><br><span class="line"><span class="comment">// Data Receive Frequence Count</span></span><br><span class="line"><span class="keyword">int</span> dataCounter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> dataFreq = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>传感器的初始化代码如下，包括初始化I2C总线、初始化MPU6050芯片、初始化DMP模块；当DMP模块被成功初始化之后，使能DMP模块，并设置Arduino的0号中断通道（数字引脚D2）为外部中断上升沿触发，然后从MPU6050获取DMP返回正确数据包的长度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IMU_Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Initialize I2C &amp; IMU</span></span><br><span class="line">  <span class="comment">// By default, the measurement range of acc is 2g, and the gyro&#x27;s range is 250 deg/s</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE</span></span><br><span class="line">      Wire.begin();</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">elif</span> I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_FASTWIRE</span></span><br><span class="line">      Fastwire::setup(<span class="number">400</span>, <span class="literal">true</span>);</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  IMU.initialize();</span><br><span class="line">  delay(<span class="number">200</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Initialize DMP</span></span><br><span class="line">  devStatus = IMU.dmpInitialize();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (devStatus == <span class="number">0</span>) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// turn on the DMP</span></span><br><span class="line">    IMU.setDMPEnabled(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// enable Arduino interrupt detection</span></span><br><span class="line">    attachInterrupt(<span class="number">0</span>, dmpDataReady, RISING);</span><br><span class="line">    mpuIntStatus = IMU.getIntStatus();</span><br><span class="line">    <span class="comment">// set our DMP Ready flag</span></span><br><span class="line">    dmpReady = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// get expected DMP packet size for later comparison</span></span><br><span class="line">    packetSize = IMU.dmpGetFIFOPacketSize();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    Serial.println(<span class="string">&quot;IMU Init Failed!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// INTERRUPT DETECTION ROUTINE</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dmpDataReady</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mpuInterrupt = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上初始化完成后，当MPU6050的中断引脚产生高电平信号，且FIFO缓存区数据的长度大于正确数据包的长度后，就可以读取DMP数据了。数据读取的代码如下，首先对初始化状态和外部中断状态进行判断；当外部中断触发后，首先读取MPU6050当前的中断状态，当状态为0x02表示解算完成（0x10表示缓存溢出中断，需要清空FIFO），再循环读取FIFO寄存器的数据长度，当长度大于一个正确数据包的长度后，从FIFO中读取数据<code>getFIFOBytes</code>，然后将数据解算为四元数<code>dmpGetQuaternion</code>，再变化到欧拉角<code>dmpGetEuler</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IMU_DMP_read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// return if IMU is not initialized</span></span><br><span class="line">  <span class="keyword">if</span> (!dmpReady) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// wait for MPU interrupt or extra packet(s) available</span></span><br><span class="line">  <span class="keyword">if</span>(!mpuInterrupt) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// reset interrupt flag and get INT_STATUS byte</span></span><br><span class="line">  mpuInterrupt = <span class="literal">false</span>;</span><br><span class="line">  mpuIntStatus = IMU.getIntStatus();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// get current FIFO count</span></span><br><span class="line">  fifoCount = IMU.getFIFOCount();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// check for overflow</span></span><br><span class="line">  <span class="keyword">if</span> ((mpuIntStatus &amp; <span class="number">0x10</span>) || fifoCount == <span class="number">1024</span>) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// reset so we can continue cleanly</span></span><br><span class="line">    IMU.resetFIFO();</span><br><span class="line">    Serial.println(<span class="string">&quot;FIFO overflow!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// otherwise, check for DMP data ready interrupt (this should happen frequently)</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (mpuIntStatus &amp; <span class="number">0x02</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// wait for correct available data length, should be a VERY short wait</span></span><br><span class="line">    <span class="keyword">while</span> (fifoCount &lt; packetSize) </span><br><span class="line">      fifoCount = IMU.getFIFOCount();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read a packet from FIFO</span></span><br><span class="line">    IMU.getFIFOBytes(fifoBuffer, packetSize);</span><br><span class="line">    <span class="comment">// track FIFO count here in case there is &gt; 1 packet available</span></span><br><span class="line">    <span class="comment">// (this lets us immediately read more without waiting for an interrupt)</span></span><br><span class="line">    fifoCount -= packetSize;</span><br><span class="line"></span><br><span class="line">    IMU.dmpGetQuaternion(&amp;q, fifoBuffer);</span><br><span class="line">    IMU.dmpGetEuler(euler, &amp;q);</span><br><span class="line">    </span><br><span class="line">    dataCounter++;</span><br><span class="line"></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主程序中初始化串口和IMU，同时开启5ms定时中断向上位机发送欧拉角数据，同时对DMP接受到的数据频率进行统计；主循环中不断执行DMP的数据读取，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Serial.begin(<span class="number">115200</span>);</span><br><span class="line">  IMU_Init();</span><br><span class="line">  MsTimer2::<span class="built_in">set</span>(<span class="number">5</span>,sendPC);</span><br><span class="line">  MsTimer2::start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  IMU_DMP_read(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendPC</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> timeCounter = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  timeCounter += <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span>(timeCounter &gt; <span class="number">1000</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    dataFreq = dataCounter;</span><br><span class="line">    dataCounter = <span class="number">0</span>;</span><br><span class="line">    timeCounter = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Send Data to PC</span></span><br><span class="line">  ANO_DT_Send_Senser(euler[<span class="number">1</span>]*<span class="number">180</span>/M_PI,euler[<span class="number">2</span>]*<span class="number">180</span>/M_PI, euler[<span class="number">0</span>]*<span class="number">180</span>/M_PI, dataFreq,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图为旋转传感器时上位机的波形曲线，前三条曲线为欧拉角；第四条蓝色曲线为DMP读取的频率，实测结果约为66Hz，可能和软件I2C有关，其他一些博客在STM32 F407平台上测试结果为100Hz，官方手册中最高为200Hz。本部分的完整程序请在<a href="https://download.csdn.net/download/qq_35007540/16596089">此处</a>下载。</p>
<p><img src="/2021/03/01/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/1-IMU%E5%8E%9F%E7%90%86%E4%B8%8EMPU6050%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/8.gif" alt="8" style="zoom:80%;"></p>
]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>IMU系统</tag>
      </tags>
  </entry>
  <entry>
    <title>IMU原理与人体姿态检测</title>
    <url>/2021/02/28/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/1.IMU%E7%9A%84%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>最近做了一套基于IMU的人体姿态检测系统，用来取代动作捕捉系统。一方面IMU的实时性和可开发性比动捕要好，另一方面IMU成本很低的同时精度也足以满足需求。本文介绍IMU的基本原理与基于IMU的人体姿态检测系统的设计。</p>
<span id="more"></span>
<hr>
<h4 id="1-IMU的组成与原理"><a href="#1-IMU的组成与原理" class="headerlink" title="1.IMU的组成与原理"></a>1.IMU的组成与原理</h4><img src="/2021/02/28/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/1.IMU%E7%9A%84%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/1.bmp" class>
<p>IMU可根据DOF的不同来加以区分，其中6DOF的IMU和9DOF的IMU比较常见，6DOF的IMU一般由一个三轴加速度计和一个三轴陀螺仪组成。9DOF的IMU会多一个三轴磁力计。模块所能感知状态量的个数即为DOF大小，DOF越多、精度越高的IMU也就越贵。<br>这里只讨论6DOF的IMU。</p>
<h6 id="加速度计"><a href="#加速度计" class="headerlink" title="加速度计"></a>加速度计</h6><hr>
<p>顾名思义，三轴加速度计能感受三轴的加速度，如上图中三个矢量所示。但要注意的是，当图示模块水平放置且静止，z轴方向加速度大小为<code>-g</code>，也就是说IMU测量的加速度与物体真实加速度相差一个重力加速度。<br><img src="/2021/02/28/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/1.IMU%E7%9A%84%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/2.bmp" class><br>加速度计的物理实现是利用牛顿第二定律，如上图所示，中间红色物体为一个质量块，两头通过具有弹簧性质的长条结构与基底相连，红色的短栅与绿色的短栅分别为电容的极板。当基底在双箭头方向有加速度<code>a</code>时，由<code>f=ma=kx</code>，质量块会沿加速度相反的方向移动，红色极板与绿色极板之间的距离会发生变化，通过测量极板电容<code>C</code>的变化就可以得到加速度的大小。在三轴加速度计中，这样的结构在三个方向各有一个，且做到了微米的尺寸，并配合相应的测量电路集成在一个芯片中（如图一所示），构成一个微机电系统（MEMS）。</p>
<h6 id="陀螺仪"><a href="#陀螺仪" class="headerlink" title="陀螺仪"></a>陀螺仪</h6><hr>
<p>角速度测量的原理比加速度要复杂一些，因为涉及了科里奥里力(Coriolis Force)。所以我们先来说一下Coriolis Force。科里奥里力是由坐标系的转动与物体在动坐标系中的相对运动引起的，其本质是物体的惯性。</p>
<img src="/2021/02/28/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/1.IMU%E7%9A%84%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/3.bmp" class>
<p>如果图示模块置于绝对静止的坐标系中，当在x方向施加一个驱动力使质量块运动时，根据牛顿第二定律，质量块只会在x方向上运动，而在y方向上不会运动。</p>
<img src="/2021/02/28/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/1.IMU%E7%9A%84%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/4.bmp" class>
<p>但如果将图示模块置于一个旋转坐标系下，由于坐标系的旋转，使得当质量块沿x方向运动时，在y方向上会受到一个力，即科里奥里力<code>F=-2mvω</code>，从而使质量块沿y方向运动。地球上的很多自然现象，如热带气旋、季风带、河道两侧冲刷程度不同，都源于科里奥里力。</p>
<img src="/2021/02/28/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/1.IMU%E7%9A%84%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/5.bmp" class>
<p>陀螺仪的物理实现如上图所示，外侧的蓝色与黄色部分为驱动电极，内部的红色与蓝色为测量电极。在模块的驱动方向施加正弦驱动电压，当模块发生旋转时，质量块在垂直方向受科里奥里力影响也会产生一个正弦运动，且正弦运动的幅值与平台的角速度成正比，通过垂直方向的电极测量出此幅值，便可以得到模块角速度。与三轴加速度计一样，这样的结构在三轴陀螺仪的三个方向上各有一个，从而测量出三个方向的角速度。</p>
<h5 id="2-IMU姿态解算"><a href="#2-IMU姿态解算" class="headerlink" title="2. IMU姿态解算"></a>2. IMU姿态解算</h5><p>现在我们能够从IMU中得到三轴的加速度和三轴的角速度，接下来就要从这些数据中解算出三个方向的角度。实际上，单独由加速度计或陀螺仪都可以解算出三轴的角度。</p>
<h6 id="由加速度解算角度"><a href="#由加速度解算角度" class="headerlink" title="由加速度解算角度"></a>由加速度解算角度</h6><hr>
<img src="/2021/02/28/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/1.IMU%E7%9A%84%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/6.png" class>
<p>由于加速度计本质是测量力，所以在传感器静止的时候，测量的结果为重力加速度。当平台运动的加速度远小于重力加速度时，可认为传感器测量的结果全部为重力加速度，因此可以根据重力加速的在三轴分量的大小来解算出角度。</p>
<img src="/2021/02/28/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/1.IMU%E7%9A%84%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/7.png" class>
<p>以上图为例，传感器沿<code>y</code>方向倾斜的角度为：</p>
<script type="math/tex; mode=display">
Angle_{Accel} = arccos\frac{ax}{-g}</script><h6 id="由陀螺仪解算角度"><a href="#由陀螺仪解算角度" class="headerlink" title="由陀螺仪解算角度"></a>由陀螺仪解算角度</h6><hr>
<p>由角速度解算角度很容易理解，当知道陀螺仪的初始角度时，对角速度进行积分就可以得到角度值。</p>
<script type="math/tex; mode=display">
Angle_{Gyro}=Angle_0 + \int_0^t Gyro dt</script><h6 id="数据融合"><a href="#数据融合" class="headerlink" title="数据融合"></a>数据融合</h6><hr>
<p>现在我们可以从加速度和角速度分别解算出角度，但这两种方式都存在很大的问题。一方面由于加速度计容易受到振动的影响，噪声很大，所以解算角度的噪声也很大；另一方面虽然陀螺仪测量角速度的噪声不是很大，经过积分环节后噪声进一步被变小，但由于初始角度并不能准确得到，而且角速度存在零漂问题（即模块静止时角速度不完全为0，而是有一个偏置），经过积分后这个误差会被累积。<br>因此，两种方式解算出来的角度都无法直接使用，但我们可以采用数据融合的方法，把两种角度融合在一起，得到一个既没有累计误差、噪声又小的角度数据。</p>
<h6 id="互补滤波"><a href="#互补滤波" class="headerlink" title="互补滤波"></a>互补滤波</h6><hr>
<p>一阶互补滤波是最简单但却非常实用的数据融合算法，它把由加速度解算的角度和由角速度积分的角度按照一定比例加到一起，公式如下：</p>
<script type="math/tex; mode=display">
Angle = K\cdot Angle_{accel}+(1-K)\cdot (Angle + \omega\cdot dt)</script><p>其中参数<code>K</code>表示对加速度解算角度的置信程度，由于加速度的噪声很大，所以参数<code>K</code>一般很小，典型值为<code>0.05</code>，实际使用要根据效果来调整。</p>
<p>这样的互补滤波器可以看做是一个高通滤波和一个低通滤波的叠加：公式的第一项是为低通滤波部分，目的是滤除加速度的噪声；公式的第二项为高通滤波部分，目的是滤除角速度的直流偏置（零漂）。</p>
<h6 id="Kalman滤波"><a href="#Kalman滤波" class="headerlink" title="Kalman滤波"></a>Kalman滤波</h6><hr>
<p>互补滤波虽然简单实用易理解，但我们还有更好的算法来进行数据融合，比如Kalman滤波。关于Kalman滤波的原理，有一些非常好的论文和博客，感兴趣的同学可以移步这些网站:</p>
<p><a href="http://www.cs.unc.edu/~welch/kalman/media/pdf/Kalman1960.pdf">Kalman先生1960年的论文</a><br><a href="https://list.yinxiang.com/markdown/eef42447-db3f-48ee-827b-1bb34c03eb83.php">博客 How a Kalman filter works</a><br><a href="https://blog.csdn.net/u010720661/article/details/63253509">上篇博客的中文版</a><br><a href="https://courses.engr.illinois.edu/ece420/sp2017/UnderstandingKalmanFilter.pdf">论文 Understanding Kalman Filter</a><br><a href="https://www.jianshu.com/p/d3b1c3d307e0">上篇论文的中文版</a></p>
<p>Kalman滤波的原理稍过复杂，这里并不打算深入讨论。但由于博客和论坛上关于用Kalman滤波融合加速度计和陀螺仪数据的建模方法介绍比较少，所以这里给出本问题状态空间方程的建立方法。</p>
<p>和一般系统的建模方法不同，本问题中的状态变量不是角度和角速度，而是角度和角速度的偏置：</p>
<script type="math/tex; mode=display">
State = \begin{bmatrix} Angle(k)  \\ Gyro_{bias}(k) \\  \end{bmatrix}</script><p>状态空间模型考虑带控制量的形式，其中控制量为陀螺仪测量的角速度，观测方程中只有从加速度解算得到的角度，方程如下：</p>
<script type="math/tex; mode=display">
\begin{bmatrix} Angle(k+1)  \\ Gyro_{bias}(k+1)   \end{bmatrix} = \begin{bmatrix} 1 & -dt \\ 0 & 1   \end{bmatrix}\begin{bmatrix} Angle(k)  \\ Gyro_{bias}(k) \end{bmatrix} + \begin{bmatrix} dt \\ 0  \end{bmatrix} Gyro(k) + W(k)</script><script type="math/tex; mode=display">
Angle_{accel}(k) =\begin{bmatrix} 1 & 0  \end{bmatrix}  \begin{bmatrix} Angle(k) \\ Gyro_{bias}(k)  \end{bmatrix} + V(k)</script><p>其中矩阵<code>W</code>和<code>V</code>分别为输入噪声矩阵和观测噪声矩阵，这两个矩阵的参数需要根据情况进行调整。对于本问题矩阵<code>V</code>的参数要比<code>W</code>的参数大很多，因为由加速度计观测角度的噪声很大。</p>
<hr>
<h5 id="3-使用IMU来测量关节角度"><a href="#3-使用IMU来测量关节角度" class="headerlink" title="3.使用IMU来测量关节角度"></a>3.使用IMU来测量关节角度</h5><p>这里基于IMU设计了一套用来测量人体姿态的硬件，通过在身体每个肢段上放置一个IMU，测量每段肢体在空间中的姿态角，下位机使用单片机通过串口接收每个IMU模块的数据，然后通过CAN总线发送给上位机，上位机再解算出关节角度。制作的模块如下：</p>
<img src="/2021/02/28/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/1.IMU%E7%9A%84%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/8.jpg" class><img src="/2021/02/28/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/1.IMU%E7%9A%84%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/9.jpg" class>
<p>下图是测量大腿和小腿的数据，Matlab对接收的数据进行解算并实时显示出来。</p>
<img src="/2021/02/28/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/1.IMU%E7%9A%84%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/10.gif" class>
<p>下图是由IMU得到的行走状态下肢三关节的角度变化。初次实验采样频率设置的有点低，只有50HZ，所以波形看起来不太平滑。</p>
<img src="/2021/02/28/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/1.IMU%E7%9A%84%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/11.bmp" class>]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>硬件基础</tag>
      </tags>
  </entry>
  <entry>
    <title>An Introduction for IMU 2 - IMU数据融合与姿态解算</title>
    <url>/2021/03/02/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/2-IMU%E6%95%B0%E6%8D%AE%E8%9E%8D%E5%90%88%E4%B8%8E%E5%A7%BF%E6%80%81%E8%A7%A3%E7%AE%97/</url>
    <content><![CDATA[<p>在上一篇博客中，我们已经介绍了IMU的内部工作原理，以及如何通过Arduino读取MPU6050的数据。虽然可以从DMP直接读取姿态角，但其数据返回的频率相对较低，同时由于DMP库不是开源的，其内部的工作原理、输出姿态角的准确性都不清楚；而除了MPU以外的IMU传感器基本不带有DMP功能，因此大部分时候还是需要我们自己在单片机里实现IMU姿态角的计算。本片博客将介绍如何使用采集到的加速度和角速度数据进行数据融合，也就是IMU的姿态解算。</p>
<span id="more"></span>
<h2 id="IMU姿态解算"><a href="#IMU姿态解算" class="headerlink" title="IMU姿态解算"></a>IMU姿态解算</h2><p>MPU6050得到的原始数据仅有加速度与角速度，单独由加速度计或陀螺仪都可以解算出三轴的角度。</p>
<p><img src="/2021/03/02/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/2-IMU%E6%95%B0%E6%8D%AE%E8%9E%8D%E5%90%88%E4%B8%8E%E5%A7%BF%E6%80%81%E8%A7%A3%E7%AE%97/1.png" alt="1" style="zoom:50%;"></p>
<p>根据IMU的测量原理可知，加速度计测量的是底座对于质量块作用的力所产生的加速度。当模块处于静止时，质量块会受到向下的重力加速度，而加速度计的底座向质量块提供相反的加速度使质量块保持静止，因此在静止条件下加速度计会测量到1g竖直向上的加速度。当模块倾斜且<strong>保持静止</strong>时，可以通过重力加速度在另外一个/两个轴线上的分量计算得到模块的姿态角度：</p>
<script type="math/tex; mode=display">
{ AngleY }_{ {acc }}=\arctan \frac{accY}{accZ}</script><p>另一方面，由于角速度是角度的导数，通过对角速度积分也可以得到姿态角：</p>
<script type="math/tex; mode=display">
{ AngleY_{gyro } }={ AngleY }_{0}+\int_{0}^{T} { gyroYdt }</script><p>虽然可以从加速度和角速度分别解算出角度，但这两种方式都存在很大的问题。一方面由于加速度计容易受到振动的影响，噪声很大，所以解算角度的噪声也很大，同时加速度解算的角度仅适用于静态过程；另一方面虽然陀螺仪测量角速度的噪声不是很大，经过积分环节后噪声进一步被变小，但由于初始角度并不能准确得到，而且角速度存在零漂问题，经过积分后误差会被累积。因此，两种方式解算出来的角度都无法直接使用，但我们可以采用数据融合的方法，把两种角度融合在一起，得到一个既没有累计误差、噪声又小的角度数据。</p>
<hr>
<h2 id="互补滤波"><a href="#互补滤波" class="headerlink" title="互补滤波"></a>互补滤波</h2><p>一阶互补滤波是最简单但却非常实用的数据融合算法，它把由加速度解算的角度和由角速度积分的角度按照一定比例加到一起，公式如下：</p>
<script type="math/tex; mode=display">
Angle = K\cdot Angle_{acc}+(1-K)\cdot (Angle + \omega\cdot dt)</script><p>其中参数<code>K</code>表示对加速度解算角度的置信程度，由于加速度的噪声很大，所以参数<code>K</code>一般很小，典型值为<code>0.05</code>，实际使用要根据效果来调整。互补滤波器可以看做是一个高通滤波和一个低通滤波的叠加：公式的第一项是为低通滤波部分，目的是滤除加速度的噪声；公式的第二项为高通滤波部分，目的是滤除角速度的直流偏置（零漂）。</p>
<p>互补滤波容易理解，实现简单，运算量低；滤波器只有一个参数，所以比较容易调整；经过简单的传感器校准后，在大部分应用场景下都能取得比较好的效果。若需要更高的动态性能，可以考虑使用卡尔曼滤波。</p>
<hr>
<h2 id="卡尔曼滤波"><a href="#卡尔曼滤波" class="headerlink" title="卡尔曼滤波"></a>卡尔曼滤波</h2><p>卡尔曼滤波通过构建线性模型下的最优滤波器实现对IMU的数据融合与姿态解算，其中状态变量设置为角度和角速度的偏置：</p>
<script type="math/tex; mode=display">
State = \begin{bmatrix} Angle(k)  \\ Gyro_{bias}(k) \\  \end{bmatrix}</script><p>状态空间模型考虑带控制量的形式，并建立为如下形式，其中状态方程的控制量为陀螺仪测量的角速度，观测方程的观测量为加速度解算得到的角度：</p>
<script type="math/tex; mode=display">
\begin{bmatrix} Angle(k+1)  \\ Gyro_{bias}(k+1)   \end{bmatrix} = \begin{bmatrix} 1 & -dt \\ 0 & 1   \end{bmatrix}\begin{bmatrix} Angle(k)  \\ Gyro_{bias}(k) \end{bmatrix} + \begin{bmatrix} dt \\ 0  \end{bmatrix} Gyro(k) + Q(k)</script><script type="math/tex; mode=display">
Angle_{acc}(k) =\begin{bmatrix} 1 & 0  \end{bmatrix}  \begin{bmatrix} Angle(k) \\ Gyro_{bias}(k)  \end{bmatrix} + R(k)</script><p>其中矩阵<code>Q</code>和<code>R</code>分别为输入噪声矩阵和观测噪声矩阵，是滤波器的可调参数，表征模型与测量的准确性。由加速度计观测角度的噪声较大，同时动态过程中加速度解算的角度并不准确，所以对于本问题矩阵<code>R</code>的参数要比<code>Q</code>的参数大很多。</p>
<p>下面给出<strong>卡尔曼滤波的递推公式</strong>，关于对卡尔曼滤波的理解，可以参考<a href="https://zhuanlan.zhihu.com/p/39912633">其他博客</a>。</p>
<p>状态方程：</p>
<script type="math/tex; mode=display">
X(k+1)=AX(k)+BU(k)+Q(k)</script><script type="math/tex; mode=display">
Y(k)=CX(k)+R(k)</script><p>状态一步预测：</p>
<script type="math/tex; mode=display">
\hat X(k+1|k) = A\hat X(k|k)+BU(k)</script><script type="math/tex; mode=display">
P(k+1|k)=AP(k|k)A^T+Q(k)</script><p>状态更新：</p>
<script type="math/tex; mode=display">
K(k+1)=P(k+1|k)C^T[CP(k+1|k)C^T+R(k+1)]^{-1}=\frac{P(k+1|k)C^T}{CP(k+1|k)C^T+R(k+1)}</script><script type="math/tex; mode=display">
\hat X(k+1|k+1)=\hat X(k+1|k)+K(k+1)[Y(k+1)-CX(k+1|k)]</script><script type="math/tex; mode=display">
P(k+1|k+1)=P(k+1|k)-K(k+1)CP(k+1|k)</script><hr>
<h2 id="Arduino下的实现代码"><a href="#Arduino下的实现代码" class="headerlink" title="Arduino下的实现代码"></a>Arduino下的实现代码</h2><p>本部分介绍如何在Arduino下实现IMU的数据融合与姿态计算，分别通过一阶互补滤波和卡尔曼滤波进行实现。对于卡尔曼滤波器，目前网络博客上的嵌入式代码更多采用数组元素的加减乘除操作，来实现矩阵的各种运算，对于初学者来说增加了一定的难度。本文调用了Arduino的矩阵运算库来实现卡尔曼滤波器，执行上会增加一定的计算量和运算时间，但更方便初学者理解。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;BasicLinearAlgebra.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;math.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> BLA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> dt      = <span class="number">0.005</span>;</span><br><span class="line"><span class="keyword">float</span> Q_angle = <span class="number">0.001</span>;</span><br><span class="line"><span class="keyword">float</span> Q_gyro  = <span class="number">0.003</span>;</span><br><span class="line"><span class="keyword">float</span> R_angle = <span class="number">0.5</span>;</span><br><span class="line"><span class="keyword">float</span> K1      = <span class="number">0.05</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> Angle_Kalman, Bias_Kalman, Angle_FOCF;</span><br><span class="line"></span><br><span class="line">BLA::Matrix&lt;<span class="number">2</span>,<span class="number">1</span>&gt; X = &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">BLA::Matrix&lt;<span class="number">1</span>,<span class="number">1</span>&gt; Y = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">BLA::Matrix&lt;<span class="number">1</span>,<span class="number">1</span>&gt; U = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">BLA::Matrix&lt;<span class="number">2</span>,<span class="number">2</span>&gt; A = &#123;<span class="number">1</span>,dt,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">BLA::Matrix&lt;<span class="number">2</span>,<span class="number">1</span>&gt; B = &#123;dt,<span class="number">0</span>&#125;;</span><br><span class="line">BLA::Matrix&lt;<span class="number">1</span>,<span class="number">2</span>&gt; C = &#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">BLA::Matrix&lt;<span class="number">2</span>,<span class="number">2</span>&gt; P = &#123;<span class="number">0.1</span>,<span class="number">0.1</span>,<span class="number">0.1</span>,<span class="number">0.1</span>&#125;;</span><br><span class="line">BLA::Matrix&lt;<span class="number">2</span>,<span class="number">1</span>&gt; K = &#123;<span class="number">0.1</span>,<span class="number">0.1</span>&#125;;</span><br><span class="line">BLA::Matrix&lt;<span class="number">2</span>,<span class="number">2</span>&gt; Q = &#123;Q_angle,<span class="number">0</span>,<span class="number">0</span>,Q_gyro&#125;;</span><br><span class="line">BLA::Matrix&lt;<span class="number">1</span>,<span class="number">1</span>&gt; R = &#123;R_angle&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calIMU</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="comment">// Get IMU Raw Data</span></span><br><span class="line">  IMU.getMotion6(&amp;ax, &amp;ay, &amp;az, &amp;gx, &amp;gy, &amp;gz);  <span class="comment">//获取MPU6050陀螺仪和加速度计的数据</span></span><br><span class="line">  <span class="comment">// Convert Data to right unit</span></span><br><span class="line">  gyro = gx*<span class="number">250.0</span>/<span class="number">32767</span>,accel_z= az*<span class="number">2.0</span>*<span class="number">9.8</span>/<span class="number">32767</span>;</span><br><span class="line">  <span class="comment">// Calculate angle directly by two methods</span></span><br><span class="line">  accel_angle = <span class="built_in">atan2</span>(ay,az)*<span class="number">180.0</span>/PI, gyro_angle += (gyro+<span class="number">1</span>)*dt;</span><br><span class="line">  <span class="comment">// One-Order Complementary Filter</span></span><br><span class="line">  Fist_Older_Complementary_Filter(gyro,accel_angle);</span><br><span class="line">  <span class="comment">// Kalman Filter</span></span><br><span class="line">  Kalman_Filter(gyro,accel_angle);</span><br><span class="line">  <span class="comment">// Send Data to PC</span></span><br><span class="line">  ANO_DT_Send_Senser(gyro*<span class="number">100</span>, accel_z*<span class="number">100</span>, accel_angle*<span class="number">100</span>, gyro_angle*<span class="number">100</span>, Angle_FOCF*<span class="number">100</span>, Angle_Kalman*<span class="number">100</span>, Bias_Kalman*<span class="number">100</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fist_Older_Complementary_Filter</span><span class="params">(<span class="keyword">float</span> Gyro, <span class="keyword">float</span> Accel_Angle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Angle_FOCF = K1*Accel_Angle + (<span class="number">1</span> - K1)*(Angle_FOCF + Gyro * dt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kalman_Filter</span><span class="params">(<span class="keyword">float</span> Gyro, <span class="keyword">float</span> Accel_Angle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  U(<span class="number">0</span>,<span class="number">0</span>) = Gyro;</span><br><span class="line">  Y(<span class="number">0</span>,<span class="number">0</span>) = Accel_Angle;</span><br><span class="line">  </span><br><span class="line">  X = A*X + B*U;</span><br><span class="line">  P = A*P*~A + Q;</span><br><span class="line">  K = P*~C*((C*P*~C+R).Inverse());</span><br><span class="line">  X += K*(Y - C*X);</span><br><span class="line">  P -= K*C*P;</span><br><span class="line"></span><br><span class="line">  Angle_Kalman = X(<span class="number">0</span>, <span class="number">0</span>), Bias_Kalman = X(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单轴姿态解算的效果如下，其中黄色为加速度计解算的角度，蓝色为陀螺仪积分得到的角度，红色和绿色分别为一阶互补滤波和卡尔曼滤波的角度曲线。在Arduino Nano平台下，输出频率为200Hz，实测单次解算耗时约3.2ms。完整的解算代码可在<a href="https://github.com/JYChenNK/IMU_SYS/tree/main/2-calIMU-Filter">此处下载</a>。</p>
<p><img src="/2021/03/02/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/2-IMU%E6%95%B0%E6%8D%AE%E8%9E%8D%E5%90%88%E4%B8%8E%E5%A7%BF%E6%80%81%E8%A7%A3%E7%AE%97/GIF 2021-3-31 14-42-51.gif" alt="GIF 2021-3-31 14-42-51" style="zoom:8 0%;"></p>
]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>IMU系统</tag>
      </tags>
  </entry>
  <entry>
    <title>IMU无线系统设计</title>
    <url>/2021/10/01/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/IMU%E6%97%A0%E7%BA%BF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>在之前的博客中，已经对IMU的工作原理以及姿态结算方法进行了具体介绍，当时也设计了一个简单的有限姿态采集系统。在后来使用中发现，通过有线连接的IMU姿态采集系统，在运动过程中线缆连接处不可避免的会出现接触不良的情况，导致经常出现连接中断与数据丢失。因此在之前的基础上，设计了一套无线姿态传感系统，本文将主要介绍硬件设计的基本方案。</p>
<img src="/2021/10/01/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/IMU%E6%97%A0%E7%BA%BF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/13.png" class>
<span id="more"></span>
<h2 id="无线IMU硬件设计"><a href="#无线IMU硬件设计" class="headerlink" title="无线IMU硬件设计"></a>无线IMU硬件设计</h2><p>无线IMU姿态测量模块主要有五部分组成：锂电池、锂电池充电管理模块、锂电池输出稳压模块、维特智能的JY901以及汇承的HC-12无线通信模块，系统结构框图如上所示。为了方便佩戴，该传感器计划设计成较小的尺寸体积，长宽初步定为20*30mm。</p>
<h3 id="IMU模块"><a href="#IMU模块" class="headerlink" title="IMU模块"></a>IMU模块</h3><p>这里采用维特智能研发的<a href="https://item.taobao.com/item.htm?spm=a1z09.2.0.0.e1362e8d1hfpCq&amp;id=43511899945&amp;_u=j2e2b4db30d7">九轴姿态传感器</a>，内部集成Kalman滤波，输出频率可达200Hz，支持串口和IIC接口，同时价格较低。同时基于WT931的无线IMU模块在后续计划中，其采样频率可达500Hz。由于模块支持串口数据输出，因此将其串口直接连接无线模块接受端，并将数据发送至上位机。</p>
<blockquote>
<p>由于无线模块不支持发送AT指令，因此不同通过无线传输的方式对IMU的基本参数进行设置，只能实现基本的数据传输。</p>
</blockquote>
<p><img src="/2021/10/01/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/IMU%E6%97%A0%E7%BA%BF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/1605790727566.png" width="60%"></p>
<h3 id="无线通信模块"><a href="#无线通信模块" class="headerlink" title="无线通信模块"></a>无线通信模块</h3><p>无线通信模块采用汇承的<a href="https://item.taobao.com/item.htm?spm=a1z09.2.0.0.e1362e8d1hfpCq&amp;id=20265137304&amp;_u=j2e2b4db5c9c">HC-12</a>433M透传模块。在前期测试中发现，蓝牙通信在多机情况下不稳定，且通信距离较短；Wifi通信的通信延时不稳定。因此最终悬选择这款433M的无线透传模块，并且支持设置不同工作模式（低功耗、全速、远距）、不同的通信频道（0-999）。</p>
<blockquote>
<p>实际使用时需合理选择天线，同时通信频道最好间隔设置，即将通道设置为1,3,5,7,9…</p>
</blockquote>
<p><img src="/2021/10/01/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/IMU%E6%97%A0%E7%BA%BF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/1605791843906.png" width="60%"></p>
<h3 id="锂电池型号选择"><a href="#锂电池型号选择" class="headerlink" title="锂电池型号选择"></a>锂电池型号选择</h3><p>所采用的锂电池为为市面上常见的<a href="https://detail.tmall.com/item.htm?id=43641125910&amp;spm=a1z09.2.0.0.e1362e8d1hfpCq&amp;_u=j2e2b4dbbd93">3.7V聚合物锂电池</a>，电池内部自带过充保护板。考虑了体积的限制，最终选择容量为260mAh。</p>
<p><img src="/2021/10/01/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/IMU%E6%97%A0%E7%BA%BF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/1605786805794.png" width="60%"></p>
<h3 id="锂电池充电模块设计"><a href="#锂电池充电模块设计" class="headerlink" title="锂电池充电模块设计"></a>锂电池充电模块设计</h3><p>接下来为锂电池设计配套的充电模块。为方便充电，采用TypeC接头，充电芯片采用较为常用的<a href="https://atta.szlcsc.com/upload/public/pdf/watermark/20190926/C84051_A3C1A17BA2C9FBF3AD637A80C4632639.pdf">TP4056</a>，其主要参数如下：</p>
<img src="/2021/10/01/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/IMU%E6%97%A0%E7%BA%BF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/1605787978387.png" class>
<p>管脚功能说明如下：<br><img src="/2021/10/01/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/IMU%E6%97%A0%E7%BA%BF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/1605788045912.png" class><br><img src="/2021/10/01/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/IMU%E6%97%A0%E7%BA%BF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/1605788079933.png" class></p>
<p>参考数据手册中的典型应用电路，设计如下的充电电路：<br><img src="/2021/10/01/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/IMU%E6%97%A0%E7%BA%BF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/1605789032628.png" class><br>其中R4电阻需要根据电池容量来确定。锂电池的充电电流一般为电池容量的0.1~1.5倍，常规的充电电流为0.5倍电池容量。项目中由于需要对电池快速充电的需要，因此设计为接近1倍电池容量，充电电流与电阻R4的关系可由数据手册得到：</p>
<script type="math/tex; mode=display">
I_{BAT}=\frac{1200}{R_4}</script><h3 id="锂电池稳压模块设计"><a href="#锂电池稳压模块设计" class="headerlink" title="锂电池稳压模块设计"></a>锂电池稳压模块设计</h3><p>锂电池输出的电压会随电量的减少从4.2V降低到3.7V，在为传感器供电之前需要进行稳压。采用mini封装的<a href="https://atta.szlcsc.com/upload/public/pdf/source/20130730/1457706628575.pdf">RT9193</a>，将输出电压稳定在3.3<br><img src="/2021/10/01/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/IMU%E6%97%A0%E7%BA%BF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/1605790101539.png" class></p>
<p><img src="/2021/10/01/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/IMU%E6%97%A0%E7%BA%BF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/1605790250999.png" width="60%"></p>
<h3 id="原理图与PCB设计"><a href="#原理图与PCB设计" class="headerlink" title="原理图与PCB设计"></a>原理图与PCB设计</h3><p>将上面的几个部分结合在一起，同时增加一个开关，和一个用来调节JY901与HC-12连通的拨码开关，构成如下的原理图，并在此基础上设计了PCB电路。</p>
<img src="/2021/10/01/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/IMU%E6%97%A0%E7%BA%BF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/1605792242432.png" class>
<img src="/2021/10/01/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/IMU%E6%97%A0%E7%BA%BF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/1605792890624.png" class>
<img src="/2021/10/01/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/IMU%E6%97%A0%E7%BA%BF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/1605794866241.png" class>
<h3 id="传感器外壳设计"><a href="#传感器外壳设计" class="headerlink" title="传感器外壳设计"></a>传感器外壳设计</h3><p>为了方便传感器的安装和穿戴，同时为传感器提供必要的保护，设计了无线IMU的3D保护外壳。外壳由两部分组成，并借助PCB上的定位孔对PCB进行固定；对部分位置进行镂空，方便充电\LED显示\开关调节。突起圆柱体部分为无线模块的外置天线。</p>
<img src="/2021/10/01/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/IMU%E6%97%A0%E7%BA%BF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/1605796190829.png" class>
<img src="/2021/10/01/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/IMU%E6%97%A0%E7%BA%BF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/Snipaste_2020-11-14_18-41-28.png" class>
<h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><img src="/2021/10/01/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/IMU%E6%97%A0%E7%BA%BF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/1605792625091.jpg" class>
<img src="/2021/10/01/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/IMU%E6%97%A0%E7%BA%BF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/1605878803930.jpg" class>
<hr>
<h2 id="无线IMU硬件测试"><a href="#无线IMU硬件测试" class="headerlink" title="无线IMU硬件测试"></a>无线IMU硬件测试</h2><p>对于所搭建的无线IMU系统，进行了一系列的硬件测试，包括充电测试、稳压测试、通信测试、续航测试等，其中通信测试过程中遇到的玄学问题较多，也有可能是源自我对通信方面的了解不是很多，因此这里单独进行分析。注意该无线IMU系统还配有另外制作的数据接收机，由HC-12和一个单片机构成，比较简单，因此本文不进行介绍。</p>
<h3 id="通信稳定性测试"><a href="#通信稳定性测试" class="headerlink" title="通信稳定性测试"></a>通信稳定性测试</h3><p>所采用的HC-12为433M频段的无线通信模块，在串口波特率为9600bps时通信距离可达600m。但所使用的JY901姿态传感器在9600波特率时采样频率较低，因此必须提高传输波特率。经测试，通过HC-12将JY901数据发送至上位机时，采样频率与串口波特率的关系如下：BuadRate为57600时，SampleRate最大为100Hz；BaudRate为115200时，SampleRate最大为200Hz；对于100Hz以下的采样率，无法满足基本的实验需要，因此不进行考虑。然而实际通信的过程中，有可能因为通信距离以及各种干扰使采样率达不到最大水平。我基本为零的通信知识告诉我，波特率越高，通信会越不稳定，因此需要在更高的采样率与更好的稳定性之间进行折中，因此对57600和115200两种波特率进行通信稳定性的对比测试。</p>
<p>通信测试采用一组三个IMU，分别在57600和115200波特率下，将传感器环绕实验室一周（实验室环境较为复杂，有较多金属箱体会对通信产生干扰），记录整个过程接收数据频率的变化，结果如下图所示，左图为57600，右图为115200。</p>
<img src="/2021/10/01/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/IMU%E6%97%A0%E7%BA%BF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/IMU_Test_B57600_F100_M3_Freq.png" class>
<p>可以看出在115200波特率下，通信的确更不稳定，接收数据的频率最低达到110Hz，接收频率波动为45%；而57600波特率下最低接收频率为89Hz，接收频率波动为10%。因此若需要更稳定的数据通信，应选择波特率为57600，而考虑到115200波特率通信在实验环境下的最低接收频率也高于100Hz，因此最终还是讲通信波特率定为115200Hz。该配置下三个传感器的俯仰角数据接收情况如下图所示，数据较为平稳。</p>
<img src="/2021/10/01/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/IMU%E6%97%A0%E7%BA%BF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/IMU_Test_B115200_F200_M3_Curve.png" class>
<h3 id="无线IMU系统性能参数"><a href="#无线IMU系统性能参数" class="headerlink" title="无线IMU系统性能参数"></a>无线IMU系统性能参数</h3><blockquote>
<ul>
<li>重量：145g</li>
<li>尺寸：26mmx37mmx14mm</li>
<li>续航时长：3.5h</li>
<li>充电时长：1h</li>
<li>采样频率：200Hz</li>
<li>通信距离：实验室内均可，空旷条件下待测试</li>
</ul>
</blockquote>
<h2 id="无线IMU数据导入OpenSim"><a href="#无线IMU数据导入OpenSim" class="headerlink" title="无线IMU数据导入OpenSim"></a>无线IMU数据导入OpenSim</h2><p>在OpenSim最新的4.1版本中，新增了OpenSense模块提供对IMU数据的支持，但官方例程仅提供对Xsens支持。在所制作的无线IMU系统之上，进一步将采集的数据转化为OpenSim所支持的形式，并进行逆运动分析。所设计的无线IMU系统包含7个IMU，分别安装在盆骨和两侧的大腿、小腿、足上，上位机接收7个IMU的加速度、角速度和欧拉角数据，但只有欧拉角数据在本部分会被使用。由于OpenSense提供的是对四元数数据的支持，所以需要做一些必要的转换。数据处理与转化的基本流程如下，基于Matlab的示例程序见<a href="./OpenSenceDemo.zip">附件</a>。</p>
<img src="/2021/10/01/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/IMU%E6%97%A0%E7%BA%BF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/1607072414292.png" class>
<img src="/2021/10/01/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/IMU%E6%97%A0%E7%BA%BF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/120201204_162212.gif" class>]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>硬件开发</tag>
      </tags>
  </entry>
  <entry>
    <title>FPI无线足底压力鞋垫系统设计</title>
    <url>/2021/10/02/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/FPI%E6%97%A0%E7%BA%BF%E8%B6%B3%E5%BA%95%E5%8E%8B%E5%8A%9B%E9%9E%8B%E5%9E%AB%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>本篇为无线传感系统的第二篇，主要记录无线足底压力鞋垫的设计和制作。</p>
<img src="/2021/10/02/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/FPI%E6%97%A0%E7%BA%BF%E8%B6%B3%E5%BA%95%E5%8E%8B%E5%8A%9B%E9%9E%8B%E5%9E%AB%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/FPI_Rendering.gif" class title="FPI_Rendering">
<span id="more"></span>
<h2 id="压力鞋垫的测量原理"><a href="#压力鞋垫的测量原理" class="headerlink" title="压力鞋垫的测量原理"></a>压力鞋垫的测量原理</h2><p>压力鞋垫非自制，购买柔希科技的16P版本的压力鞋垫，鞋垫的压力传感器分布大致如下：</p>
<p><img src="/2021/10/02/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/FPI%E6%97%A0%E7%BA%BF%E8%B6%B3%E5%BA%95%E5%8E%8B%E5%8A%9B%E9%9E%8B%E5%9E%AB%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/鞋垫连线图.jpeg" width="100%"></p>
<p>一般来说电阻式薄膜压力传感器的构成一般分为五层结构：顶层和底层为绝缘保护层；之后是两个导电层，用来连接传感器传输信号，并且多数情况下导线会成矩阵式排列，以减少导线数量、增加传感器密度；最中间的是一层或两层的压力敏感材料。</p>
<img src="/2021/10/02/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/FPI%E6%97%A0%E7%BA%BF%E8%B6%B3%E5%BA%95%E5%8E%8B%E5%8A%9B%E9%9E%8B%E5%9E%AB%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/FPI_6.png" class title="截屏2021-06-09 下午9.21.55">
<p>压力传感器是利用电阻的压敏特性对压力进行测量，当压力作用在压敏材料上时，材料的电阻值会发生显著变化。多数压敏材料的电导率与压力成线性关系，因而电阻与压力之间成倒数关系，如上右图所示。</p>
<h2 id="压力鞋垫的数据采集"><a href="#压力鞋垫的数据采集" class="headerlink" title="压力鞋垫的数据采集"></a>压力鞋垫的数据采集</h2><img src="/2021/10/02/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/FPI%E6%97%A0%E7%BA%BF%E8%B6%B3%E5%BA%95%E5%8E%8B%E5%8A%9B%E9%9E%8B%E5%9E%AB%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/FPI_1.png" class title="FPI_1">
<p>上面已经已到，压力鞋垫为了提高压力测量点的密度，减少导线数量，降低对采集芯片的引脚需求，一般采用矩阵式的排线方法，也就是同一根导线会连接多个传感器。一般来说，压力鞋垫上所有的传感器都按排和列进行划分，每一排或每一列都连接相同一根导线，任意选定一行和一列都可以唯一确定一个压力测量点。如上所示，柔细科技的16P压力鞋垫就将16个传感器分为4行6列，这样就可以将16根信号线降低为10根信号线，进一步若将列通道作为选通信号，则只有4根行信号线需要连接到模拟量采集端口。但这样矩阵式的布线方式也会给数据采集带来一些困难。</p>
<p>在多数论文里，为了进一步减少压力鞋垫需要的采集引脚数目，会选择采用多路选通器来进行行扫描，典型的有8路模拟多路选通器CD4051。这种芯片能够通过三个控制线以2进制编码的形式控制8个通道与公共端的连接，而当某一通道与公共端连通时，其余各通道均处于悬空状态。我们将鞋垫的列信号线接到CD4051的其中6路选通引脚上，然后用单片机接CD4051的A B C引脚控制选通信号，就可以用3个引脚控制压力鞋垫的6路列信号选通线。</p>
<img src="/2021/10/02/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/FPI%E6%97%A0%E7%BA%BF%E8%B6%B3%E5%BA%95%E5%8E%8B%E5%8A%9B%E9%9E%8B%E5%9E%AB%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/FPI_7.png" class title="截屏2021-06-10 下午4.29.32">
<p>当CD4051的公共端连接VCC时，采集电路如下所示，以col6被选通为例，col6与公共端连通故电压为VCC，行信号连接一个分压电阻Rf后连接到GND。由于当col6选通时，col1-col5均为悬空状态，其余压力测量点的合成电阻对该采样电路没有影响，因此通过测量row1上的电压vol1，以及已知的分压电阻Rf，就可以得到压力测量点电阻R6的大小。在前期测试中压力电阻阻值范围为20M-50K，分压电阻Rf可以取10K-500K之间，分压电阻太小会导致测量精度下降，在前期实验中，Rf选择为200K。</p>
<img src="/2021/10/02/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/FPI%E6%97%A0%E7%BA%BF%E8%B6%B3%E5%BA%95%E5%8E%8B%E5%8A%9B%E9%9E%8B%E5%9E%AB%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/FPI_2.png" class title="截屏2021-06-10 下午3.55.05">
<p>但在后续实验中发现，CD4051在通道切换的时候存在比较明显的响应过程。下图展示的是col6通道选通后，间隔100us连续采样14次，vol1的电压变化，曲线非常符合一阶指数响应过程，同时也显示该响应过程有较大的时间常数，T约为1/1411=700us，到达稳态需要3T时间也就是2.1ms，这样6个列通道全部采样一次就需要12.6ms，鞋垫压力的采样频率会小于100Hz，这是无法接受的。想要实现200Hz以上的采样频率，通道切换的过渡时间需要小于280us。</p>
<img src="/2021/10/02/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/FPI%E6%97%A0%E7%BA%BF%E8%B6%B3%E5%BA%95%E5%8E%8B%E5%8A%9B%E9%9E%8B%E5%9E%AB%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/Snipaste_2021-06-07_09-43-03.png" class title="Snipaste_2021-06-07_09-43-03">
<p>进一步我们采用示波器观测通道切换时，vol1的电压变化曲线。单片机控制CD4051每间隔1ms在col6和col5之间进行一次切换，并且在通道6的压力采样点上有一个稳定持续的压力，通道5上没有压力，因此下图所示的波形会在高低电平之间不断切换，切换间隔为1ms。可以看出波形有明显的响应过程，并且在切换到通道5时，响应的时间常数更大一些。</p>
<img src="/2021/10/02/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/FPI%E6%97%A0%E7%BA%BF%E8%B6%B3%E5%BA%95%E5%8E%8B%E5%8A%9B%E9%9E%8B%E5%9E%AB%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/Snipaste_2021-06-08_10-55-36.png" class title="Snipaste_2021-06-08_10-55-36">
<p>当CD4051从通道6切换到通道5时，除了col5上所施加的电压VCC外，由于上一时刻在作用在col6上的电压在通道关断后不会立刻消失，依靠电容效应随着放电过程电压逐渐降低，由叠加定义可知其仍然对vol1的电压产生影响，因此我们看到切换到通道5之后vol1的电压缓慢下降。而在从通道5切换到通道6时，由于col5上原来的电压较低，因此对col6的vol1影响较小，但还是可以看到一点缓慢下降的趋势。</p>
<img src="/2021/10/02/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/FPI%E6%97%A0%E7%BA%BF%E8%B6%B3%E5%BA%95%E5%8E%8B%E5%8A%9B%E9%9E%8B%E5%9E%AB%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/FPI_3.png" class title="截屏2021-06-10 下午7.28.34">
<p>调研了解现有的足底压力系统有可以实现200Hz的采样频率，推测本实验中较大的过渡时间是由于CD4051芯片本身的特性造成的。因此后面尝试去除CD4051，直接使用单片机本身的引脚连接压力鞋垫的列选通信号线。连接col的单片机引脚设置为数字量输出模式，当信号选通时，将该引脚设置为高电平，并将其余引脚设置为低电平。实验中单片机每间隔300us切换一次选通信号，通道6的传感器上依然有一个持续施加的作用力。下图所示的为Rf分别为200K、100K、50K时的vol1波形：</p>
<img src="/2021/10/02/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/FPI%E6%97%A0%E7%BA%BF%E8%B6%B3%E5%BA%95%E5%8E%8B%E5%8A%9B%E9%9E%8B%E5%9E%AB%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/Snipaste_2021-06-08_17-03-51_200k.png" class title="Snipaste_2021-06-08_17-03-51_200k">
<img src="/2021/10/02/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/FPI%E6%97%A0%E7%BA%BF%E8%B6%B3%E5%BA%95%E5%8E%8B%E5%8A%9B%E9%9E%8B%E5%9E%AB%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/Snipaste_2021-06-08_17-05-08_100k.png" class title="Snipaste_2021-06-08_17-05-08_100k">
<img src="/2021/10/02/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/FPI%E6%97%A0%E7%BA%BF%E8%B6%B3%E5%BA%95%E5%8E%8B%E5%8A%9B%E9%9E%8B%E5%9E%AB%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/Snipaste_2021-06-08_17-05-53_50k.png" class title="Snipaste_2021-06-08_17-05-53_50k">
<p>随着Rf的下降，电路时间常数1/RC降低，通道切换的响应时间变短，同时由于分压下降，col6采集的稳态电压也逐渐下降。当Rf选择为50K时，过渡时间小于250us，基本可以满足500Hz采样的需要。</p>
<p>但这种将列选通信号直接连接到单片机引脚上的方法存在一个比较严重的问题：同一行的传感器之间会相互影响：</p>
<img src="/2021/10/02/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/FPI%E6%97%A0%E7%BA%BF%E8%B6%B3%E5%BA%95%E5%8E%8B%E5%8A%9B%E9%9E%8B%E5%9E%AB%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/GIF.gif" class title="GIF">
<p>上图所示的依然是对row1的6个传感器进行扫描，其中col6上作用一个稳定持续的压力不随时间发生改变，col5和col4上作用一个时变的压力。可以看出，在col5或col4压力变化时，col6的电压也会跟随发生改变。具体来说，当同一行的其他传感器的压力增大时，col6的电电压会减小。</p>
<p>下图为当前系统的电路连接示意图。由于所有的列选通信号都是连接单片机的数字量输出引脚，在非选通时引脚置为低电平，实际上也就是与GND直接相连，而非处于悬空状态。此时测量电路的实际分压电阻$ Rf^r $将是Rf与R15的并联，当其余电阻因受到压力而阻值下降时，$ Rf^r $会随之下降，vol1上的分压也因此降低。</p>
<img src="/2021/10/02/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/FPI%E6%97%A0%E7%BA%BF%E8%B6%B3%E5%BA%95%E5%8E%8B%E5%8A%9B%E9%9E%8B%E5%9E%AB%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/FPI_4.png" class title="截屏2021-06-10 下午8.50.39">
<p>所以为了消除通道之间的耦合影响，需要将非选通的col通道设置为悬空状态，而不能连接到GND。程序上可以通过将引脚改变为输入模式来实现，因为在输入模式下引脚处于高阻状态近似于悬空（但不能设置为上拉输入或下拉输入）。下面为调整的后扫描曲线，在col5和col4压力变化时col1基本不受影响。</p>
<img src="/2021/10/02/5-Projects/%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/FPI%E6%97%A0%E7%BA%BF%E8%B6%B3%E5%BA%95%E5%8E%8B%E5%8A%9B%E9%9E%8B%E5%9E%AB%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/GIF2.gif" class title="GIF2">
<h2 id="无线压力鞋垫系统PCB设计"><a href="#无线压力鞋垫系统PCB设计" class="headerlink" title="无线压力鞋垫系统PCB设计"></a>无线压力鞋垫系统PCB设计</h2>]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>硬件开发</tag>
      </tags>
  </entry>
  <entry>
    <title>MicroLabBox教程 1 - Basic Info &amp; Quick Start</title>
    <url>/2021/06/11/4-Tutorials/dSPACE/dSPACE-01/Basic%20Info%20&amp;%20Quick%20Start/</url>
    <content><![CDATA[<p>本篇简要介绍dSPACE - MicroLabBox的背景知识，演示使用Simulink快速开发dSPACE的基本流程。</p>
<img src="/2021/06/11/4-Tutorials/dSPACE/dSPACE-01/Basic%20Info%20&%20Quick%20Start/0.png" class title="Untitled">
<span id="more"></span>
<h2 id="MicroLabBox"><a href="#MicroLabBox" class="headerlink" title="MicroLabBox"></a><strong>MicroLabBox</strong></h2><ul>
<li><strong><a href="https://www.dspace.com/zh/zho/home/products.cfm">MicroLabBox</a></strong>是由德国dSPACE公司开发的一套基于MATLAB/Simulink的控制系统开发及半实物仿真的软硬件系统，<strong>用于实验室的一体化开发，在汽车行业的原型机开发中有非常广泛的应用；</strong></li>
<li>dSPACE的实时系统拥有<strong>实时性强</strong>、<strong>可靠性高</strong>、扩充性好等优点，处理器具有高速的计算能力，并配备了丰富的I/O支持，用户可以根据需要进行组合；软件环境的功能强大且使用方便，包括实现代码自动生成/下载和试验/调试的整套工具，是<strong>快速控制原型验证</strong>和<strong>半实物仿真（硬件在环仿真）</strong>的首选实时平台；</li>
</ul>
<h2 id="MicroLabBox的开发流程"><a href="#MicroLabBox的开发流程" class="headerlink" title="MicroLabBox的开发流程"></a><strong>MicroLabBox的开发流程</strong></h2><img src="/2021/06/11/4-Tutorials/dSPACE/dSPACE-01/Basic%20Info%20&%20Quick%20Start/01.png" class title="image-20211102013716732">
<hr>
<img src="/2021/06/11/4-Tutorials/dSPACE/dSPACE-01/Basic%20Info%20&%20Quick%20Start/02.png" class title="未标题-1.png">
<h2 id="First-Routine"><a href="#First-Routine" class="headerlink" title="First Routine"></a>First Routine</h2><h3 id="Step-1-创建Simulink文件并编写程序"><a href="#Step-1-创建Simulink文件并编写程序" class="headerlink" title="Step-1 创建Simulink文件并编写程序"></a>Step-1 创建Simulink文件并编写程序</h3><ul>
<li>新建Simulink Model并<strong>选择RTI1202模版</strong></li>
</ul>
<img src="/2021/06/11/4-Tutorials/dSPACE/dSPACE-01/Basic%20Info%20&%20Quick%20Start/3.png" class title="Untitled">
<img src="/2021/06/11/4-Tutorials/dSPACE/dSPACE-01/Basic%20Info%20&%20Quick%20Start/4.png" class title="Untitled">
<ul>
<li>从Simulink Library中拖拽需要的<strong>dSPACE功能包（IO接口）</strong>，并完成完整的程序</li>
</ul>
<img src="/2021/06/11/4-Tutorials/dSPACE/dSPACE-01/Basic%20Info%20&%20Quick%20Start/5.png" class title="Untitled">
<img src="/2021/06/11/4-Tutorials/dSPACE/dSPACE-01/Basic%20Info%20&%20Quick%20Start/6.png" class title="Untitled">
<ul>
<li>编译程序，生成<code>.sdf</code>文件</li>
</ul>
<img src="/2021/06/11/4-Tutorials/dSPACE/dSPACE-01/Basic%20Info%20&%20Quick%20Start/7.png" class title="Untitled">
<p><strong>Tips</strong></p>
<ul>
<li>编译前，确保dSPACE已经上电，并通过网线连接到电脑，否则报错</li>
<li>编译的文件会生成在Matlab当前工作目录下，编译前确保路径正确</li>
</ul>
<h3 id="Step-2-创建ControlDesk工程并设计交互界面"><a href="#Step-2-创建ControlDesk工程并设计交互界面" class="headerlink" title="Step-2 创建ControlDesk工程并设计交互界面"></a>Step-2 创建ControlDesk工程并设计交互界面</h3><ul>
<li>打开dSPACE，新建工程，设置项目地址、项目名称、实验名称</li>
</ul>
<img src="/2021/06/11/4-Tutorials/dSPACE/dSPACE-01/Basic%20Info%20&%20Quick%20Start/8.png" class title="Untitled">
<img src="/2021/06/11/4-Tutorials/dSPACE/dSPACE-01/Basic%20Info%20&%20Quick%20Start/9.png" class title="Untitled">
<ul>
<li>选择硬件平台（默认，无需操作），设置该实验的<code>sdf</code>文件</li>
</ul>
<img src="/2021/06/11/4-Tutorials/dSPACE/dSPACE-01/Basic%20Info%20&%20Quick%20Start/10.png" class title="Untitled">
<img src="/2021/06/11/4-Tutorials/dSPACE/dSPACE-01/Basic%20Info%20&%20Quick%20Start/11.png" class title="Untitled">
<ul>
<li>ControlDesk交互界面</li>
</ul>
<img src="/2021/06/11/4-Tutorials/dSPACE/dSPACE-01/Basic%20Info%20&%20Quick%20Start/12.png" class title="Untitled">
<ul>
<li>根据需要设计交互界面</li>
</ul>
<blockquote>
<p><strong>步骤</strong></p>
<ul>
<li>在控件栏中拖选需要的控件至交互界面区</li>
<li>从程序变量区选择需要的变量拖动到控件上以建立连接</li>
<li>编辑控件属性使之匹配变量的需要</li>
</ul>
</blockquote>
<img src="/2021/06/11/4-Tutorials/dSPACE/dSPACE-01/Basic%20Info%20&%20Quick%20Start/13.png" class title="Untitled">
<img src="/2021/06/11/4-Tutorials/dSPACE/dSPACE-01/Basic%20Info%20&%20Quick%20Start/14.png" class title="Untitled">
<h3 id="Step-3-下载并运行程序"><a href="#Step-3-下载并运行程序" class="headerlink" title="Step-3 下载并运行程序"></a>Step-3 下载并运行程序</h3><img src="/2021/06/11/4-Tutorials/dSPACE/dSPACE-01/Basic%20Info%20&%20Quick%20Start/15.png" class title="Untitled">
<img src="/2021/06/11/4-Tutorials/dSPACE/dSPACE-01/Basic%20Info%20&%20Quick%20Start/16.png" class title="Untitled">
<blockquote>
<p>在Ch1和Ch4引脚之间连接LED，通过点击按钮控制LED的亮灭</p>
</blockquote>
<h2 id="Step-4-修改程序并重新烧录"><a href="#Step-4-修改程序并重新烧录" class="headerlink" title="Step-4 修改程序并重新烧录"></a>Step-4 修改程序并重新烧录</h2><ul>
<li>和step 2中相同的方法创建另外2个数字量输出，新增一个数字量输入接口，重新烧录程序</li>
</ul>
<img src="/2021/06/11/4-Tutorials/dSPACE/dSPACE-01/Basic%20Info%20&%20Quick%20Start/17.png" class title="Untitled">
<blockquote>
<p><strong>Tips</strong></p>
<ul>
<li>确保Matlab当前工作目录在之前的sdf文件目录下</li>
<li>在编译之前需要在ControlDesk中Go offline</li>
<li>在ControlDesk中重新加载程序（Go Online）</li>
</ul>
</blockquote>
<img src="/2021/06/11/4-Tutorials/dSPACE/dSPACE-01/Basic%20Info%20&%20Quick%20Start/18.png" class title="Untitled">
<img src="/2021/06/11/4-Tutorials/dSPACE/dSPACE-01/Basic%20Info%20&%20Quick%20Start/19.png" class title="Untitled">
<img src="/2021/06/11/4-Tutorials/dSPACE/dSPACE-01/Basic%20Info%20&%20Quick%20Start/20.png" class title="Untitled">
<ul>
<li><strong>Tips</strong><ul>
<li>如果正确的编译得到了新的程序（sdf文件），在Go Online时需要点击2/3次确认按钮</li>
<li>重新设计交互界面，并运行</li>
</ul>
</li>
</ul>
<img src="/2021/06/11/4-Tutorials/dSPACE/dSPACE-01/Basic%20Info%20&%20Quick%20Start/21.png" class title="Untitled">
<ul>
<li><strong>Tips</strong><ul>
<li>对于含有曲线的控件，需要点击Start Measuring以开启测量</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>tutorials</category>
      </categories>
      <tags>
        <tag>dSPACE</tag>
      </tags>
  </entry>
  <entry>
    <title>MicroLabBox教程 4 - dSPACE硬件接口 高级篇</title>
    <url>/2021/06/14/4-Tutorials/dSPACE/dSPACE-04/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/</url>
    <content><![CDATA[<p>本篇简单介绍如何将不支持的设备连接至dSPACE。</p>
<span id="more"></span>
<h2 id="Demo-1-dSPCAE控制跑台"><a href="#Demo-1-dSPCAE控制跑台" class="headerlink" title="Demo 1 - dSPCAE控制跑台"></a>Demo 1 - dSPCAE控制跑台</h2><img src="/2021/06/14/4-Tutorials/dSPACE/dSPACE-04/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/Untitled.png" class title="Untitled">
<img src="/2021/06/14/4-Tutorials/dSPACE/dSPACE-04/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/Untitled_1.png" class title="Untitled">
<img src="/2021/06/14/4-Tutorials/dSPACE/dSPACE-04/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/Untitled_2.png" class title="Untitled">
<hr>
<h2 id="Demo-2-dSPACE实时采集呼吸代谢数据"><a href="#Demo-2-dSPACE实时采集呼吸代谢数据" class="headerlink" title="Demo 2 - dSPACE实时采集呼吸代谢数据"></a>Demo 2 - dSPACE实时采集呼吸代谢数据</h2><img src="/2021/06/14/4-Tutorials/dSPACE/dSPACE-04/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/Untitled_3.png" class title="Untitled">
<img src="/2021/06/14/4-Tutorials/dSPACE/dSPACE-04/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/image-20211124172814323.png" class title="image-20211124172814323">
<img src="/2021/06/14/4-Tutorials/dSPACE/dSPACE-04/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/Untitled_7.png" class title="Untitled">]]></content>
      <categories>
        <category>tutorials</category>
      </categories>
      <tags>
        <tag>dSPACE</tag>
      </tags>
  </entry>
  <entry>
    <title>MicroLabBox教程 2 - dSPACE硬件接口 基础篇</title>
    <url>/2021/06/12/4-Tutorials/dSPACE/dSPACE-02/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<p>本篇介绍dSPACE简单硬件接口的基本使用方法，包含数字量输入输出、模拟量输入输出、PWM信号输入输出，以及供电模块。</p>
<span id="more"></span>
<h3 id="数字量输出"><a href="#数字量输出" class="headerlink" title="数字量输出"></a>数字量输出</h3><img src="/2021/06/12/4-Tutorials/dSPACE/dSPACE-02/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E5%9F%BA%E7%A1%80%E7%AF%87/Untitled.png" class title="Untitled">
<ul>
<li><strong>Tips</strong><ul>
<li>管脚配置：<ul>
<li>dSPACE的数字量引脚分为A、B两组，A组为基本DIO，B为高级DIO（只接受互补信号）</li>
<li>基本DIO分为三个端口，每端口16个通道，可以设置为按组输出模式</li>
</ul>
</li>
<li>输出配置：可配置为2.5\3.3\5V三种电平</li>
<li>接受信号类型：布尔，或布尔向量（Matlab/Simulink默认类型为浮点型，对于输入需要加以数据类型转换）</li>
</ul>
</li>
</ul>
<blockquote>
<p>两种修改数据类型的方法</p>
<ul>
<li>在模块中修改输出属性</li>
<li>使用convert模块转换数据类型</li>
</ul>
</blockquote>
<img src="/2021/06/12/4-Tutorials/dSPACE/dSPACE-02/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E5%9F%BA%E7%A1%80%E7%AF%87/Untitled1.png" class title="Untitled">
<img src="/2021/06/12/4-Tutorials/dSPACE/dSPACE-02/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E5%9F%BA%E7%A1%80%E7%AF%87/Untitled2.png" class title="Untitled">
<h3 id="数字量输入"><a href="#数字量输入" class="headerlink" title="数字量输入"></a>数字量输入</h3><img src="/2021/06/12/4-Tutorials/dSPACE/dSPACE-02/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E5%9F%BA%E7%A1%80%E7%AF%87/Untitled3.png" class title="Untitled">
<ul>
<li><strong>Tips</strong><ul>
<li>管脚配置：dSPACE的所有数字量引脚均可设置为输入或输出模式，和输出一样可以配置为按组输</li>
<li>为保证模块正常工作，输入模块后面必须接有其他模块</li>
</ul>
</li>
</ul>
<h3 id="数字量信号的管脚映射"><a href="#数字量信号的管脚映射" class="headerlink" title="数字量信号的管脚映射"></a>数字量信号的管脚映射</h3><blockquote>
<p>ch1 - ch48  →  DB50 → 拓展板</p>
</blockquote>
<img src="/2021/06/12/4-Tutorials/dSPACE/dSPACE-02/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211102025047013.png" class title="image-20211102025047013">
<hr>
<h3 id="模拟量输出和输入"><a href="#模拟量输出和输入" class="headerlink" title="模拟量输出和输入"></a>模拟量输出和输入</h3><img src="/2021/06/12/4-Tutorials/dSPACE/dSPACE-02/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E5%9F%BA%E7%A1%80%E7%AF%87/2221635676258_.pic.jpg" class title="2221635676258_.pic.jpg">
<ul>
<li><strong>Tips</strong><ul>
<li>dSPACE有一组模拟量输出通道AO1，和两组模拟量输入通道AI1和AI2，AO1有16个通道，AI1包含24个通道，AI2有8个通道（32个输入，16个输出）；</li>
<li>所有模拟量引脚均为BNC接口，其内芯为信号线，外部为地线/反相线，测量/输出电压均为两线之差；</li>
<li>模拟量输入/输出范围均为-10V / +10V；</li>
<li>dSPACE模拟量输入输出模块内部对电压进行了标准化，输出/输入的范围为-1/+1，<strong>即指令1代表输出10V电压</strong>，需要进行单位转换（输入信号需要放大10倍，输出信号需要缩小10倍）</li>
</ul>
</li>
</ul>
<img src="/2021/06/12/4-Tutorials/dSPACE/dSPACE-02/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E5%9F%BA%E7%A1%80%E7%AF%87/Untitled5.png" class title="Untitled">
<img src="/2021/06/12/4-Tutorials/dSPACE/dSPACE-02/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E5%9F%BA%E7%A1%80%E7%AF%87/Untitled6.png" class title="Untitled">
<hr>
<h3 id="PWM输出和输入"><a href="#PWM输出和输入" class="headerlink" title="PWM输出和输入"></a>PWM输出和输入</h3><blockquote>
<p><strong>dPSACE所有DIO1管脚（48个通道）都支持配置为PWM输入和输出模式</strong></p>
</blockquote>
<img src="/2021/06/12/4-Tutorials/dSPACE/dSPACE-02/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E5%9F%BA%E7%A1%80%E7%AF%87/Untitled7.png" class title="Untitled">
<ul>
<li><strong>Tips</strong><ul>
<li>输出指定周期、指定占空比的PWM信号，周期单位为秒，占空比范围0-1，1代表100%占空比（一条直线），二者都可以在线修改</li>
</ul>
</li>
</ul>
<img src="/2021/06/12/4-Tutorials/dSPACE/dSPACE-02/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E5%9F%BA%E7%A1%80%E7%AF%87/Untitled8.png" class title="Untitled">
<ul>
<li>Tips<ul>
<li>dSPACE中包含两种PWM输入模块，一种返回脉冲宽度时间（单位s），另一种返回PWM频率（Hz）和占空比（0-1）</li>
</ul>
</li>
</ul>
<hr>
<h3 id="Power-Supply"><a href="#Power-Supply" class="headerlink" title="Power Supply"></a>Power Supply</h3><img src="/2021/06/12/4-Tutorials/dSPACE/dSPACE-02/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E5%9F%BA%E7%A1%80%E7%AF%87/WechatIMG223.jpeg" class title="WechatIMG223.jpeg">
<img src="/2021/06/12/4-Tutorials/dSPACE/dSPACE-02/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E5%9F%BA%E7%A1%80%E7%AF%87/Untitled9.png" class title="Untitled">
<ul>
<li>Tips<ul>
<li>dSPACE中包含两组电源输出，A组输出固定12V电压，不可被编程，上电即工作；B组为可调电压输出（2-20V），但输出功率较小；</li>
<li>对于数字电路/模块供电的情况，在工作功率/电流极低的情况下，可以使用数字量输入输出引脚直接供电，<strong>功率模块禁止此操作</strong>；</li>
<li><strong>任何涉及供电的配置、连线、测试务必十分小心！！！</strong></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>tutorials</category>
      </categories>
      <tags>
        <tag>dSPACE</tag>
      </tags>
  </entry>
  <entry>
    <title>MicroLabBox教程 5 - dSPACE程序设计 初级篇</title>
    <url>/2021/06/15/4-Tutorials/dSPACE/dSPACE-05/dSPACE%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%88%9D%E7%BA%A7%E7%AF%87/</url>
    <content><![CDATA[<p>本篇介绍dSPACE程序设计的一些基本方法、思维与技巧。<br><span id="more"></span></p>
<p>本部分在<code>Task1 - 关节角度指示器</code>的基础上进行讲解。<br><strong>Task 1 - 关节角度指示器</strong></p>
<blockquote>
<ul>
<li>dSPACE连接磁编码器和RGB模块，磁编码器的V G S分别连接DIO1的ch5-ch7，RGB的信号线连接DIO1的ch29-ch31；</li>
<li>当踝关节角度在-15deg到15deg之间，RGB模块亮绿灯；</li>
<li>当踝关节的角度由-15deg减小到-25deg，或由15deg增加到25deg，RBG模块由绿灯渐变为红灯；</li>
<li>当踝关节角度小于-25deg或大于25deg，RGB模块红灯闪烁；</li>
</ul>
</blockquote>
<img src="/2021/06/15/4-Tutorials/dSPACE/dSPACE-05/dSPACE%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%88%9D%E7%BA%A7%E7%AF%87/Untitled.png" class title="Untitled">
<hr>
<h2 id="1-使用局部寄存变量"><a href="#1-使用局部寄存变量" class="headerlink" title="1 - 使用局部寄存变量"></a>1 - 使用局部寄存变量</h2><blockquote>
<p>实现功能：通过点击按钮，对磁编码器测量到的踝关节角度进行校准；</p>
</blockquote>
<p>⭐ <strong>dSPACE中Simulink模型的执行过程（1）</strong></p>
<p>dSPACE运行时Simulink的主要模块每隔一固定时间会被全部执行一次；Matlab Function中直接定义的变量均为局部变量，每个周期执行完之后都会被释放掉，没有记忆性；</p>

<h3 id="实现变量寄存的两种方式"><a href="#实现变量寄存的两种方式" class="headerlink" title="实现变量寄存的两种方式"></a>实现变量寄存的两种方式</h3><ul>
<li><strong>1 - 寄存器（延时模块）</strong></li>
</ul>
<img src="/2021/06/15/4-Tutorials/dSPACE/dSPACE-05/dSPACE%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%88%9D%E7%BA%A7%E7%AF%87/image-20211124173611883.png" class title="image-20211124173611883">
<ul>
<li><strong>2- 局部寄存变量（persistent &amp; 初始化）</strong></li>
</ul>
<img src="/2021/06/15/4-Tutorials/dSPACE/dSPACE-05/dSPACE%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%88%9D%E7%BA%A7%E7%AF%87/image-20211124173637760.png" class title="image-20211124173637760">
<hr>
<h2 id="2-模块化与参数化"><a href="#2-模块化与参数化" class="headerlink" title="2 - 模块化与参数化"></a>2 - 模块化与参数化</h2><ul>
<li><strong>低耦合，高内聚</strong> - 将复杂函数功能模块化、功能化</li>
</ul>

<ul>
<li>使用<strong>SubSystem</strong>对功能化模块进行封装</li>
</ul>

<ul>
<li>使用<strong>Mask</strong>对模块参数进行封装</li>
</ul>
<img src="/2021/06/15/4-Tutorials/dSPACE/dSPACE-05/dSPACE%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%88%9D%E7%BA%A7%E7%AF%87/image-20211124173716755.png" class title="image-20211124173716755">

<p>💡 <strong><em>参数的作用域</em></strong></p>
<ul>
<li>通过Mask定义的参数仅在其内部所有模块和子模块中起作用；</li>
<li>在Simulink的Model Properties → Callbacks → InitFcn*下定义的参数可在全局调用；</li>
<li>参数可以在子系统中按名称进行传递；</li>
</ul>
<img src="/2021/06/15/4-Tutorials/dSPACE/dSPACE-05/dSPACE%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%88%9D%E7%BA%A7%E7%AF%87/image-20211124173742558.png" class title="image-20211124173742558">
<hr>
<h2 id="3-状态机"><a href="#3-状态机" class="headerlink" title="3 - 状态机"></a>3 - 状态机</h2><p><a href="https://zhuanlan.zhihu.com/p/47434856">什么是状态机？</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA">有限状态机 - 维基百科，自由的百科全书</a></p>
<blockquote>
<p>实现功能：当关节角度超过最大角度时，RGB保持红灯闪烁，直到上位机点击按钮清除该错误状态；</p>
</blockquote>
<ul>
<li><code>if-else</code> → <strong>系统状态</strong>、<strong>状态转移条件</strong>、<strong>状态执行动作</strong></li>
</ul>
<img src="/2021/06/15/4-Tutorials/dSPACE/dSPACE-05/dSPACE%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%88%9D%E7%BA%A7%E7%AF%87/image-20211124173837024.png" class title="image-20211124173837024">
<ul>
<li><strong>外骨骼的控制系统需要在静止、校准以及不同辅助模式下切换，都需要通过状态机来实现</strong></li>
</ul>
<hr>
<h2 id="4-使用全局寄存变量"><a href="#4-使用全局寄存变量" class="headerlink" title="4 - 使用全局寄存变量"></a>4 - 使用全局寄存变量</h2><blockquote>
<p>实现功能：当系统清除错误状态时，同时清空踝关节角度的校准偏置（<code>angle_bias=0</code>）</p>
<ul>
<li>错误形式</li>
</ul>
</blockquote>
<img src="/2021/06/15/4-Tutorials/dSPACE/dSPACE-05/dSPACE%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%88%9D%E7%BA%A7%E7%AF%87/Untitled15.png" class>
<p>⭐ <strong>dSPACE中Simulink模型的执行过程（2）</strong></p>
<p>在每隔控制周期，dSPACE按照<strong>信号流向</strong>，从首至尾<strong>顺序执行；禁止存在环路信号</strong></p>
<ul>
<li><strong>方法 1 - 使用单位延迟</strong></li>
</ul>
<img src="/2021/06/15/4-Tutorials/dSPACE/dSPACE-05/dSPACE%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%88%9D%E7%BA%A7%E7%AF%87/Untitled16.png" class title="Untitled">
<ul>
<li><p><strong>方法 2 - 使用全局寄存变量</strong></p>
<ul>
<li><p><strong>Step 1 创建 -</strong> 创建并设置全局变量，设置变量的维度和初值</p>
<img src="/2021/06/15/4-Tutorials/dSPACE/dSPACE-05/dSPACE%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%88%9D%E7%BA%A7%E7%AF%87/Untitled17.png" class title="Untitled">
</li>
<li><p><strong>Step 2 调用 -</strong>  在Matlab Function中通过<code>global</code>调用全局变量，并在<strong>Port and Data Manger</strong>中进行声明</p>
<img src="/2021/06/15/4-Tutorials/dSPACE/dSPACE-05/dSPACE%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%88%9D%E7%BA%A7%E7%AF%87/Untitled18.png" class title="Untitled">
</li>
<li><p><strong>Step 3 检查 -</strong>  正确调用后，寄存器模块内会列出所有调用该变量的模块</p>
<img src="/2021/06/15/4-Tutorials/dSPACE/dSPACE-05/dSPACE%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%88%9D%E7%BA%A7%E7%AF%87/Untitled19.png" class title="Untitled"></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>tutorials</category>
      </categories>
      <tags>
        <tag>dSPACE</tag>
      </tags>
  </entry>
  <entry>
    <title>MicroLabBox教程 6 - dSPACE程序设计 中级篇</title>
    <url>/2021/06/16/4-Tutorials/dSPACE/dSPACE-06/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E4%B8%AD%E7%BA%A7%E7%AF%87/</url>
    <content><![CDATA[<p>本篇介绍使用Simulink进行dSPACE程序设计的技巧，涉及向量、矩阵的使用，以及定时器与中断；</p>
<span id="more"></span>
<h2 id="1-MUX"><a href="#1-MUX" class="headerlink" title="1 - MUX"></a>1 - MUX</h2><ul>
<li>使用Matlab Function进行向量合成，<strong>不要使用Mux</strong>，其输出无法识别</li>
</ul>
<hr>
<h2 id="2-通过索引使用不定长数组"><a href="#2-通过索引使用不定长数组" class="headerlink" title="2 - 通过索引使用不定长数组"></a>2 - 通过索引使用不定长数组</h2><blockquote>
<p>点击按钮后，接下来N秒内，RGB模块每秒显示一种红绿之间的随机颜色，其中N为可调参数(1-10)，N种随机颜色在按钮触发时被完全定义；</p>
</blockquote>
<img src="/2021/06/16/4-Tutorials/dSPACE/dSPACE-06/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E4%B8%AD%E7%BA%A7%E7%AF%87/Untitled.png" class title="Untitled">
<p>💡 Simulink的Matlab Function不支持创建可变长度数组，可以创建固定长度数组，再通过索引调用；</p>
<hr>
<h2 id="3-数组越界与计算超时"><a href="#3-数组越界与计算超时" class="headerlink" title="3 - 数组越界与计算超时"></a>3 - 数组越界与计算超时</h2><ul>
<li>进行数组索引时，元素不可越界，否则dSPACE直接宕机；（重启机器+重启ControlDesk）</li>
<li><p>当单个计算周期的计算耗时超过采样时间，ControlDesk会卡住；（重新开始测量）</p>
<ul>
<li><p>可通过Task Info → turnaroundTime 查看dSPACE的计算耗时，并改进算法效率；</p>
  <img src="/2021/06/16/4-Tutorials/dSPACE/dSPACE-06/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E4%B8%AD%E7%BA%A7%E7%AF%87/1.png" class title="Untitled">
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="4-定时器与定时中断"><a href="#4-定时器与定时中断" class="headerlink" title="4 - 定时器与定时中断"></a>4 - 定时器与定时中断</h2><blockquote>
<p>在多数的嵌入式系统中，往往存在多个不同运行频率的程序段；以控制系统为例，包含观测器和控制器两部分，观测器的执行频率一般高于控制器，以保障在控制计算之前系统当前的状态信息得到有效估计。</p>
</blockquote>
<ul>
<li><p><strong>Step 1 -</strong> 使用dSPACE的Timer Interrupt作为定时中断触发，并配置定时间隔</p>
  <img src="/2021/06/16/4-Tutorials/dSPACE/dSPACE-06/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E4%B8%AD%E7%BA%A7%E7%AF%87/2.png" class>
</li>
<li><p><strong>Step 2 -</strong> 在定时执行模块中添加触发连接，并将触发配置为function call</p>
  <img src="/2021/06/16/4-Tutorials/dSPACE/dSPACE-06/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E4%B8%AD%E7%BA%A7%E7%AF%87/3.png" class title="Untitled">
</li>
<li><p><strong>Step - 3</strong> 在不同执行速度的模块之间添加缓冲器，并取消勾选Ensure deterministic data transfer，以实异步通信</p>
  <img src="/2021/06/16/4-Tutorials/dSPACE/dSPACE-06/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E4%B8%AD%E7%BA%A7%E7%AF%87/4.png" class title="Untitled">
</li>
<li><p><strong>Step - 4</strong> 对于含有全局变量的情况，在模型配置中将Multi data store选项设置为none</p>
  <img src="/2021/06/16/4-Tutorials/dSPACE/dSPACE-06/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E4%B8%AD%E7%BA%A7%E7%AF%87/5.png" class title="Untitled">
</li>
<li><p><strong>Step - 5</strong> 配置定时器的中断优先级</p>
  <img src="/2021/06/16/4-Tutorials/dSPACE/dSPACE-06/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E4%B8%AD%E7%BA%A7%E7%AF%87/6.png" class title="Untitled">
</li>
</ul>
<p>⭐ <strong>dSPACE中Simulink模型的执行过程（3）</strong></p>
<ul>
<li><p>dSPACE使用独立的定时器去运行该定时器下的模块和程序，其中TimerA被用来执行基础定时程序；</p>
</li>
<li><p>每个<strong>定时模块</strong>/<strong>中断模块</strong>可以看作是一个独立的线程，线程之间需要缓冲器（消息队列，FIFO）来实现数据的传递；</p>
</li>
</ul>
<hr>
<h2 id="5-硬件中断"><a href="#5-硬件中断" class="headerlink" title="5 - 硬件中断"></a>5 - 硬件中断</h2><p><a href="https://www.qqxiuzi.cn/bianma/ascii.htm">ASCII编码转换，ASCII码在线查询工具</a></p>
<blockquote>
<p>实现功能：使用串口接收中断，在每次接受到串口数据时，向上位机发送‘Hello’</p>
</blockquote>
<ul>
<li>使用串口接收中断和模块，并搭建中断执行模块</li>
</ul>
<img src="/2021/06/16/4-Tutorials/dSPACE/dSPACE-06/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E4%B8%AD%E7%BA%A7%E7%AF%87/image-20211124175203609.png" class title="image-20211124175203609">
<hr>
<h2 id="6-异步通信"><a href="#6-异步通信" class="headerlink" title="6 - 异步通信"></a>6 - 异步通信</h2><blockquote>
<p>实现功能：在每次接受到串口数据时，RGB红灯闪烁三秒</p>
</blockquote>
<img src="/2021/06/16/4-Tutorials/dSPACE/dSPACE-06/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E4%B8%AD%E7%BA%A7%E7%AF%87/image-20211124175242419.png" class title="image-20211124175242419">
<p>💡在进行异步通信时，不同线程之间的缓冲器会使得信号被降采样，因此在异步通信中传递触发信号时，确保信号能够被正确传递；</p>
<h2 id="7-中断优先级"><a href="#7-中断优先级" class="headerlink" title="7 - 中断优先级"></a>7 - 中断优先级</h2><img src="/2021/06/16/4-Tutorials/dSPACE/dSPACE-06/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E4%B8%AD%E7%BA%A7%E7%AF%87/image-20211124175323799.png" class title="image-20211124175323799">
<p>⭐ <strong>dSPACE中Simulink模型的执行过程（4）</strong></p>
<blockquote>
<p>当dSPACE运行低优先级的中断处理函数（线程）时，当有高优先级的中断触发，则dSPACE会暂停当前任务，转去处理高优先级的任务，处理玩之后在返回继续执行之前的任务</p>
</blockquote>
<hr>
<h2 id="8-Host-Service"><a href="#8-Host-Service" class="headerlink" title="8 - Host Service"></a>8 - Host Service</h2><blockquote>
<p>通过Host Service指定上位机数据采集、显示和记录的频率，以满足特定的需求；<br>尽量避免在一个模型中配置多个Host Service，可能会导致数据采集紊乱；</p>
</blockquote>
<img src="/2021/06/16/4-Tutorials/dSPACE/dSPACE-06/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E4%B8%AD%E7%BA%A7%E7%AF%87/13.png" class title="Untitled">
<img src="/2021/06/16/4-Tutorials/dSPACE/dSPACE-06/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E4%B8%AD%E7%BA%A7%E7%AF%87/14.png" class title="Untitled">]]></content>
      <categories>
        <category>tutorials</category>
      </categories>
      <tags>
        <tag>dSPACE</tag>
      </tags>
  </entry>
  <entry>
    <title>MicroLabBox教程 7 - dSPACE程序设计 高级篇</title>
    <url>/2021/06/17/4-Tutorials/dSPACE/dSPACE-07/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/</url>
    <content><![CDATA[<p>本篇以NKAEX-MINI为例，介绍控制系统程序设计的基本方法</p>
<span id="more"></span>
<h2 id="程序整体框架"><a href="#程序整体框架" class="headerlink" title="程序整体框架"></a>程序整体框架</h2><p><strong>整体结构</strong></p>
<img src="/2021/06/17/4-Tutorials/dSPACE/dSPACE-07/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/Snipaste_2021-11-11_22-29-52.png" class title="Snipaste_2021-11-11_22-29-52.png">
<p><strong>传感器模组</strong></p>
<img src="/2021/06/17/4-Tutorials/dSPACE/dSPACE-07/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/Snipaste_2021-11-11_22-30-16.png" class title="Snipaste_2021-11-11_22-30-16.png">
<p><strong>控制器结构: 状态机 - 高层控制器 - 底层控制器 - 驱动器输出</strong></p>
<img src="/2021/06/17/4-Tutorials/dSPACE/dSPACE-07/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/Snipaste_2021-11-11_22-31-18.png" class title="Snipaste_2021-11-11_22-31-18.png">
<hr>
<h2 id="传感器模块与电机输出"><a href="#传感器模块与电机输出" class="headerlink" title="传感器模块与电机输出"></a>传感器模块与电机输出</h2><img src="/2021/06/17/4-Tutorials/dSPACE/dSPACE-07/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/Snipaste_2021-11-11_22-30-16.png" class title="Snipaste_2021-11-11_22-30-16.png">
<h3 id="拉力传感器与惠斯通电桥"><a href="#拉力传感器与惠斯通电桥" class="headerlink" title="拉力传感器与惠斯通电桥"></a>拉力传感器与惠斯通电桥</h3><img src="/2021/06/17/4-Tutorials/dSPACE/dSPACE-07/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/image-20211124181203343.png" class title="image-20211124181203343">
<h3 id="电机控制信号与电机控制软件"><a href="#电机控制信号与电机控制软件" class="headerlink" title="电机控制信号与电机控制软件"></a>电机控制信号与电机控制软件</h3><ul>
<li>控制模式每次需要配置为模拟量，启动控制前需要监控输入的模拟量是否在安全范围内</li>
</ul>
<img src="/2021/06/17/4-Tutorials/dSPACE/dSPACE-07/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/Snipaste_2021-11-12_14-01-29.png" class title="Snipaste_2021-11-12_14-01-29.png">
<ul>
<li>配置操作模式，设置速度模式、模拟量控制，配置最大速度（仅需配置一次）</li>
</ul>
<img src="/2021/06/17/4-Tutorials/dSPACE/dSPACE-07/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/image-20211124183228134.png" class title="image-20211124183228134">
<ul>
<li>调节模拟量增益（仅一次），和偏置（每次上电均需校准）；整定电机参数（每个月校准一次）</li>
</ul>
<img src="/2021/06/17/4-Tutorials/dSPACE/dSPACE-07/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/image-20211124183335223.png" class title="image-20211124183335223">
<blockquote>
<p>在每次实验之前，需要对模拟量信号的偏移进行调整<br>若需要进行参数整定，确保电机没有负载</p>
</blockquote>
<h3 id="肌电传感器的信号滤波"><a href="#肌电传感器的信号滤波" class="headerlink" title="肌电传感器的信号滤波"></a>肌电传感器的信号滤波</h3><img src="/2021/06/17/4-Tutorials/dSPACE/dSPACE-07/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/Untitled_9.png" class title="Untitled">
<p><strong>传感器连线</strong></p>
<img src="/2021/06/17/4-Tutorials/dSPACE/dSPACE-07/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/image-20211124181607135.png" class title="image-20211124181607135">
<p><strong>外骨骼传感信号转接板</strong></p>
<img src="/2021/06/17/4-Tutorials/dSPACE/dSPACE-07/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/image-20211124181708169.png" class title="image-20211124181708169">
<p><strong>电机编码器信号转接板</strong></p>
<img src="/2021/06/17/4-Tutorials/dSPACE/dSPACE-07/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/Untitled_12.png" class title="Untitled">
<hr>
<h2 id="步态状态机"><a href="#步态状态机" class="headerlink" title="步态状态机"></a>步态状态机</h2><blockquote>
<p>指定系统的工作状态，划分步态支撑相与摆动相，进行异常监测</p>
<ul>
<li>Mode → 系统工作状态</li>
<li>State  → 步态支撑/摆动相状态</li>
</ul>
</blockquote>
<img src="/2021/06/17/4-Tutorials/dSPACE/dSPACE-07/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/Untitled_13.png" class title="Untitled">
<hr>
<h2 id="High-Level-Controller"><a href="#High-Level-Controller" class="headerlink" title="High Level Controller"></a>High Level Controller</h2><blockquote>
<p>根据系统状态规划电机的工作模式，生成期望力矩曲线，并向输出Low Lever控制器发送期望速度、期望位置或期望力矩；</p>
</blockquote>
<img src="/2021/06/17/4-Tutorials/dSPACE/dSPACE-07/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/Untitled_14.png" class title="Untitled">
<ul>
<li>期望力矩曲线</li>
</ul>
<img src="/2021/06/17/4-Tutorials/dSPACE/dSPACE-07/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/Untitled_15.png" class title="Untitled">
<ul>
<li>期望关节角度</li>
</ul>
<script type="math/tex; mode=display">\theta_{des,motor}=R\cdot\theta_{exo}-\theta_{margin}</script>]]></content>
      <categories>
        <category>tutorials</category>
      </categories>
      <tags>
        <tag>dSPACE</tag>
      </tags>
  </entry>
  <entry>
    <title>MicroLabBox教程 3 - dSPACE硬件接口 中级篇</title>
    <url>/2021/06/13/4-Tutorials/dSPACE/dSPACE-03/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E4%B8%AD%E7%BA%A7%E7%AF%87/</url>
    <content><![CDATA[<p>本篇主要介绍dSPACE的复杂硬件输入接口，包括正交编码器、串口、CAN总线、UDP。</p>
<span id="more"></span>
<h3 id="正交编码器输入"><a href="#正交编码器输入" class="headerlink" title="正交编码器输入"></a>正交编码器输入</h3><p><a href="https://zhuanlan.zhihu.com/p/350368518">编码器计数原理与电机测速原理—多图解析</a></p>
<img src="/2021/06/13/4-Tutorials/dSPACE/dSPACE-03/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E4%B8%AD%E7%BA%A7%E7%AF%87/Snipaste_2021-11-01_23-24-15.png" class title="Snipaste_2021-11-01_23-24-15.png">
<img src="/2021/06/13/4-Tutorials/dSPACE/dSPACE-03/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E4%B8%AD%E7%BA%A7%E7%AF%87/image-20211124170638327.png" class title="image-20211124170638327">
<p>💡 Tips</p>
<ul>
<li>dSPACE内用于接受正交编码器信号的解码器仅有6个，即最多能同时采集6路正交编码器信号；</li>
<li>可设置使用DIO1或DIO2连接编码器信号线，其中DIO2必须需要互补信号输入，用于保证强电磁干扰下的信号可靠性；</li>
<li>可在参数界面设置是否使用Z相信号输入，三根信号线必须以ABZ的顺序接入连续的3个dSPACE数字量引脚，仅首引脚号可设置；</li>
<li>编码器的测量模式可在角度模式和位置模式之间选择，角度模式下输出角度，位置模式下输出线数；</li>
</ul>
<hr>
<h2 id="RS-232-485串口"><a href="#RS-232-485串口" class="headerlink" title="RS-232/485串口"></a>RS-232/485串口</h2><p><a href="https://zhuanlan.zhihu.com/p/96506127">USART-串口通信</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/25893717">UART、RS232、TTL关系浅析</a></p>
<img src="/2021/06/13/4-Tutorials/dSPACE/dSPACE-03/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E4%B8%AD%E7%BA%A7%E7%AF%87/image-20211124170823354.png" class title="image-20211124170823354">
<img src="/2021/06/13/4-Tutorials/dSPACE/dSPACE-03/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E4%B8%AD%E7%BA%A7%E7%AF%87/Snipaste_2021-11-03_11-05-09.png" class title="Snipaste_2021-11-03_11-05-09.png">
<img src="/2021/06/13/4-Tutorials/dSPACE/dSPACE-03/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E4%B8%AD%E7%BA%A7%E7%AF%87/image-20211124170935214.png" class title="image-20211124170935214">
<img src="/2021/06/13/4-Tutorials/dSPACE/dSPACE-03/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E4%B8%AD%E7%BA%A7%E7%AF%87/image-20211124170949481.png" class title="image-20211124170949481">
<blockquote>
<p>使用时请注意接口的线序</p>
</blockquote>
<img src="/2021/06/13/4-Tutorials/dSPACE/dSPACE-03/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E4%B8%AD%E7%BA%A7%E7%AF%87/image-20211124171028615.png" class title="image-20211124171028615">
<hr>
<h3 id="CAN总线通信"><a href="#CAN总线通信" class="headerlink" title="CAN总线通信"></a>CAN总线通信</h3><p><a href="https://zhuanlan.zhihu.com/p/162708070#:~:text=CAN%E6%80%BB%E7%BA%BF%E6%98%AF%E4%B8%80%E7%A7%8D%E7%94%A8%E4%BA%8E%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%9A%84ECU%EF%BC%88%E7%94%B5%E5%AD%90%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%EF%BC%89%E4%B9%8B%E9%97%B4%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BA%BF%EF%BC%8CCAN%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%B8%80%E7%A7%8DISO%20%E5%9B%BD%E9%99%85%E6%A0%87%E5%87%86%E5%8C%96%E7%9A%84%E4%B8%B2%E8%A1%8C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%EF%BC%8C%E6%9C%89,ISO-11898%20%E5%92%8C%20ISO-11519%E4%B8%A4%E4%B8%AA%E7%B3%BB%E5%88%97%E3%80%82">一篇易懂的CAN通讯协议指南1</a></p>
<img src="/2021/06/13/4-Tutorials/dSPACE/dSPACE-03/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E4%B8%AD%E7%BA%A7%E7%AF%87/image-20211124171133316.png" class title="image-20211124171133316">
<p><strong>以DJI的M3508的电调C620为例，介绍如何使用dSPACE进行CAN总线数据通信</strong></p>
<ul>
<li>阅读文档，获取设备CAN总线通信的相关信息，包括：CAN总线通信速度、设备标志符(ID)、帧类型、帧格式、发送/接受报文格式和数据含义</li>
</ul>
<img src="/2021/06/13/4-Tutorials/dSPACE/dSPACE-03/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E4%B8%AD%E7%BA%A7%E7%AF%87/image-20211124171225993.png" class title="image-20211124171225993">
<ul>
<li>使用dSPACE的CAN总线模块</li>
</ul>

<img src="/2021/06/13/4-Tutorials/dSPACE/dSPACE-03/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E4%B8%AD%E7%BA%A7%E7%AF%87/image-20211124171256939.png" class title="image-20211124171256939">
<hr>
<h2 id="Ethernet-UDP通信"><a href="#Ethernet-UDP通信" class="headerlink" title="Ethernet UDP通信"></a>Ethernet UDP通信</h2><ul>
<li>基础概念 - IP地址，端口</li>
</ul>
<img src="/2021/06/13/4-Tutorials/dSPACE/dSPACE-03/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E4%B8%AD%E7%BA%A7%E7%AF%87/image-20211124171426517.png" class title="image-20211124171426517">
<ul>
<li>配置通信参数</li>
</ul>
<img src="/2021/06/13/4-Tutorials/dSPACE/dSPACE-03/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E4%B8%AD%E7%BA%A7%E7%AF%87/Snipaste_2021-11-04_10-21-58.png" class title="Snipaste_2021-11-04_10-21-58.png">
<img src="/2021/06/13/4-Tutorials/dSPACE/dSPACE-03/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E4%B8%AD%E7%BA%A7%E7%AF%87/image-20211124171742608.png" class title="image-20211124171742608">
<ul>
<li>按通信协议对发送数据进行打包、对接受数据进行解码</li>
</ul>
<img src="/2021/06/13/4-Tutorials/dSPACE/dSPACE-03/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E4%B8%AD%E7%BA%A7%E7%AF%87/Snipaste_2021-11-04_12-13-20.png" class title="Snipaste_2021-11-04_12-13-20.png">

<p>💡 使用帮助文档<br>对于dSAPCE提供的Simulink模块，右键Help打开dSPACE Help界面，可查看该模块的具体使用方法；</p>
]]></content>
      <categories>
        <category>tutorials</category>
      </categories>
      <tags>
        <tag>dSPACE</tag>
      </tags>
  </entry>
</search>
