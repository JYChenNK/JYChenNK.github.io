<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>OpenSim源码安装</title>
    <url>/2021/06/01/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<p>Windows环境下OpenSim源码安装记录</p>
<img src="/2021/06/01/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/Snipaste_2021-11-11_22-29-52-7844452.png" class title="Snipaste_2021-11-11_22-29-52">
<span id="more"></span>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://github.com/opensim-org/opensim-core#for-the-impatient-windows">官方文档</a></li>
<li><a href="https://blog.csdn.net/lrm15659833890/article/details/88576891">中文博客</a></li>
<li><a href="https://blog.csdn.net/wopt00/article/details/91430023">中文博客2</a></li>
</ul>
<h2 id="Step1-安装依赖软件"><a href="#Step1-安装依赖软件" class="headerlink" title="Step1 安装依赖软件"></a>Step1 安装依赖软件</h2><ul>
<li><p>安装VS2015或VS2017</p>
<ul>
<li>VS2017的安装选项<img src="/2021/06/01/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/1586142260410.png" class>
<img src="/2021/06/01/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/1586142274169.png" class>
<img src="/2021/06/01/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/1586142312200.png" class>
</li>
</ul>
</li>
<li><p>安装<a href="https://git-scm.com/downloads">git</a></p>
</li>
<li>安装<a href="https://cmake.org/download/">cmake</a></li>
<li>安装<a href="https://chocolatey.org/">chocolatey</a></li>
<li>以管理员打开<strong>PowerShell</strong>，运行一下代码（本步骤需科学上网）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">choco install python2 jdk8 swig</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Step2-编译依赖项"><a href="#Step2-编译依赖项" class="headerlink" title="Step2 编译依赖项"></a>Step2 编译依赖项</h2><ul>
<li>打开<strong>PowerShell</strong>，且切换至合适路径，下载源码<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;opensim-org&#x2F;opensim-core.git</span><br></pre></td></tr></table></figure></li>
<li>新建编译文件夹，并进入<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir opensim_dependencies_build</span><br><span class="line">cd .\opensim_dependencies_build</span><br></pre></td></tr></table></figure></li>
<li>生成编译配置文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmake ..\opensim-core\dependencies -G&quot;Visual Studio 15 2017 Win64&quot; -DCMAKE_INSTALL_PREFIX&#x3D;&quot;..\opensim_dependencies_install&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>对于VS2015，输入以下指令</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmake ..\opensim-core\dependencies -G&quot;Visual Studio 14 2015 Win64&quot; -DCMAKE_INSTALL_PREFIX&#x3D;&quot;..\opensim_dependencies_install&quot;</span><br></pre></td></tr></table></figure>
<img src="/2021/06/01/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/1586143165609.png" class>
<ul>
<li>开始编译依赖项（包括Simbody 、Biomechanical-ToolKit Core、docopt.cpp等）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmake --build . --config RelWithDebInfo -- &#x2F;maxcpucount:8</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>这一步可能会出现如下错误</p>
</blockquote>
<img src="/2021/06/01/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/1592020228095.png" class>
<blockquote>
<p>这个错误是由于源码中的部分文件含有中文系统无法识别的字符，打开查看如下文件</p>
</blockquote>
<img src="/2021/06/01/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/1592020209417.png" class>
<blockquote>
<p>所有和加速度有关的符合都有乱码。在不改系统语言的情况下，可以将文件中的乱码删除，重新编译即可</p>
</blockquote>
<img src="/2021/06/01/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/1592020274065.png" class>
<h2 id="Step3-编译源码"><a href="#Step3-编译源码" class="headerlink" title="Step3 编译源码"></a>Step3 编译源码</h2><ul>
<li>移动路径，并新建源码编译文件夹<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ..</span><br><span class="line">mkdir opensim_build</span><br><span class="line">cd .\opensim_build</span><br></pre></td></tr></table></figure></li>
<li>编译配置<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmake ..\opensim-core -G&quot;Visual Studio 15 2017 Win64&quot; -DCMAKE_INSTALL_PREFIX&#x3D;&quot;..\opensim_install&quot; -DOPENSIM_DEPENDENCIES_DIR&#x3D;&quot;..\opensim_dependencies_install&quot; -DBUILD_JAVA_WRAPPING&#x3D;ON -DBUILD_PYTHON_WRAPPING&#x3D;ON -DWITH_BTK&#x3D;ON</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>出现错误</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Could NOT find PythonInterp: Found unsuitable version &quot;2.7.17&quot;, but</span><br><span class="line">  required is at least &quot;3&quot; (found C:&#x2F;Python27&#x2F;python.exe)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>貌似对Python版本的要求不一样了，再装一下Python3，并写在Python2</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">choco install python3</span><br><span class="line">choco uninstall python2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>重新配置</p>
</blockquote>
<p>4.OpenSim源码编译<img src="/2021/06/01/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/1586144793154.png" alt></p>
<ul>
<li>开始编译 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmake --build . --config RelWithDebInfo -- &#x2F;maxcpucount:8</span><br></pre></td></tr></table></figure>
<blockquote>
<p>又出现错误</p>
<img src="/2021/06/01/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/1586147266768.png" class>
</blockquote>
</li>
</ul>
<blockquote>
<p>看起来是Java的问题，发现swig版本为4.0.1，要求是3.0.8以上，因此重装swig3.0.8版本</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">choco install swig --version 3.0.8 --force</span><br></pre></td></tr></table></figure>
<blockquote>
<p>删除<code>opensim_build</code>文件夹内容后，重新配置并编译，通过（耗时较长）</p>
</blockquote>
<img src="/2021/06/01/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/1586158357360.png" class>
<ul>
<li>进行测试<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ctest --build-config RelWithDebInfo --parallel 8</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>Matlab部分的是没问题，Python好像有点问题，暂时不用Python，不管它</p>
</blockquote>
<img src="/2021/06/01/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/1586158893776.png" class>
<ul>
<li>安装到指定文件夹<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmake --build . --config RelWithDebInfo --target install -- &#x2F;maxcpucount:8</span><br></pre></td></tr></table></figure>
<img src="/2021/06/01/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/1586159090955.png" class>
</li>
</ul>
<blockquote>
<p>安装完成</p>
</blockquote>
<h2 id="Step4-添加环境变量"><a href="#Step4-添加环境变量" class="headerlink" title="Step4 添加环境变量"></a>Step4 添加环境变量</h2><ul>
<li>将<code>&lt;FULL-DIR&gt;\opensim_install\bin</code>路径添加到系统的全局变量<img src="/2021/06/01/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/1586159421732.png" class>
<img src="/2021/06/01/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/1586159461057.png" class>
<img src="/2021/06/01/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/1586159495841.png" class>
<img src="/2021/06/01/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/1586159953211.png" class>
<img src="/2021/06/01/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/1586160055552.png" class>
</li>
</ul>
<h2 id="Step5-配置Matlab"><a href="#Step5-配置Matlab" class="headerlink" title="Step5 配置Matlab"></a>Step5 配置Matlab</h2><p>在Matlab运行如下文件配置OpenSim，之后重新打开Matlab即可调用OpenSim接口<br><img src="/2021/06/01/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/1592216470893.png" class></p>
<h2 id="Step6-简单测试"><a href="#Step6-简单测试" class="headerlink" title="Step6 简单测试"></a>Step6 简单测试</h2><ul>
<li><p>测试MATLAB调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.opensim.modeling.*;</span><br><span class="line">model &#x3D; Model();</span><br></pre></td></tr></table></figure>
<img src="/2021/06/01/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/1586160641438.png" class>
</li>
<li><p>测试示例程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">opensim_install\Resources\Code\Matlab\Dynamic_Walker_Challenge\DesignMainStarter.m</span><br></pre></td></tr></table></figure>
<img src="/2021/06/01/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/4.OpenSim%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/1586160796721.png" class>
</li>
</ul>
]]></content>
      <categories>
        <category>tutorials</category>
      </categories>
      <tags>
        <tag>OpenSim</tag>
      </tags>
  </entry>
  <entry>
    <title>102Lab数据处理软件AIOS</title>
    <url>/2021/10/04/2.AIOS/AIOS/</url>
    <content><![CDATA[<img src="/2021/10/04/2.AIOS/AIOS/fig1.png" class>
<h2 id="最新版本-v6-13"><a href="#最新版本-v6-13" class="headerlink" title="最新版本 v6.13"></a>最新版本 v6.13</h2><span id="more"></span>
<p><a href="https://github.com/JYChenNK/102DAS/releases">下载链接(GitHub)</a>，拖动到Matlab命令行窗口中即可安装</p>
<h2 id="更新说明"><a href="#更新说明" class="headerlink" title="更新说明"></a>更新说明</h2><h3 id="v6-10"><a href="#v6-10" class="headerlink" title="v6.10"></a>v6.10</h3><ul>
<li>优化界面配色</li>
<li>新增可视化绘图配色</li>
<li>新增数据处理模式（速度/精度）</li>
<li>新增绘图敞口大小设置</li>
</ul>
<img src="/2021/10/04/2.AIOS/AIOS/%E5%9B%BE%E7%89%871.png" class>
<h3 id="v6-8"><a href="#v6-8" class="headerlink" title="v6.8"></a>v6.8</h3><ul>
<li>增加Std特征用于分析稳定性</li>
<li>增加绘制足底压力曲线</li>
<li>增加绘制频响曲线</li>
<li>增加绘制阶跃曲线</li>
</ul>
<h3 id><a href="#" class="headerlink" title></a></h3><h3 id="v6-5"><a href="#v6-5" class="headerlink" title="v6.5"></a>v6.5</h3><ul>
<li>调整步态分割的最小步数</li>
<li>支持一键保存fig，png，eps</li>
<li>修复步态分割Bug</li>
<li>调整每步数据点个数为101</li>
</ul>
<h3 id="v6-4"><a href="#v6-4" class="headerlink" title="v6.4"></a>v6.4</h3><ul>
<li>新增功能：实验数据切分、合并，支持数据多选</li>
<li>新增功能：变量归一化、基线去除</li>
<li>新增功能：Group Plot</li>
<li>增加系统背景配色</li>
<li>优化功能按键分布</li>
</ul>

<h3 id="v5-6"><a href="#v5-6" class="headerlink" title="v5.6"></a>v5.6</h3><ul>
<li>支持一维、二维特征插值与拟合</li>
<li>支持4种显著性分析（T-test、Anova、Mann-Whhitney-Wilcoxon、Kruskal-Wallis）<img src="/2021/10/04/2.AIOS/AIOS/fig1.png" class>
<img src="/2021/10/04/2.AIOS/AIOS/fig2.png" class>
</li>
</ul>
<h3 id="v5-1"><a href="#v5-1" class="headerlink" title="v5.1"></a>v5.1</h3><ul>
<li>优化显示界面</li>
<li>增加过渡动画</li>
<li>增加更多曲线线型设置</li>
<li>优化色彩排序</li>
<li><p>修复单组柱状图绘制BUG</p>
<img src="/2021/10/04/2.AIOS/AIOS/demo2.gif" class>
</li>
</ul>
<h3 id="v4-12"><a href="#v4-12" class="headerlink" title="v4.12"></a>v4.12</h3><ul>
<li>支持绘制SubPlot：选择子图数目，点击<code>NEW SubPlot</code>创建子图；选择子图行、列序号，点击<code>SELECT Sub</code>选中子图进行绘制</li>
</ul>
<img src="/2021/10/04/2.AIOS/AIOS/demo1.gif" class>
<h3 id="v4-10"><a href="#v4-10" class="headerlink" title="v4.10"></a>v4.10</h3><ul>
<li>增加对双侧外骨骼的实验数据支持。确保数据中包含变量”state_r”和”state_l”；所有变量名中包含”_r”/“_R”的变量将作为右侧数据进行步态分割；所有变量名中包含”_l”/“_L”的变量将作为右侧数据进行步态分割；其他数据作为右侧数据进行步态分割。</li>
</ul>
<h3 id="v4-9"><a href="#v4-9" class="headerlink" title="v4.9"></a>v4.9</h3><ul>
<li>修复不同分辨率下的显示问题</li>
</ul>
<h3 id="v4-8"><a href="#v4-8" class="headerlink" title="v4.8"></a>v4.8</h3><ul>
<li>重新加入Scone的GRF &amp; Kine数据提取（LOAD界面）</li>
<li>支持Group Bar的误差线绘制（Broup Bar界面）</li>
<li>支持Bar和Group Bar的即时是数据导出（COMP &amp; Broup Bar界面）</li>
<li>支持数据中部分Step的删除，用于剔除错误的Step（LOAD界面）</li>
</ul>
<h3 id="v4-0"><a href="#v4-0" class="headerlink" title="v4.0"></a>v4.0</h3><ul>
<li>优化配色系统，加入othercolor</li>
<li>支持绘制步态变化曲线</li>
<li>支持相图绘制（关节角vs关节力矩）</li>
<li>支持绘制曲线对比与特征柱状图</li>
<li>支持绘制GroupBar（肌电特征）</li>
</ul>
<h3 id="v3-0"><a href="#v3-0" class="headerlink" title="v3.0"></a>v3.0</h3><ul>
<li>全面优化代码结构，降低复杂度</li>
</ul>
<h3 id="v2-0"><a href="#v2-0" class="headerlink" title="v2.0"></a>v2.0</h3><ul>
<li>支持导入Scone数据</li>
<li>支持导入PredSim数据</li>
<li>支持导入OpenSim数据（需配和步态分割信号进行数据处理）</li>
</ul>
<h3 id="V1-0"><a href="#V1-0" class="headerlink" title="V1.0"></a>V1.0</h3><p>基于Matlab App Designer设计了一款实验室数据分析软件AIOS</p>
<img src="/2021/10/04/2.AIOS/AIOS/1.png" class title="主界面">
<img src="/2021/10/04/2.AIOS/AIOS/2.png" class title="数据加载界面">
<img src="/2021/10/04/2.AIOS/AIOS/3.png" class title="绘图界面">
<hr>
<hr>
<h4 id="软件使用介绍"><a href="#软件使用介绍" class="headerlink" title="软件使用介绍"></a>软件使用介绍</h4><h5 id="打开软件"><a href="#打开软件" class="headerlink" title="打开软件"></a>打开软件</h5><p>有两种方式打开AIOS，第一种通过Matlab APP打开，启动速度较快；第二种通过exe文件直接打开，无需依赖。</p>
<p>通过Matlab APP打开：<br><img src="/2021/10/04/2.AIOS/AIOS/4.gif" class><br>通过exe文件打开：<br><img src="/2021/10/04/2.AIOS/AIOS/5.gif" class></p>
<h4 id="加载数据"><a href="#加载数据" class="headerlink" title="加载数据"></a>加载数据</h4><h5 id="导入实验文件"><a href="#导入实验文件" class="headerlink" title="导入实验文件"></a>导入实验文件</h5><p>软件可导入由dSPACE ControlDesk采集得到的数据，并支持多个数据文件的导入与分析：</p>
<img src="/2021/10/04/2.AIOS/AIOS/6.gif" class>
<h5 id="提取数据变量并处理"><a href="#提取数据变量并处理" class="headerlink" title="提取数据变量并处理"></a>提取数据变量并处理</h5><p>从原始数据中提取有用数据变量进行分析</p>
<ul>
<li>支持变量重命名</li>
<li>支持数据一键处理（处理详情待补充），需先提取state变量</li>
<li>支持数据保存</li>
</ul>
<img src="/2021/10/04/2.AIOS/AIOS/7.gif" class>
<h4 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h4><h5 id="绘制时间序列曲线"><a href="#绘制时间序列曲线" class="headerlink" title="绘制时间序列曲线"></a>绘制时间序列曲线</h5><ul>
<li>在新建Figure窗口中绘图，方便图像缩放、保存和进一步处理</li>
<li>支持多曲线绘制与窗口清空</li>
</ul>
<img src="/2021/10/04/2.AIOS/AIOS/8.gif" class>
<img src="/2021/10/04/2.AIOS/AIOS/9.gif" class>
<h5 id="绘制步态周期曲线"><a href="#绘制步态周期曲线" class="headerlink" title="绘制步态周期曲线"></a>绘制步态周期曲线</h5><ul>
<li>支持步态周期逐条曲线、平均曲线、方差区域的绘制</li>
<li>支持多曲线绘制与颜色设置</li>
</ul>
<img src="/2021/10/04/2.AIOS/AIOS/10.gif" class>
<img src="/2021/10/04/2.AIOS/AIOS/11.gif" class>
<h5 id="绘制步态特征柱状图"><a href="#绘制步态特征柱状图" class="headerlink" title="绘制步态特征柱状图"></a>绘制步态特征柱状图</h5><ul>
<li>支持柱状图数据导入与删除</li>
<li>支持步态特征选择（rms、mean、max、min）</li>
<li>支持bar与error bar切换</li>
<li>支持colormap设置</li>
</ul>
<img src="/2021/10/04/2.AIOS/AIOS/12.gif" class>
<hr>
<h2 id="历史版本"><a href="#历史版本" class="headerlink" title="历史版本"></a>历史版本</h2><ul>
<li><a href="/download/AIOS_v1.0.mlappinstall">v1.0版本</a></li>
<li><a href="/download/AIOS_v4.6.mlappinstall">v4.6版本</a></li>
<li><a href="/download/AIOS_v4.8.mlappinstall">v4.8版本</a></li>
<li><a href="/download/AIOS_v4.9.mlappinstall">v4.9版本</a></li>
<li><a href="/download/AIOS_v4.10.mlappinstall">v4.10版本</a></li>
<li><a href="/download/AIOS_v4.12.mlappinstall">v4.12版本</a></li>
<li><a href="/download/AIOS_v5.6.mlappinstall">v5.6版本</a></li>
<li><a href="/download/DPAS_for_102Lab.mlapp">v6.4版本</a></li>
<li><a href="/download/DPAS-102Lab_v6.5.mlappinstall">v6.5版本</a></li>
<li><a href="/download/DPAS-102Lab_v6.6.mlappinstall">v6.6版本</a></li>
<li><a href="/download/DPAS-102Lab_v6.10.mlappinstall">v6.10版本</a></li>
<li><a href="/download/DPAS-102Lab_v6.12.mlappinstall">v6.12版本</a></li>
</ul>
]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title>基于肌肉骨骼模型的预测仿真</title>
    <url>/2020/04/26/7.%E5%9F%BA%E4%BA%8E%E8%82%8C%E8%82%89%E9%AA%A8%E9%AA%BC%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%A2%84%E6%B5%8B%E4%BB%BF%E7%9C%9F/7.%E5%9F%BA%E4%BA%8E%E8%82%8C%E8%82%89%E9%AA%A8%E9%AA%BC%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%A2%84%E6%B5%8B%E4%BB%BF%E7%9C%9F/</url>
    <content><![CDATA[<img src="/2020/04/26/7.%E5%9F%BA%E4%BA%8E%E8%82%8C%E8%82%89%E9%AA%A8%E9%AA%BC%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%A2%84%E6%B5%8B%E4%BB%BF%E7%9C%9F/7.%E5%9F%BA%E4%BA%8E%E8%82%8C%E8%82%89%E9%AA%A8%E9%AA%BC%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%A2%84%E6%B5%8B%E4%BB%BF%E7%9C%9F/img001.png" class title="img001">
<span id="more"></span>
<h2 id="肌肉骨骼模型"><a href="#肌肉骨骼模型" class="headerlink" title="肌肉骨骼模型"></a>肌肉骨骼模型</h2><h3 id="骨骼的刚体动力学模型"><a href="#骨骼的刚体动力学模型" class="headerlink" title="骨骼的刚体动力学模型"></a>骨骼的刚体动力学模型</h3><img src="/2020/04/26/7.%E5%9F%BA%E4%BA%8E%E8%82%8C%E8%82%89%E9%AA%A8%E9%AA%BC%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%A2%84%E6%B5%8B%E4%BB%BF%E7%9C%9F/7.%E5%9F%BA%E4%BA%8E%E8%82%8C%E8%82%89%E9%AA%A8%E9%AA%BC%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%A2%84%E6%B5%8B%E4%BB%BF%E7%9C%9F/1587749146996.png" class>
<p>首先基于刚体动力学对于人体骨骼系统进行建模。首先确定系统的广义坐标$q$，对于图中所示的二维模型为例，广义坐标包含躯干的水平、数值方向位移和姿态角，以及每条腿三个关节角，一共$3+2*3=9$个自由度。之后通过这些广义变量和广义变量的导数，表示出系统的动能和势能，并构造拉格朗日函数：</p>
<script type="math/tex; mode=display">L=T-V</script><p>考虑骨骼系统仅收到地反力和肌肉力的作用，通过拉格朗日方程得到系统的动力学模型：</p>
<script type="math/tex; mode=display">\frac{\mathrm{d}}{\mathrm{d} t}\left(\frac{\partial L}{\partial \dot{q}_{j}}\right)-\frac{\partial L}{\partial q_{j}}=\tau^{j}_{contact}+\tau^{j}_{muscle}</script><script type="math/tex; mode=display">\mathbf{M}(\mathbf{q}) \cdot \ddot{\mathbf{q}}+\mathbf{B}(\mathbf{q}, \dot{\mathbf{q}})=\mathbf{J(q)}^T\mathbf{F}_{contact}+\mathbf{R(q)}\mathbf{F}_{muscle}</script><p>其中$\mathbf{M(q)}$为质量矩阵，$\mathbf{B}(\mathbf{q}, \dot{\mathbf{q}})$包含重力、离心力和科氏力，$\mathbf{J(q)}$表示雅克比矩阵，将地反力转化为对每个广义坐标的等效力矩，$\mathbf{R(q)}$表示肌肉力对广义坐标的等效力矩。下面我们主要讨论等式右侧的肌肉力与地反力。</p>
<h3 id="肌肉动力学"><a href="#肌肉动力学" class="headerlink" title="肌肉动力学"></a>肌肉动力学</h3><h4 id="肌肉激活动力学"><a href="#肌肉激活动力学" class="headerlink" title="肌肉激活动力学"></a>肌肉激活动力学</h4><p>尽管各个文献里的描述不尽一致，但一般来说<strong>excitation</strong>用来描述神经信号，是肌肉的控制输入（整流滤波归一化的EMG信号就是这个），而<strong>activation</strong>用来表示肌肉的活跃度，是肌肉的内部状态。在静态状态下，这两者可能相等，但在动态变化中，两者一般不同，存在由excitation到activation动态过程，即肌肉激活动力学。各方学者建立了不同的激活动力学模型，一般包含一个微分方程和一些非线性变换，其中<strong>Winters</strong>开发的一种激活动力学如下：</p>
<script type="math/tex; mode=display">
f=0.5 \tanh (b(e-a))</script><script type="math/tex; mode=display">
\frac{d a}{d t}=\left[\frac{1}{\tau_{a}(0.5+1.5 a)}(f+0.5)+\frac{0.5+1.5 a}{\tau_{d}}(-f+0.5)\right](e-a)</script><h4 id="肌肉收缩动力学"><a href="#肌肉收缩动力学" class="headerlink" title="肌肉收缩动力学"></a>肌肉收缩动力学</h4><img src="/2020/04/26/7.%E5%9F%BA%E4%BA%8E%E8%82%8C%E8%82%89%E9%AA%A8%E9%AA%BC%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%A2%84%E6%B5%8B%E4%BB%BF%E7%9C%9F/7.%E5%9F%BA%E4%BA%8E%E8%82%8C%E8%82%89%E9%AA%A8%E9%AA%BC%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%A2%84%E6%B5%8B%E4%BB%BF%E7%9C%9F/1587817529399.png" class>
<p>肌肉收缩的特性可以用如上的<strong>Hill肌肉模型</strong>来描述，它由肌肉收缩单元CE与被动弹性单元PE并联，并与一个肌腱弹性单元T串联，肌肉与肌腱之间还存在一个角度成为羽状角。由于根据上面的模型，肌肉实际产生的力不仅受到收缩单元CE的激活度的影响，还受到肌肉的长度、收缩速度的影响。由肌肉纤维产生的力具有如下关系：</p>
<script type="math/tex; mode=display">\begin{aligned}
F^{\mathrm{mt}}(t) &=F^{\mathrm{t}} \\
&=F^{\max }\left[a(t)f(l) f(v) +f_{\mathrm{p}}(l)\right] \cos (\phi(t))
\end{aligned}</script><p>$F^{\max }$表示最大等长收缩力，$f(l),f(v),f(p)$分别表示力-长度、力-速度、被动力-长度的关系。这些函数由下图所示的实验曲线所描述，一般可以通过多项式函数拟合来近似表示。</p>
<img src="/2020/04/26/7.%E5%9F%BA%E4%BA%8E%E8%82%8C%E8%82%89%E9%AA%A8%E9%AA%BC%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%A2%84%E6%B5%8B%E4%BB%BF%E7%9C%9F/7.%E5%9F%BA%E4%BA%8E%E8%82%8C%E8%82%89%E9%AA%A8%E9%AA%BC%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%A2%84%E6%B5%8B%E4%BB%BF%E7%9C%9F/1587721929270.png" class>
<p>注意到上式公式中，实际输入为激活度$a$、归一化肌肉长度$l$、和归一化收缩速度$v$，而肌肉长度与收缩速度之间存在关系，收缩动力学的状态量仅有$a$和$l$，且上述方程描述的是一个微分方程。我们将整个肌肉动力学表示为如下形式，但这种表示并不严谨，实际上每块肌肉包含着两个微分方程：</p>
<script type="math/tex; mode=display">
\mathbf{F}_{muscle} = \mathbf{F}_{muscle}(\mathbf{q},\mathbf{a} , \mathbf{\dot a},\mathbf{L}_{CE},\mathbf{\dot L}_{CE},\mathbf{e})</script><h3 id="地反力模型"><a href="#地反力模型" class="headerlink" title="地反力模型"></a>地反力模型</h3><p>OpenSim中采用<strong>Hunt-Crossley</strong>模型来表示接触力，接触力由刚度项、阻尼项和摩擦项组合而成，其表达式为：</p>
<script type="math/tex; mode=display">
\mathbf{f}_{\text {contact}}=\mathbf{f}_{\text {stiffness}}+\mathbf{f}_{\text {dissipation}}+\mathbf{f}_{\text {friction}}</script><img src="/2020/04/26/7.%E5%9F%BA%E4%BA%8E%E8%82%8C%E8%82%89%E9%AA%A8%E9%AA%BC%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%A2%84%E6%B5%8B%E4%BB%BF%E7%9C%9F/7.%E5%9F%BA%E4%BA%8E%E8%82%8C%E8%82%89%E9%AA%A8%E9%AA%BC%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%A2%84%E6%B5%8B%E4%BB%BF%E7%9C%9F/1587819399557.png" class>
<p>接触力模型中的第一项表示弹性力。如上图所示，我们可以用两个弹性小球来描述接触，当小球接触时会发生弹性变形，变形的程度与各自的弹性模量$E$有关，总的变形为$x$。当变形发生时，每个小球都会受到一个弹性力：</p>
<script type="math/tex; mode=display">
f_{\text {stiffness}}=f_{H z}=\left(\frac{4}{3} \sigma R^{1 / 2} E^{*}\right) x^{3 / 2}</script><p>$R$表示合成相对曲率，$E^*$表示合成弹性模量，它们都可以通过两个小球的参数计算出来；$\sigma$表示偏心系数，当$\sigma=1$的时候为圆接触，$x$为总的变形量。</p>
<p>接触力模型中的第二项表示损耗力，或是阻尼力。碰撞的发生往往伴随着能量的损耗，单纯的弹性力无法表示这一点，因此引入Hunt-Crossley耗散力：</p>
<script type="math/tex; mode=display">
f_{dissipation}=\frac{3}{2} f_{stiffness} c^{*} \dot{x}</script><p>$c^{*}$表示等效耗散系数，而$\dot{x}$表现出耗散力的阻尼特性。刚度力和耗散力都垂直接触面。</p>
<script type="math/tex; mode=display">
f_{\text {normal}}=f_{\text {stiffness}}+f_{\text {dissipation}}</script><p>接触力模型中的最后一项表示摩擦力，方向平行接触面：</p>
<script type="math/tex; mode=display">
f_{\text {friction}}=\mu(v) f_{\text {normal}}</script><p>$\mu(v)$表示等效摩擦因数，是关于相对运动速度的函数。</p>
<p>在使用上述的Hunt-Crossley模型来计算地反力时，地面的刚度认为无穷大，则相对弹性变形$x$可以通过接触小球圆心相对地面的距离计算得到，即：</p>
<script type="math/tex; mode=display">
\mathbf{F}_{contact} = \mathbf{F}_{contact}(\mathbf{q}, \dot{\mathbf{q}})</script><h3 id="综合模型"><a href="#综合模型" class="headerlink" title="综合模型"></a>综合模型</h3><p>综上所述，肌骨模型的动力学可以统一表示为：</p>
<script type="math/tex; mode=display">
\mathbf{M}(\mathbf{q}) \cdot \ddot{\mathbf{q}}+\mathbf{B}(\mathbf{q}, \dot{\mathbf{q}})=\mathbf{J(q)}^T \mathbf{F}_{contact}(\mathbf{q}, \dot{\mathbf{q}})+\mathbf{R(q)}\mathbf{F}_{muscle}(\mathbf{q},\mathbf{a} , \mathbf{\dot a},\mathbf{L}_{CE},\mathbf{\dot L}_{CE},\mathbf{e})</script><p>定义状态变量：</p>
<script type="math/tex; mode=display">
\mathbf{x}=\left(\mathbf{q}, \dot{\mathbf{q}}, \mathbf{L}_{C E}, \mathbf{a}\right)^{T}</script><p>在定义$u$为16块肌肉的控制量（excitations），上面的动力学方程可表示为：</p>
<script type="math/tex; mode=display">
\mathbf{f}(\mathbf{x}, \dot{\mathbf{x}}, \mathbf{u})=0</script><h2 id="肌骨模型的仿真应用"><a href="#肌骨模型的仿真应用" class="headerlink" title="肌骨模型的仿真应用"></a>肌骨模型的仿真应用</h2><h3 id="前向仿真"><a href="#前向仿真" class="headerlink" title="前向仿真"></a>前向仿真</h3><img src="/2020/04/26/7.%E5%9F%BA%E4%BA%8E%E8%82%8C%E8%82%89%E9%AA%A8%E9%AA%BC%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%A2%84%E6%B5%8B%E4%BB%BF%E7%9C%9F/7.%E5%9F%BA%E4%BA%8E%E8%82%8C%E8%82%89%E9%AA%A8%E9%AA%BC%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%A2%84%E6%B5%8B%E4%BB%BF%E7%9C%9F/1587828690595.png" class>
<h3 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h3><p>逆向分析是指，在已有运动学、地反力数据后，根据实验数据推断出产生相应运动的肌肉活动，也就是OpenSim中的<strong>CMC</strong>。由于肌肉之间存在和比较严重的耦合问题，多块肌肉连接同一个关节，同一块肌肉连接着不同关节，因此逆向分析最重要的是解决肌肉冗余 - Solving the Muscle Redundancy Problem。</p>
<p>在这个问题中，已有运动学数据$\mathbf{q}<em>k$和地反力$\mathbf{F}</em>{\mathbf{C}k}$序列，$k=1, \ldots, K$表示离散时间。我们先计算逆动力学得到关节力矩$T_{\mathbf{ID}k}$，关节力矩应当等于有肌肉收缩的等效力矩：</p>
<script type="math/tex; mode=display">
T_{\mathrm{ID} k}=\sum_{m=1}^{M} r_{m k} F_{\mathrm{T} m}+e_{\mathrm{T} k} T_{\mathrm{max}}</script><p>$m$表示肌肉序号，$r$表示肌肉对关节等效力矩。有时候关节力矩和肌肉里橘无法严格相等，因此我们添加了公式中的最后一项来表示力矩的残差，而$e_{\mathrm{T} k}$表示残差系数，在后面我们会设计优化目标是残差力尽可能的小。</p>
<p>由此建立逆向分析的优化框架：</p>
<img src="/2020/04/26/7.%E5%9F%BA%E4%BA%8E%E8%82%8C%E8%82%89%E9%AA%A8%E9%AA%BC%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%A2%84%E6%B5%8B%E4%BB%BF%E7%9C%9F/7.%E5%9F%BA%E4%BA%8E%E8%82%8C%E8%82%89%E9%AA%A8%E9%AA%BC%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%A2%84%E6%B5%8B%E4%BB%BF%E7%9C%9F/1587828542736.png" class>
]]></content>
      <categories>
        <category>仿真研究</category>
      </categories>
      <tags>
        <tag>肌肉骨骼模型</tag>
      </tags>
  </entry>
  <entry>
    <title>FPI无线足底压力鞋垫系统设计</title>
    <url>/2021/10/02/8.%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/FPI%E6%97%A0%E7%BA%BF%E8%B6%B3%E5%BA%95%E5%8E%8B%E5%8A%9B%E9%9E%8B%E5%9E%AB%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>本篇为无线传感系统的第二篇，主要记录无线足底压力鞋垫的设计和制作。</p>
<img src="/2021/10/02/8.%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/FPI%E6%97%A0%E7%BA%BF%E8%B6%B3%E5%BA%95%E5%8E%8B%E5%8A%9B%E9%9E%8B%E5%9E%AB%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/FPI_Rendering.gif" class title="FPI_Rendering">
<span id="more"></span>
<h2 id="压力鞋垫的测量原理"><a href="#压力鞋垫的测量原理" class="headerlink" title="压力鞋垫的测量原理"></a>压力鞋垫的测量原理</h2><p>压力鞋垫非自制，购买柔希科技的16P版本的压力鞋垫，鞋垫的压力传感器分布大致如下：</p>
<p><img src="/2021/10/02/8.%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/FPI%E6%97%A0%E7%BA%BF%E8%B6%B3%E5%BA%95%E5%8E%8B%E5%8A%9B%E9%9E%8B%E5%9E%AB%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/鞋垫连线图.jpeg" width="100%"></p>
<p>一般来说电阻式薄膜压力传感器的构成一般分为五层结构：顶层和底层为绝缘保护层；之后是两个导电层，用来连接传感器传输信号，并且多数情况下导线会成矩阵式排列，以减少导线数量、增加传感器密度；最中间的是一层或两层的压力敏感材料。</p>
<img src="/2021/10/02/8.%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/FPI%E6%97%A0%E7%BA%BF%E8%B6%B3%E5%BA%95%E5%8E%8B%E5%8A%9B%E9%9E%8B%E5%9E%AB%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/FPI_6.png" class title="截屏2021-06-09 下午9.21.55">
<p>压力传感器是利用电阻的压敏特性对压力进行测量，当压力作用在压敏材料上时，材料的电阻值会发生显著变化。多数压敏材料的电导率与压力成线性关系，因而电阻与压力之间成倒数关系，如上右图所示。</p>
<h2 id="压力鞋垫的数据采集"><a href="#压力鞋垫的数据采集" class="headerlink" title="压力鞋垫的数据采集"></a>压力鞋垫的数据采集</h2><img src="/2021/10/02/8.%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/FPI%E6%97%A0%E7%BA%BF%E8%B6%B3%E5%BA%95%E5%8E%8B%E5%8A%9B%E9%9E%8B%E5%9E%AB%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/FPI_1.png" class title="FPI_1">
<p>上面已经已到，压力鞋垫为了提高压力测量点的密度，减少导线数量，降低对采集芯片的引脚需求，一般采用矩阵式的排线方法，也就是同一根导线会连接多个传感器。一般来说，压力鞋垫上所有的传感器都按排和列进行划分，每一排或每一列都连接相同一根导线，任意选定一行和一列都可以唯一确定一个压力测量点。如上所示，柔细科技的16P压力鞋垫就将16个传感器分为4行6列，这样就可以将16根信号线降低为10根信号线，进一步若将列通道作为选通信号，则只有4根行信号线需要连接到模拟量采集端口。但这样矩阵式的布线方式也会给数据采集带来一些困难。</p>
<p>在多数论文里，为了进一步减少压力鞋垫需要的采集引脚数目，会选择采用多路选通器来进行行扫描，典型的有8路模拟多路选通器CD4051。这种芯片能够通过三个控制线以2进制编码的形式控制8个通道与公共端的连接，而当某一通道与公共端连通时，其余各通道均处于悬空状态。我们将鞋垫的列信号线接到CD4051的其中6路选通引脚上，然后用单片机接CD4051的A B C引脚控制选通信号，就可以用3个引脚控制压力鞋垫的6路列信号选通线。</p>
<img src="/2021/10/02/8.%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/FPI%E6%97%A0%E7%BA%BF%E8%B6%B3%E5%BA%95%E5%8E%8B%E5%8A%9B%E9%9E%8B%E5%9E%AB%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/FPI_7.png" class title="截屏2021-06-10 下午4.29.32">
<p>当CD4051的公共端连接VCC时，采集电路如下所示，以col6被选通为例，col6与公共端连通故电压为VCC，行信号连接一个分压电阻Rf后连接到GND。由于当col6选通时，col1-col5均为悬空状态，其余压力测量点的合成电阻对该采样电路没有影响，因此通过测量row1上的电压vol1，以及已知的分压电阻Rf，就可以得到压力测量点电阻R6的大小。在前期测试中压力电阻阻值范围为20M-50K，分压电阻Rf可以取10K-500K之间，分压电阻太小会导致测量精度下降，在前期实验中，Rf选择为200K。</p>
<img src="/2021/10/02/8.%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/FPI%E6%97%A0%E7%BA%BF%E8%B6%B3%E5%BA%95%E5%8E%8B%E5%8A%9B%E9%9E%8B%E5%9E%AB%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/FPI_2.png" class title="截屏2021-06-10 下午3.55.05">
<p>但在后续实验中发现，CD4051在通道切换的时候存在比较明显的响应过程。下图展示的是col6通道选通后，间隔100us连续采样14次，vol1的电压变化，曲线非常符合一阶指数响应过程，同时也显示该响应过程有较大的时间常数，T约为1/1411=700us，到达稳态需要3T时间也就是2.1ms，这样6个列通道全部采样一次就需要12.6ms，鞋垫压力的采样频率会小于100Hz，这是无法接受的。想要实现200Hz以上的采样频率，通道切换的过渡时间需要小于280us。</p>
<img src="/2021/10/02/8.%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/FPI%E6%97%A0%E7%BA%BF%E8%B6%B3%E5%BA%95%E5%8E%8B%E5%8A%9B%E9%9E%8B%E5%9E%AB%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/Snipaste_2021-06-07_09-43-03.png" class title="Snipaste_2021-06-07_09-43-03">
<p>进一步我们采用示波器观测通道切换时，vol1的电压变化曲线。单片机控制CD4051每间隔1ms在col6和col5之间进行一次切换，并且在通道6的压力采样点上有一个稳定持续的压力，通道5上没有压力，因此下图所示的波形会在高低电平之间不断切换，切换间隔为1ms。可以看出波形有明显的响应过程，并且在切换到通道5时，响应的时间常数更大一些。</p>
<img src="/2021/10/02/8.%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/FPI%E6%97%A0%E7%BA%BF%E8%B6%B3%E5%BA%95%E5%8E%8B%E5%8A%9B%E9%9E%8B%E5%9E%AB%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/Snipaste_2021-06-08_10-55-36.png" class title="Snipaste_2021-06-08_10-55-36">
<p>当CD4051从通道6切换到通道5时，除了col5上所施加的电压VCC外，由于上一时刻在作用在col6上的电压在通道关断后不会立刻消失，依靠电容效应随着放电过程电压逐渐降低，由叠加定义可知其仍然对vol1的电压产生影响，因此我们看到切换到通道5之后vol1的电压缓慢下降。而在从通道5切换到通道6时，由于col5上原来的电压较低，因此对col6的vol1影响较小，但还是可以看到一点缓慢下降的趋势。</p>
<img src="/2021/10/02/8.%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/FPI%E6%97%A0%E7%BA%BF%E8%B6%B3%E5%BA%95%E5%8E%8B%E5%8A%9B%E9%9E%8B%E5%9E%AB%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/FPI_3.png" class title="截屏2021-06-10 下午7.28.34">
<p>调研了解现有的足底压力系统有可以实现200Hz的采样频率，推测本实验中较大的过渡时间是由于CD4051芯片本身的特性造成的。因此后面尝试去除CD4051，直接使用单片机本身的引脚连接压力鞋垫的列选通信号线。连接col的单片机引脚设置为数字量输出模式，当信号选通时，将该引脚设置为高电平，并将其余引脚设置为低电平。实验中单片机每间隔300us切换一次选通信号，通道6的传感器上依然有一个持续施加的作用力。下图所示的为Rf分别为200K、100K、50K时的vol1波形：</p>
<img src="/2021/10/02/8.%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/FPI%E6%97%A0%E7%BA%BF%E8%B6%B3%E5%BA%95%E5%8E%8B%E5%8A%9B%E9%9E%8B%E5%9E%AB%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/Snipaste_2021-06-08_17-03-51_200k.png" class title="Snipaste_2021-06-08_17-03-51_200k">
<img src="/2021/10/02/8.%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/FPI%E6%97%A0%E7%BA%BF%E8%B6%B3%E5%BA%95%E5%8E%8B%E5%8A%9B%E9%9E%8B%E5%9E%AB%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/Snipaste_2021-06-08_17-05-08_100k.png" class title="Snipaste_2021-06-08_17-05-08_100k">
<img src="/2021/10/02/8.%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/FPI%E6%97%A0%E7%BA%BF%E8%B6%B3%E5%BA%95%E5%8E%8B%E5%8A%9B%E9%9E%8B%E5%9E%AB%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/Snipaste_2021-06-08_17-05-53_50k.png" class title="Snipaste_2021-06-08_17-05-53_50k">
<p>随着Rf的下降，电路时间常数1/RC降低，通道切换的响应时间变短，同时由于分压下降，col6采集的稳态电压也逐渐下降。当Rf选择为50K时，过渡时间小于250us，基本可以满足500Hz采样的需要。</p>
<p>但这种将列选通信号直接连接到单片机引脚上的方法存在一个比较严重的问题：同一行的传感器之间会相互影响：</p>
<img src="/2021/10/02/8.%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/FPI%E6%97%A0%E7%BA%BF%E8%B6%B3%E5%BA%95%E5%8E%8B%E5%8A%9B%E9%9E%8B%E5%9E%AB%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/GIF.gif" class title="GIF">
<p>上图所示的依然是对row1的6个传感器进行扫描，其中col6上作用一个稳定持续的压力不随时间发生改变，col5和col4上作用一个时变的压力。可以看出，在col5或col4压力变化时，col6的电压也会跟随发生改变。具体来说，当同一行的其他传感器的压力增大时，col6的电电压会减小。</p>
<p>下图为当前系统的电路连接示意图。由于所有的列选通信号都是连接单片机的数字量输出引脚，在非选通时引脚置为低电平，实际上也就是与GND直接相连，而非处于悬空状态。此时测量电路的实际分压电阻$ Rf^r $将是Rf与R15的并联，当其余电阻因受到压力而阻值下降时，$ Rf^r $会随之下降，vol1上的分压也因此降低。</p>
<img src="/2021/10/02/8.%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/FPI%E6%97%A0%E7%BA%BF%E8%B6%B3%E5%BA%95%E5%8E%8B%E5%8A%9B%E9%9E%8B%E5%9E%AB%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/FPI_4.png" class title="截屏2021-06-10 下午8.50.39">
<p>所以为了消除通道之间的耦合影响，需要将非选通的col通道设置为悬空状态，而不能连接到GND。程序上可以通过将引脚改变为输入模式来实现，因为在输入模式下引脚处于高阻状态近似于悬空（但不能设置为上拉输入或下拉输入）。下面为调整的后扫描曲线，在col5和col4压力变化时col1基本不受影响。</p>
<img src="/2021/10/02/8.%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/FPI%E6%97%A0%E7%BA%BF%E8%B6%B3%E5%BA%95%E5%8E%8B%E5%8A%9B%E9%9E%8B%E5%9E%AB%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/GIF2.gif" class title="GIF2">
<h2 id="无线压力鞋垫系统PCB设计"><a href="#无线压力鞋垫系统PCB设计" class="headerlink" title="无线压力鞋垫系统PCB设计"></a>无线压力鞋垫系统PCB设计</h2>]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>硬件开发</tag>
      </tags>
  </entry>
  <entry>
    <title>轨迹优化与直接配点法</title>
    <url>/2020/04/24/5.%E8%BD%A8%E8%BF%B9%E4%BC%98%E5%8C%96%E4%B8%8E%E7%9B%B4%E6%8E%A5%E9%85%8D%E7%82%B9%E6%B3%95/5.%E8%BD%A8%E8%BF%B9%E4%BC%98%E5%8C%96%E4%B8%8E%E7%9B%B4%E6%8E%A5%E9%85%8D%E7%82%B9%E6%B3%95/</url>
    <content><![CDATA[<p>本文主要讨论轨迹优化问题中的直接配点法，希望通过此教程帮助理解轨迹优化问题的基本概念与直接配点法的相关理论基础，最后我们还会讨论一些具体实现问题。直接配点法最终是通过非线性规划求解器来得到最终结果，因此在阅读本文之间可以先了解NLP问题相关基础知识，当然这并不影响对本文的理解，本文仅需要一些简单的高等数学与微分方程的知识。</p>
<span id="more"></span>
<h2 id="轨迹优化问题"><a href="#轨迹优化问题" class="headerlink" title="轨迹优化问题"></a>轨迹优化问题</h2><h3 id="问题简介"><a href="#问题简介" class="headerlink" title="问题简介"></a>问题简介</h3><p>轨迹用来描述一个物体的运动过程，通常是关于时间的变量。轨迹优化一种用于寻找最佳轨迹选择的方法，通常是通过选择合适的系统输入或控制量，是系统完成期望的运动过程。在控制领域，轨迹优化近似于最优控制，但从更广的概念上来讲，轨迹优化更具一般性。</p>
<p>下面我们用一个例子来进一步说明轨迹优化问题。</p>
<img src="/2020/04/24/5.%E8%BD%A8%E8%BF%B9%E4%BC%98%E5%8C%96%E4%B8%8E%E7%9B%B4%E6%8E%A5%E9%85%8D%E7%82%B9%E6%B3%95/5.%E8%BD%A8%E8%BF%B9%E4%BC%98%E5%8C%96%E4%B8%8E%E7%9B%B4%E6%8E%A5%E9%85%8D%E7%82%B9%E6%B3%95/1587399082007.png" class>
<p>如图所示，一个滑块放置在光滑地面上，并受到一个水平方向的作用力。我们想要滑块在里的作用下，在1s的时间内从开始位置运动到指定位置，并刚好停在该处。这个问题存在着无数种可能的运动轨迹，进一步，我们希望从中确定一条最优的轨迹，如图所示。</p>
<img src="/2020/04/24/5.%E8%BD%A8%E8%BF%B9%E4%BC%98%E5%8C%96%E4%B8%8E%E7%9B%B4%E6%8E%A5%E9%85%8D%E7%82%B9%E6%B3%95/5.%E8%BD%A8%E8%BF%B9%E4%BC%98%E5%8C%96%E4%B8%8E%E7%9B%B4%E6%8E%A5%E9%85%8D%E7%82%B9%E6%B3%95/1587400040884.png" class>
<img src="/2020/04/24/5.%E8%BD%A8%E8%BF%B9%E4%BC%98%E5%8C%96%E4%B8%8E%E7%9B%B4%E6%8E%A5%E9%85%8D%E7%82%B9%E6%B3%95/5.%E8%BD%A8%E8%BF%B9%E4%BC%98%E5%8C%96%E4%B8%8E%E7%9B%B4%E6%8E%A5%E9%85%8D%E7%82%B9%E6%B3%95/1587400055329.png" class>
<p>我们可以把这个问题用数学语言形式化。系统满足如下的动力学方程：</p>
<script type="math/tex; mode=display">
\dot{x}=\nu, \quad \dot{\nu}=u</script><p>并要求满足如下的边界约束：</p>
<script type="math/tex; mode=display">
\begin{array}{ll}
x(0)=0, & x(1)=1 \\
\nu(0)=0, & \nu(1)=0
\end{array}</script><p>轨迹优化关心在一定指标下的最优轨迹，这样的指标可以用如下的目标函数来描述：</p>
<script type="math/tex; mode=display">
\min _{u(t), x(t), \nu(t)} \int_{0}^{1} u^{2}(\tau) d \tau</script><h3 id="形式化描述"><a href="#形式化描述" class="headerlink" title="形式化描述"></a>形式化描述</h3><p>一般来说，轨迹优化问题通过在一定的约束条件下优化如下的目标函数来得到最优轨迹：</p>
<script type="math/tex; mode=display">
\min _{t_{0}, t_{F}, \boldsymbol{x}(t), \boldsymbol{u}(t)} \underbrace{J\left(t_{0}, t_{F}, \boldsymbol{x}\left(t_{0}\right), \boldsymbol{x}\left(t_{F}\right)\right)}_{\text {Mayer Term }}+\underbrace{\int_{t_{0}}^{t_{F}} w(\tau, \boldsymbol{x}(\tau), \boldsymbol{u}(\tau)) d \tau}_{\text {Lagrange Term }}</script><p>其中的约束条件包含如下形式：<br>系统的动力学约束：</p>
<script type="math/tex; mode=display">
\dot{\boldsymbol{x}}(t)=\boldsymbol{f}(t, \boldsymbol{x}(t), \boldsymbol{u}(t))</script><p>路径约束：</p>
<script type="math/tex; mode=display">
\boldsymbol{h}(t, \boldsymbol{x}(t), \boldsymbol{u}(t)) \leq \mathbf{0}</script><p>边界约束：</p>
<script type="math/tex; mode=display">
\boldsymbol{g}\left(t_{0}, t_{F}, \boldsymbol{x}\left(t_{0}\right), \boldsymbol{x}\left(t_{F}\right)\right) \leq \mathbf{0}</script><p>和状态量与控制量边界：</p>
<script type="math/tex; mode=display">
\begin{array}{l}
\boldsymbol{x}_{\mathrm{low}} \leq \boldsymbol{x}(t) \leq \boldsymbol{x}_{\mathrm{upp}} \\
\boldsymbol{u}_{\mathrm{low}} \leq \boldsymbol{u}(t) \leq \boldsymbol{u}_{\mathrm{upp}}
\end{array}</script><p>由于最终我们想要求得的是控制量关于时间的具体函数形式，而非一个值或一个参数，因此轨迹优化问题也可以理解为在一定约束或大量约束下的泛函问题。</p>
<h3 id="变分法求解"><a href="#变分法求解" class="headerlink" title="变分法求解"></a>变分法求解</h3><p>（对变分法不熟悉的可以跳过本部分）<br>针对泛函问题，可以采用变分法进行求解。以滑块移动的问题为例，由于其目标函数可以表示为如下形式：</p>
<script type="math/tex; mode=display">
J=\int_{0}^{1} u^{2}(\tau) d \tau=\int_{0}^{1} \ddot{x}^{2}(\tau) d \tau</script><p>因此可以构建拉格朗日方程：</p>
<script type="math/tex; mode=display">
\mathcal{L}(t, x, \dot{x}, \ddot{x})=\mathcal{L}(\ddot{x})=\ddot{x}^{2}</script><p>对此应用推广的欧拉-拉格朗日方程：</p>
<script type="math/tex; mode=display">
\frac{\partial \mathcal{L}}{\partial x^{*}}-\frac{d}{d t} \frac{\partial \mathcal{L}}{\partial \dot{x}^{*}}-\frac{d^{2}}{d t^{2}} \frac{\partial \mathcal{L}}{\partial \dot{x}^{*}}=0</script><p>可得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
(0)-(0)-\frac{d^{2}}{d t^{2}}\left(2 \ddot{x}^{*}\right) &=0 \\
\frac{d^{4}}{d t^{4}} x^{*} &=0
\end{aligned}</script><p>因此$x$具有三次函数的形式，将相应的边界条件代入，得到最优轨迹：</p>
<script type="math/tex; mode=display">
u^{*}(t)=6-12 t, \quad x^{*}(t)=3 t^{2}-2 t^{3}</script><h2 id="直接配点法-direct-collocation-methods"><a href="#直接配点法-direct-collocation-methods" class="headerlink" title="直接配点法-direct collocation methods"></a>直接配点法-direct collocation methods</h2><p>对于简单问题，使用变分法可以很快的求解出最优轨迹，但对于复杂的轨迹优化问题，状态变量或控制变量有可能达到几十万的维度，约束条件也会非常复杂。因此有必要研究通过数值方法求解轨迹优化问题，接下来我们介绍其中一种数值求解的思想，也就是直接配点法。对于一些其他的方法，例如shooting methods，则不在本文的讨论范围之内。接下来我们先通过滑块移动的问题来说明直接配点法的思想，之后再详细介绍梯形聚点法。</p>
<p>直接配点法的核心思想是将连续时间曲线离散为有限时间序列，从而把轨迹规划问题转化大规模非线性规划问题。首先，我们对轨迹进行离散化，将状态变量$x(t)$和$v(t)$表示为一系列离散时刻上的值，也称为配置点：</p>
<script type="math/tex; mode=display">
\begin{array}{l}
t \rightarrow t_{0} \ldots t_{k} \ldots t_{N} \\
x \rightarrow x_{0} \ldots x_{k} \ldots x_{N} \\
\nu \rightarrow \nu_{0} \ldots \nu_{k} \ldots \nu_{N}\\
u \rightarrow u_{0} \ldots u_{k} \ldots u_{N} \\
\end{array}</script><p>这些配置点实际上就是最终转化的NLP问题优化变量，$N$表示离散的细化程度，N越大则离散化误差越小，但优化单独越大。接下来我们要把原始问题用这些配置点进行近似表示，其核心思想是两个配置点之间的状态变化等于系统动力学的积分：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\dot{x} &=\nu \\
\int_{t_{k}}^{t_{k+1}} \dot{x} d t &=\int_{t_{k}}^{t_{k+1}} \nu d t \\
x_{k+1}-x_{k} & \approx \frac{1}{2}\left(h_{k}\right)\left(\nu_{k+1}+\nu_{k}\right)
\end{aligned}</script><p>由于位置的微分等于速度，对等式两侧进行积分，从时刻$t<em>k$积分到时刻$t</em>{k+1}$。等式左侧自然等于两个状态之间的差值，而对于等式右侧我们用梯形积分公式进行近似。这里$h<em>k=(t</em>{k+1}-t_k)$。</p>
<p>我们把速度与作用力的动力学关系同样转化成上面的形式，忽略由梯形积分近似的误差，得到以下由配置点表示的约束方程：</p>
<script type="math/tex; mode=display">
\begin{array}{l}
x_{k+1}-x_{k}=\frac{1}{2}\left(h_{k}\right)\left(\nu_{k+1}+\nu_{k}\right) \\
\nu_{k+1}-\nu_{k}=\frac{1}{2}\left(h_{k}\right)\left(u_{k+1}+u_{k}\right)
\end{array}</script><p>注意到通过离散化，我们把原来连续的动力学方程，转化为N个等式约束。当然为了满足题目要求，配置点还要满足以下的约束：</p>
<script type="math/tex; mode=display">
\begin{array}{ll}
x_{0}=0, & x_{N}=1 \\
\nu_{0}=0, & \nu_{N}=0
\end{array}</script><p>最后，通过采用梯形积分近似的方法，将目标函数也用配置点进行表示：</p>
<script type="math/tex; mode=display">
\min _{u(t)} \int_{t_{0}}^{t_{N}} u^{2}(\tau) d \tau \quad = \min _{u_{0} \ldots u_{N}} \sum_{k=0}^{N-1} \frac{1}{2}\left(h_{k}\right)\left(u_{k}^{2}+u_{k+1}^{2}\right)</script><p>至此，滑块移动问题被完全转化为一个3N个优化参数（配置点），2N+4个约束的非线性规划问题，采用类似内点法的非线性规划求解器（IPOPT）进行求解，就可以得到问题数值结果。</p>
<h2 id="梯形配点法"><a href="#梯形配点法" class="headerlink" title="梯形配点法"></a>梯形配点法</h2><p>在上面的例子中，我们采用梯形公式来近似积分，将问题中的所用连续问题转化为离散问题，这种方法称为梯形配点法，下面对其进行详细说明。</p>
<h3 id="积分方程的近似"><a href="#积分方程的近似" class="headerlink" title="积分方程的近似"></a>积分方程的近似</h3><p>积分方程一般出现在目标函数中，梯形配点法中采用被积函数两个时刻之间的梯形面积来近似积分：</p>
<script type="math/tex; mode=display">
\int_{t_{0}}^{t_{F}} w(\tau, \boldsymbol{x}(\tau), \boldsymbol{u}(\tau)) d \tau \quad \approx \sum_{k=0}^{N-1} \frac{1}{2} h_{k} \cdot\left(w_{k}+w_{k+1}\right)</script><h3 id="微分方程的近似"><a href="#微分方程的近似" class="headerlink" title="微分方程的近似"></a>微分方程的近似</h3><p>微分方程一般出现在动力学方程中。直接配点法的关键特征之一是，它将系统动力学表示为一组约束，称为配点约束。梯形配点法将动力学方程写成积分形式，然后用梯形求积法来近似积分：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\dot{\boldsymbol{x}} &=\boldsymbol{f} \\
\int_{t_{k}}^{t_{k+1}} \boldsymbol{x} d t &=\int_{t_{k}}^{t_{k+1}} \boldsymbol{f} d t \\
\boldsymbol{x}_{k+1}-\boldsymbol{x}_{k} & \approx \frac{1}{2} h_{k} \cdot\left(\boldsymbol{f}_{k+1}+\boldsymbol{f}_{k}\right)
\end{aligned}</script><p>然后在每对配置点之间都建立这种近似的约束关系：</p>
<script type="math/tex; mode=display">
\boldsymbol{x}_{k+1}-\boldsymbol{x}_{k}=\frac{1}{2} h_{k} \cdot\left(\boldsymbol{f}_{k+1}+\boldsymbol{f}_{k}\right), \quad k \in 0, \ldots,(N-1)</script><h3 id="原始约束"><a href="#原始约束" class="headerlink" title="原始约束"></a>原始约束</h3><p>离散后的配置点，应当满足原问题的状态约束、控制约束、路径约束、边界约束：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\boldsymbol{x}<\mathbf{0} \quad &\rightarrow \quad \boldsymbol{x}_{k}<\mathbf{0} \quad \forall k\\
\boldsymbol{u}<\mathbf{0} \quad &\rightarrow \quad \boldsymbol{u}_{k}<\mathbf{0} \quad \forall k\\
\boldsymbol{g}(t, \boldsymbol{x}, \boldsymbol{u})<\mathbf{0} \quad &\rightarrow \quad \boldsymbol{g}\left(t_{k}, \boldsymbol{x}_{k}, \boldsymbol{u}_{k}\right)<\mathbf{0} \quad \forall k\\
\boldsymbol{h}\left(t_{0}, \boldsymbol{x}\left(t_{0}\right), \boldsymbol{u}\left(t_{0}\right)\right)<\mathbf{0} \quad &\rightarrow \quad \boldsymbol{h}\left(t_{0}, \boldsymbol{x}_{0}, \boldsymbol{u}_{0}\right)<\mathbf{0} \quad 
\end{aligned}</script><h3 id="曲线插值"><a href="#曲线插值" class="headerlink" title="曲线插值"></a>曲线插值</h3><p>为了从配置点恢复连续轨迹，需要进行曲线插值。梯形配点法的将控制轨迹和系统动力学近似为分段线性函数，也称为线性样条。构造样条曲线时，术语结点<em>knot point </em>用来表示连接两个多项式段的任何点，对于梯形配点法而言，样条的结点与配置点是重合的。首先通过分段线性插值重建控制轨迹（$\tau=t-t<em>{k}$，$h</em>{k}=t<em>{k+1}-t</em>{k}$）：</p>
<script type="math/tex; mode=display">
\boldsymbol{u}(t) \approx \boldsymbol{u}_{k}+\frac{\tau}{h_{k}}\left(\boldsymbol{u}_{k+1}-\boldsymbol{u}_{k}\right)</script><img src="/2020/04/24/5.%E8%BD%A8%E8%BF%B9%E4%BC%98%E5%8C%96%E4%B8%8E%E7%9B%B4%E6%8E%A5%E9%85%8D%E7%82%B9%E6%B3%95/5.%E8%BD%A8%E8%BF%B9%E4%BC%98%E5%8C%96%E4%B8%8E%E7%9B%B4%E6%8E%A5%E9%85%8D%E7%82%B9%E6%B3%95/1587487370709.png" class>
<p>之后重建状态变量的轨迹，需要说明的是，状态变量的轨迹是二次样条曲线的形式。因为在梯形配点法中，系统动力学是用线性样条近似，而状态轨迹是动力学方程的积分，因此具有二次形式。显然这样重建出的状态轨迹更准确，如下图所示。</p>
<script type="math/tex; mode=display">
\boldsymbol{f}(t)=\dot{\boldsymbol{x}}(t) \approx \boldsymbol{f}_{k}+\frac{\tau}{h_{k}}\left(\boldsymbol{f}_{k+1}-\boldsymbol{f}_{k}\right)</script><script type="math/tex; mode=display">
\boldsymbol{x}(t)=\int \dot{\boldsymbol{x}}(t) d \tau \approx \boldsymbol{c}+\boldsymbol{f}_{k} \tau+\frac{\tau^{2}}{2 h_{k}}\left(\boldsymbol{f}_{k+1}-\boldsymbol{f}_{k}\right)</script><script type="math/tex; mode=display">
\boldsymbol{x}(t) \approx \boldsymbol{x}_{k}+\boldsymbol{f}_{k} \tau+\frac{\tau^{2}}{2 h_{k}}\left(\boldsymbol{f}_{k+1}-\boldsymbol{f}_{k}\right)</script><img src="/2020/04/24/5.%E8%BD%A8%E8%BF%B9%E4%BC%98%E5%8C%96%E4%B8%8E%E7%9B%B4%E6%8E%A5%E9%85%8D%E7%82%B9%E6%B3%95/5.%E8%BD%A8%E8%BF%B9%E4%BC%98%E5%8C%96%E4%B8%8E%E7%9B%B4%E6%8E%A5%E9%85%8D%E7%82%B9%E6%B3%95/1587487392318.png" class>
<h2 id="实现问题"><a href="#实现问题" class="headerlink" title="实现问题"></a>实现问题</h2><p>接下来我们来讨论一些配点法实际实现时可能遇到的问题和解决方法。</p>
<h3 id="初始化问题"><a href="#初始化问题" class="headerlink" title="初始化问题"></a>初始化问题</h3><p>几乎所有的轨迹优化技术都需要一个良好的初始猜测来开始优化。良好的初始化将确保求解器快速地得到全局最优解，一个糟糕的初始化会导致非线性规划求解器无法解决一个正确的优化问题。初始猜测的选择会影响优化最终收敛到哪一个局部最小值，不合适的初始值会使求解器优化到一个局部极小值，而约束的存在使情况变得更糟，优化器甚至无法找到一个可行的解决方案。</p>
<p>轨迹优化的最佳初始化通常需要一些特定的知识，但也有一些通用的方法可以采用。通常建议尝试集中不同的初始化策略，检查他们是否都优化到同一个结果。最简单的初始方法是假设轨迹是状态空间的一条直线，当然也可以设计为可能预想到的结果。</p>
<p>对于更复杂的轨迹优化问题，我们建议先从一个简单的问题开始优化，以优化结果作为下一个优化问题的初始猜测，然后构造一系列优化问题，逐渐接近最终的问题。举例来说，让一个双足行走机器人以3.0m/s的速度奔跑或许是一个比较复杂的优化问题，你可以先从1.0m/s的行走开始优化，逐渐增加前进速度，直至达到期望的速度，在这过程中每次优化的结果都作为下一次优化的初始估计。</p>
<h3 id="网格细化"><a href="#网格细化" class="headerlink" title="网格细化"></a>网格细化</h3><p>直接配点法采用分段多项式样条函数来对轨迹曲线进行近似，显然离散的时间越短、多项式的阶数越高，则近似的精度越高。网格细分是在一系列不同的配置网格上求解轨迹优化问题的过程，也称为配置网格。一般情况下，初始的网格比较粗糙，配置点数量较少，并采用较低阶的配置方法，而后续的网格有更多的点和更高阶的配置方法。这种迭代策略是为了以最少的计算工作量获得最精确的解决方案：初始的粗网格位置计算量小，并能给出一个比较好的初始估计，之后通过更精细的网格配置得到更准确的结果。</p>
<img src="/2020/04/24/5.%E8%BD%A8%E8%BF%B9%E4%BC%98%E5%8C%96%E4%B8%8E%E7%9B%B4%E6%8E%A5%E9%85%8D%E7%82%B9%E6%B3%95/5.%E8%BD%A8%E8%BF%B9%E4%BC%98%E5%8C%96%E4%B8%8E%E7%9B%B4%E6%8E%A5%E9%85%8D%E7%82%B9%E6%B3%95/1587490201492.png" class>
<h3 id="误差分析"><a href="#误差分析" class="headerlink" title="误差分析"></a>误差分析</h3><p>在所述的轨迹优化方法中存在两种形式的数值误差：转换误差和求解误差，这里我们主要关注前一种误差，即量化离散所带来的误差。衡量误差的标准有很多，这里我们用候选轨迹的动力学误差进行评价。由于在任何时刻系统都要满足动力学方程，因此有:</p>
<script type="math/tex; mode=display">
\dot{\boldsymbol{x}}^{*}(t)=\boldsymbol{f}\left(t, \boldsymbol{x}^{*}(t), \boldsymbol{u}^{*}(t)\right)</script><p>公式中的变量都可以由配置点插值得到，因此动力学方程误差为：</p>
<script type="math/tex; mode=display">
\varepsilon(t)=\dot{\boldsymbol{x}}(t)-\boldsymbol{f}(t, \boldsymbol{x}(t), \boldsymbol{u}(t))</script><p>上式在配置点处应该严格等于零，但在配置点之间一般不为零。通过误差的积分可以量化转化误差：</p>
<script type="math/tex; mode=display">
\boldsymbol{\eta}_{k}=\int_{t_{k}}^{t_{k+1}}|\varepsilon(\tau)| d \tau</script><p>若转化误差大于一定水平，则需要进一步进行网格细化。</p>
]]></content>
      <categories>
        <category>仿真研究</category>
      </categories>
      <tags>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>非线性规划</title>
    <url>/2020/04/22/6.%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/6.%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>优化是自然界和人类社会最为普遍行为，物理系统趋于较低的能量，化学分子相互作用以达到最小的电子势能，投资者寻求最佳收益，工程师寻求最佳性能，优化是宇宙运行的本质之一。在本文中，我们将主要讨论非线性规划的数值方法。</p>
<p>根据函数性质，优化问题可分为线性优化和非线性优化；根据是否含有约束，可以分为无约束优化和有约束优化。一般来说，有约束优化问题要比无约束优化问题更难求解，因此本文将先介绍非线性优化的求解算法，再介绍非线性规划的内点法。</p>
<span id="more"></span>
<h2 id="非线性优化"><a href="#非线性优化" class="headerlink" title="非线性优化"></a>非线性优化</h2><h3 id="问题描述与必要性条件"><a href="#问题描述与必要性条件" class="headerlink" title="问题描述与必要性条件"></a>问题描述与必要性条件</h3><p>非线性优化问题是指，对于一个给定的非线性函数$f(x)$，确定出使函数值最小的自变量$x$：</p>
<script type="math/tex; mode=display">\min _{x} f(x)</script><p>其中$f(x)$称为目标函数，$x$称为未知量或参数。实际情况中的最大化问题一般都可以通过简单的变换转化为最小值问题，因此我们仅考虑最小化一种情况。由高等数学可知，在无约束的情况下，该问题的解应满足如下一阶条件和二阶条件：</p>
<p>一阶必要条件：$\nabla f\left(x^{*}\right)=0$</p>
<p>二阶必要条件：$\nabla f(x^<em>)=0, \nabla^2 f(x^</em>)\ge 0$</p>
<p>对于参数为多维的情况，$\nabla f\left(x^{<em>}\right)$表示梯度向量，$\nabla^2 f\left(x^{</em>}\right)$表示海森矩阵，而符号$\ge$表示海森矩阵半正定。一阶必要条件表明目标函数达到极值点，而二阶必要条件进一步将其限定为极小值点。对于一般情况，二阶必要条件只能判定其为局部最优解，而不一定为全局最小值；只有当目标函数为凸函数时，局部极小才等价为全局极小值。</p>
<h3 id="非线性优化的数值方法"><a href="#非线性优化的数值方法" class="headerlink" title="非线性优化的数值方法"></a>非线性优化的数值方法</h3><p>对于复杂的非线性函数，计算机没办法根据必要条件直接得到解，而是一般通过数值迭代的方法从一个初始点一步步逼近问题的解$x^<em>$。用数学的语言表述为，从一个初始点$x<em>0$，通过构造一个迭代序列$\left{x</em>{k}\right}_{k=0}^{\infty}$，使$x_k\to x^</em>$。这种迭代的思路可以分为两种：线搜索算法和置信域算法。在本文中我们主要讨论线搜索的方法。</p>
<p>在线搜索策略中，算法每次迭代会先在当前参数$x_k$处确定一个参数的<strong>迭代方向</strong>$d_k$，然后让参数在该方向上移动一定<strong>步长</strong>$\alpha_k$，即：</p>
<script type="math/tex; mode=display">
x_{k+1}=x_k+\alpha_k d_k</script><h4 id="迭代步长"><a href="#迭代步长" class="headerlink" title="迭代步长"></a>迭代步长</h4><p>假定我们已经确定了一个迭代方向$d_k$，则原优化问题可以转化为一个一维搜索问题：</p>
<script type="math/tex; mode=display">\min _{\alpha>0} f\left(x_{k}+\alpha d_{k}\right)</script><p>我们可以进行精确一维搜索，采用例如二分法、黄金分割法来求出该一维问题的最佳步长；当然我们也可以采用非精确一维搜索来确定$\alpha_k$，只要其满足：</p>
<script type="math/tex; mode=display">f(x_k+\alpha_k d_k) < f(x_k)</script><p>实际上，在现代优化算法中，一般采取非精确一维搜索的策略，虽然其每次迭代目标函数的下降幅度不如精确一维搜索，但整体的优化效率更高。</p>
<h4 id="梯度法"><a href="#梯度法" class="headerlink" title="梯度法"></a>梯度法</h4><p>非线性优化的主要问题在于确定一个适当的迭代方向$d_k$。<strong>最速下降方向</strong>，即负梯度方向$-\nabla f(x_k)$是最明显的迭代方向，它本身就描述目标函数下降最快的方向。除了最速下降方向，任何与其夹角小于$\pi/2$的方向，都可以作为迭代方向，都能够保证目标函数下降。即$d_k=-B_k \nabla f_k$，$B_k$为·正定矩阵。如图所示，灰色表示原函数的等高线，蓝色向量表示目标函数梯度，同样指向了等高线的法向，红色表示一种可行的迭代方向。</p>
<img src="/2020/04/22/6.%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/6.%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/1587611833869.png" class>
<p>上面我们已经说过，在确定了迭代方向后，可以采用线搜索的方法来确定合适的迭代步长。由于精确一维搜索比较耗时，因此往往采用非精确一维搜索策略，使$f_{k+1}&lt;f_k$：</p>
<script type="math/tex; mode=display">
x_{k+1}=x_k-\alpha_k\nabla f_k</script><p>梯度下降法简单直观，但对复杂问题的求解效果往往不太理想，尤其是当迭代点接近最优点时，函数梯度会变得很小，优化速度也因而变得很慢，下图所示。</p>
<img src="/2020/04/22/6.%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/6.%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/1587611935345.png" class>
<h4 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a>牛顿法</h4><p>另一种更常用的方法是<strong>Newtown法</strong>。考虑对目标函数$f(x)$在$x=x_k$处进行二阶泰勒近似：</p>
<script type="math/tex; mode=display">
f\left(x_{k}+d\right) \approx f_{k}+d^{T} \nabla f_{k}+\frac{1}{2} d^{T} \nabla^{2} f_{k} d \stackrel{\text { def }}{=} m_{k}(d)</script><p>我们将其看作为关于步长$d$的函数。假定海森矩阵$\nabla^2 f_k$是整定的，对$m_k(d)$求导并令导数等于零可得：</p>
<script type="math/tex; mode=display">
d_{k}=-\left(\nabla^{2} f_{k}\right)^{-1} \nabla f_{k}</script><p>本质上来说牛顿法是通过在迭代点处，利用目标函数的一阶导和二阶导的信息来对目标函数进行估计，并用估计函数的最小值作为参数迭代的方向。下图展示了这种优化思路，绿色为所估计的函数。在牛顿法中，迭代方向$d_k$由迭代点$x_k$指向估计函数的最小值，因此有一个自然步长$\alpha=1$：</p>
<script type="math/tex; mode=display">
x_{k+1}=x_k-\left(\nabla^{2} f_{k}\right)^{-1} \nabla f_{k}</script><img src="/2020/04/22/6.%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/6.%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/1587614043275.png" class>
<p>因为利用了目标函数更多的信息，因此牛顿法是一种比梯度法更有“远见”的算法。当估计函数比较接近目标函数时，尤其是接近最优解时，牛顿法的下降速度很快，具有二阶收敛性，也就是对于二次形式的目标函数，牛顿法可以通过一次迭代得到结果。</p>
<p>同时牛顿法也存在着一些的问题。一方面在优化初期时，对于目标函数的估计往往不太准确，导致优化性能大大下降；另一方面，二阶海森矩阵的计算非常困难。为了避免海森矩阵的计算问题，实际中更多的使用<strong>拟牛顿法</strong>，通过在迭代过程中目标函数和梯度信息来近似估计海森矩阵或海森矩阵的逆矩阵，再用该估计来计算迭代方向，例如<strong>BFGS</strong>算法等。</p>
<h2 id="非线性规划"><a href="#非线性规划" class="headerlink" title="非线性规划"></a>非线性规划</h2><p>非线性规划是指在一定约束条件下的优化问题，对于有约束优化我们一般用Programming来表示，其标准数学表述如下，其中约束包含等式约束和不等式约束：</p>
<script type="math/tex; mode=display">
\min _{x \in \mathbb{R}^{n}} f(x) \quad \text { subject to }\left\{\begin{array}{ll}
c_{i}(x)=0, & i \in \mathcal{E} \\
c_{i}(x) \geq 0, & i \in \mathcal{I}
\end{array}\right.</script><h3 id="必要性条件"><a href="#必要性条件" class="headerlink" title="必要性条件"></a>必要性条件</h3><p>在讨论具体的算法之前，我们要先研究一下约束优化的必要性条件。不同于无约束优化，有约束优化的最优值往往在约束边界上，因此不能采用无约束优化的必要性条件来判断约束优化。</p>
<p>对于只有等式约束$c_i(x)=0, i \in \mathcal{E}$的情况，我们可以构造Lagrange函数：</p>
<script type="math/tex; mode=display">
\mathcal{L}(x, \lambda)= f\left(x\right)-\lambda_E^T c_{E}\left(x\right)</script><p>$c_E(x)$表示等式约束构成的向量函数，$\lambda_E$表示Lagrange乘子构成参数向量。从而原约束优化问题的必要性条件可以由Lagrange函数的一阶导数给出：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\nabla_{x}\mathcal{L}(x, \lambda)&= \nabla f\left(x\right)- \lambda_E^T \nabla c_{E}\left(x\right) = 0\\
\nabla_{\lambda}\mathcal{L}(x, \lambda)&= c_E(x)=0
\end{aligned}</script><p>对于更一般的含有不等式约束的情况，这里给出其一阶必要性条件，即<strong>KKT条件</strong>：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\nabla_{x}\mathcal{L}(x, \lambda)= \nabla f\left(x\right)- \lambda_E^T \nabla c_{E}\left(x\right)- \lambda_I^T \nabla c_{I}\left(x\right) &= 0\\
c_{E}\left(x\right) &=0\\
c_{I}\left(x\right) & \geq 0 \\
\lambda_I & \geq 0 \\
\lambda^T c\left(x\right) &= 0
\end{aligned}</script><p>KKT条件中比较难理解的是最后一个等式，该等式主要针对不等式约束，也称为互补条件<strong>complementarity conditions</strong>。观察该等式可以看出，$\lambda$和$c(x)$其中必定有一个需要等于零，当$\lambda \ne 0$时，$c(x)=0$，则该约束处于“激活”状态，不等式约束退化成等式约束；当$c(x)\ne 0$时，$\lambda = 0$，则KKT条件的第一个等式将不包含该约束，即该约束“未激活”。</p>
<p>KKT条件为必要性条件，也就是用来判断所求参数是否为优化问题的解。其在约束优化中有非常重要的意义，几乎所有的约束优化算法的收敛性都需要借助KKT条件进行证明。</p>
<h3 id="序列二次型规划"><a href="#序列二次型规划" class="headerlink" title="序列二次型规划"></a>序列二次型规划</h3><p>我们先来研究一种相对简单的约束优化问题，即等式约束下的优化问题：</p>
<script type="math/tex; mode=display">
\begin{array}{c}
\min _{x} f(x) \\
\text { s.t. } \quad c(x)=0 \\
\end{array}</script><p>首先我们构造拉格朗日函数，将该约束优化问题转化为无约束优化问题：</p>
<script type="math/tex; mode=display">
\min _{x, \lambda} \mathcal{L}(x, \lambda)= f\left(x\right)-\lambda^T c\left(x\right)</script><p>之后采用牛顿法进行求解，对于一个初始估计$(x<em>0,\lambda_0)$，通过构造序列$\left{\left(x</em>{k}, \lambda_{k}\right)\right}$来逼近问题的解：</p>
<script type="math/tex; mode=display">
\left(x_{k+1}, \lambda_{k+1}\right)=\left(x_{k}, \lambda_{k}\right)+\left(d_{k}, d_{k}^{\lambda}\right)</script><p>正如我们在非线性优化里讨论的那样，下面公式左侧矩阵为拉格朗日函数的海森矩阵，右侧为拉格朗日函数的梯度向量：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{cc}
W_{k} & -A_{k}^{T} \\
-A_{k} & 0
\end{array}\right]\left(\begin{array}{c}
d_{k} \\
d_{k}^{\lambda}
\end{array}\right)=-\left(\begin{array}{c}
\nabla f_{k}- \lambda_{k} A_{k} \\
c_{k}
\end{array}\right)</script><script type="math/tex; mode=display">
W_{k}=\nabla_{x x}^{2} \mathcal{L}\left(x_{k}, \lambda_{k}\right), A_{k} = \nabla c(x)</script><p>接下来我们用一个例子来说明约束优化。首先考虑如下的约束优化问题：</p>
<script type="math/tex; mode=display">
\begin{array}{c}
\min _{x, y} f(x, y) = (x-4)^2+y^2 \\
\text { s.t. } \quad c(x, y) = y-x^2-1 =0 \\
\end{array}</script><p>为了方便理解，这里将该问题进行了可视化，蓝色表示约束轨迹或可行域，绿色表述目标函数，红色点表示该问题的解。在使用拉格朗日乘子法进行优化迭代时，参数$x$的最速下降方向为$d<em>k=-\nabla f</em>{k} + \lambda<em>{k} A</em>{k}$，即由目标函数梯度$\nabla f<em>{k}$和约束函数梯度$\lambda</em>{k} A<em>{k}$组合而成，由于梯度方向与等高线方向垂直，因此$-\nabla f</em>{k}$指向目标函数下降方向，而$\lambda<em>{k} A</em>{k}$垂直约束方程并指向可行域，如图中蓝点处所示。实际的迭代方向由这两个方向合成，使得参数向着目标函数下降方向，又逐渐靠近约束轨迹。当最终参数到达解的位置，也是时图中的红点处，约束轨迹与目标函数等高线相切，这两个梯度方向反相共线，也就是满足了KKT条件：$\nabla_{x}\mathcal{L}(x, \lambda)= \nabla f\left(x\right)- \lambda^T \nabla c\left(x\right) = 0$。</p>
<img src="/2020/04/22/6.%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/6.%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/1587653797241.png" class>
<h3 id="内点法优化"><a href="#内点法优化" class="headerlink" title="内点法优化"></a>内点法优化</h3><p>不等式约束下的优化求解比等式约束更加复杂，因为当$c(x)&gt;0$时，该约束实际不对目标函数产生影响，只有$c(x)=0$时，才真正起到约束作用。</p>
<p>内点法又称障碍函数法，它通过在目标函数中添加障碍项，来消去不等式约束，并通过迭代减小障碍权重，不断逼近最优解的方法。对于含有不等式约束的情况，考虑为优化问题添加一个参数向量$s$，并构造如下形式的优化问题：</p>
<script type="math/tex; mode=display">
\begin{array}{c}
\min _{x, s} f(x)-\mu \sum_{i=1}^{m} \ln s_{i} \\
\text { s.t. } \quad c_{\mathrm{E}}(x)=0 \\
c_{I}(x)-s=0
\end{array}</script><p>其中$\mu$是一个大于零的参数。我们用新增加的参数$s$与函数$c_{I}(x)$构成等式约束，来取代之前的不等式约束，由于采用了自然对数$\ln s$，因此$s$被限制严格大于0，因而约束函数$c_I(x)&gt;0$，同时当参数$s$接近0时，目标函数值会迅速增大，使得参数$s$无法减小。函数$\ln s$像是屏障一样限制的参数$s$的变化，因此被称为障碍函数法。这样构造出来的优化问题成为原问题的对偶问题。</p>
<p>还是考虑上面的例子，在原问题的基础上再增加一个$y\ge 3$的不等式约束。我们绘出对偶问题中$\mu =18$时的目标函数图像，如下所示。可以看出对偶问题的目标函数和原问题的目标函数存在很大的差异，且对偶问题的最优解$x^<em>_{dual}$也显然不同于原问题的最优解$x^</em>$。</p>
<img src="/2020/04/22/6.%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/6.%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/1587974512275.png" class>
<p>显然参数$\mu$会影响问题的解。当$\mu$越大时，$-\mu \sum<em>{i=1}^{m} \ln s</em>{i}$所占的比重也越大，因此参数$s$趋于增大，即约束函数$c_I(x)$趋于增大，表明参数$x$趋向于远离$c_I(x)=0$的边界。反之当$\mu$减小时，参数$x$才有可能靠近$c_I(x)=0$所表示的边界，但当$\mu_k \to 0$时，对偶问题会逐渐接近于原问题。</p>
<p>内点法通过构造一个$\mu$序列${\mu_k}$，使$\mu_k\to 0$，并在每个$\mu_k$上求解上述优化问题，求解结果作为下一次优化的初值，得到与${\mu_k}$对应解序列${x^<em>_k}$，且有$x^</em>_k\to x^*$，该解序列始终在原问题的可行域内，并逐渐靠近问题的最优解，因此也称为内点法。</p>
<img src="/2020/04/22/6.%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/6.%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/1587975500963.png" class>
<p>为了求解上面的优化问题，定义拉格朗日函数：</p>
<script type="math/tex; mode=display">
\mathcal{L}(x, s, y, z)=f(x) -\mu \sum_{i=1}^{m} \ln s_{i}-y^{T} c_{\mathrm{E}}(x)-z^{T}\left(c_{\mathrm{l}}(x)-s\right)</script><p>其中$x, s$为参数，$y, z$为拉格朗日乘子。对该函数使用牛顿法：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{cccc}
\nabla_{x x}^{2} \mathcal{L} & 0 & -A_{\mathrm{E}}^{T}(x) & -A_{I}^{T}(x) \\
0 & Z & 0 & S \\
A_{\mathrm{E}}(x) & 0 & 0 & 0 \\
A_{1}(x) & -I & 0 & 0
\end{array}\right]\left[\begin{array}{c}
d_{x} \\
d_{s} \\
d_{y} \\
d_{z}
\end{array}\right]=-\left[\begin{array}{c}
\nabla f(x)-A_{\mathrm{E}}^{T}(x) y-A_{I}^{T}(x) z \\
S z-\mu e \\
c_{\mathrm{E}}(x) \\
c_{I}(x)-s
\end{array}\right]</script><p>$A_E(x), A_I(x)$表示约束函数的梯度，定义$S$和$Z$为对角矩阵且其对角元素由向量$s$和$z$给出。</p>
<p>最后给出内点法的伪代码，算法分为外循环和内循环，外循环迭代障碍参数，内循环迭代问题参数：<br><img src="/2020/04/22/6.%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/6.%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/1587660896699.png" class></p>
]]></content>
      <categories>
        <category>仿真研究</category>
      </categories>
      <tags>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>IMU无线系统设计</title>
    <url>/2021/10/01/8.%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/IMU%E6%97%A0%E7%BA%BF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>在之前的博客中，已经对IMU的工作原理以及姿态结算方法进行了具体介绍，当时也设计了一个简单的有限姿态采集系统。在后来使用中发现，通过有线连接的IMU姿态采集系统，在运动过程中线缆连接处不可避免的会出现接触不良的情况，导致经常出现连接中断与数据丢失。因此在之前的基础上，设计了一套无线姿态传感系统，本文将主要介绍硬件设计的基本方案。</p>
<img src="/2021/10/01/8.%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/IMU%E6%97%A0%E7%BA%BF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/13.png" class>
<span id="more"></span>
<h2 id="无线IMU硬件设计"><a href="#无线IMU硬件设计" class="headerlink" title="无线IMU硬件设计"></a>无线IMU硬件设计</h2><p>无线IMU姿态测量模块主要有五部分组成：锂电池、锂电池充电管理模块、锂电池输出稳压模块、维特智能的JY901以及汇承的HC-12无线通信模块，系统结构框图如上所示。为了方便佩戴，该传感器计划设计成较小的尺寸体积，长宽初步定为20*30mm。</p>
<h3 id="IMU模块"><a href="#IMU模块" class="headerlink" title="IMU模块"></a>IMU模块</h3><p>这里采用维特智能研发的<a href="https://item.taobao.com/item.htm?spm=a1z09.2.0.0.e1362e8d1hfpCq&amp;id=43511899945&amp;_u=j2e2b4db30d7">九轴姿态传感器</a>，内部集成Kalman滤波，输出频率可达200Hz，支持串口和IIC接口，同时价格较低。同时基于WT931的无线IMU模块在后续计划中，其采样频率可达500Hz。由于模块支持串口数据输出，因此将其串口直接连接无线模块接受端，并将数据发送至上位机。</p>
<blockquote>
<p>由于无线模块不支持发送AT指令，因此不同通过无线传输的方式对IMU的基本参数进行设置，只能实现基本的数据传输。</p>
</blockquote>
<p><img src="/2021/10/01/8.%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/IMU%E6%97%A0%E7%BA%BF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/1605790727566.png" width="60%"></p>
<h3 id="无线通信模块"><a href="#无线通信模块" class="headerlink" title="无线通信模块"></a>无线通信模块</h3><p>无线通信模块采用汇承的<a href="https://item.taobao.com/item.htm?spm=a1z09.2.0.0.e1362e8d1hfpCq&amp;id=20265137304&amp;_u=j2e2b4db5c9c">HC-12</a>433M透传模块。在前期测试中发现，蓝牙通信在多机情况下不稳定，且通信距离较短；Wifi通信的通信延时不稳定。因此最终悬选择这款433M的无线透传模块，并且支持设置不同工作模式（低功耗、全速、远距）、不同的通信频道（0-999）。</p>
<blockquote>
<p>实际使用时需合理选择天线，同时通信频道最好间隔设置，即将通道设置为1,3,5,7,9…</p>
</blockquote>
<p><img src="/2021/10/01/8.%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/IMU%E6%97%A0%E7%BA%BF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/1605791843906.png" width="60%"></p>
<h3 id="锂电池型号选择"><a href="#锂电池型号选择" class="headerlink" title="锂电池型号选择"></a>锂电池型号选择</h3><p>所采用的锂电池为为市面上常见的<a href="https://detail.tmall.com/item.htm?id=43641125910&amp;spm=a1z09.2.0.0.e1362e8d1hfpCq&amp;_u=j2e2b4dbbd93">3.7V聚合物锂电池</a>，电池内部自带过充保护板。考虑了体积的限制，最终选择容量为260mAh。</p>
<p><img src="/2021/10/01/8.%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/IMU%E6%97%A0%E7%BA%BF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/1605786805794.png" width="60%"></p>
<h3 id="锂电池充电模块设计"><a href="#锂电池充电模块设计" class="headerlink" title="锂电池充电模块设计"></a>锂电池充电模块设计</h3><p>接下来为锂电池设计配套的充电模块。为方便充电，采用TypeC接头，充电芯片采用较为常用的<a href="https://atta.szlcsc.com/upload/public/pdf/watermark/20190926/C84051_A3C1A17BA2C9FBF3AD637A80C4632639.pdf">TP4056</a>，其主要参数如下：</p>
<img src="/2021/10/01/8.%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/IMU%E6%97%A0%E7%BA%BF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/1605787978387.png" class>
<p>管脚功能说明如下：<br><img src="/2021/10/01/8.%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/IMU%E6%97%A0%E7%BA%BF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/1605788045912.png" class><br><img src="/2021/10/01/8.%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/IMU%E6%97%A0%E7%BA%BF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/1605788079933.png" class></p>
<p>参考数据手册中的典型应用电路，设计如下的充电电路：<br><img src="/2021/10/01/8.%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/IMU%E6%97%A0%E7%BA%BF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/1605789032628.png" class><br>其中R4电阻需要根据电池容量来确定。锂电池的充电电流一般为电池容量的0.1~1.5倍，常规的充电电流为0.5倍电池容量。项目中由于需要对电池快速充电的需要，因此设计为接近1倍电池容量，充电电流与电阻R4的关系可由数据手册得到：</p>
<script type="math/tex; mode=display">
I_{BAT}=\frac{1200}{R_4}</script><h3 id="锂电池稳压模块设计"><a href="#锂电池稳压模块设计" class="headerlink" title="锂电池稳压模块设计"></a>锂电池稳压模块设计</h3><p>锂电池输出的电压会随电量的减少从4.2V降低到3.7V，在为传感器供电之前需要进行稳压。采用mini封装的<a href="https://atta.szlcsc.com/upload/public/pdf/source/20130730/1457706628575.pdf">RT9193</a>，将输出电压稳定在3.3<br><img src="/2021/10/01/8.%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/IMU%E6%97%A0%E7%BA%BF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/1605790101539.png" class></p>
<p><img src="/2021/10/01/8.%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/IMU%E6%97%A0%E7%BA%BF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/1605790250999.png" width="60%"></p>
<h3 id="原理图与PCB设计"><a href="#原理图与PCB设计" class="headerlink" title="原理图与PCB设计"></a>原理图与PCB设计</h3><p>将上面的几个部分结合在一起，同时增加一个开关，和一个用来调节JY901与HC-12连通的拨码开关，构成如下的原理图，并在此基础上设计了PCB电路。</p>
<img src="/2021/10/01/8.%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/IMU%E6%97%A0%E7%BA%BF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/1605792242432.png" class>
<img src="/2021/10/01/8.%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/IMU%E6%97%A0%E7%BA%BF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/1605792890624.png" class>
<img src="/2021/10/01/8.%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/IMU%E6%97%A0%E7%BA%BF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/1605794866241.png" class>
<h3 id="传感器外壳设计"><a href="#传感器外壳设计" class="headerlink" title="传感器外壳设计"></a>传感器外壳设计</h3><p>为了方便传感器的安装和穿戴，同时为传感器提供必要的保护，设计了无线IMU的3D保护外壳。外壳由两部分组成，并借助PCB上的定位孔对PCB进行固定；对部分位置进行镂空，方便充电\LED显示\开关调节。突起圆柱体部分为无线模块的外置天线。</p>
<img src="/2021/10/01/8.%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/IMU%E6%97%A0%E7%BA%BF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/1605796190829.png" class>
<img src="/2021/10/01/8.%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/IMU%E6%97%A0%E7%BA%BF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/Snipaste_2020-11-14_18-41-28.png" class>
<h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><img src="/2021/10/01/8.%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/IMU%E6%97%A0%E7%BA%BF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/1605792625091.jpg" class>
<img src="/2021/10/01/8.%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/IMU%E6%97%A0%E7%BA%BF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/1605878803930.jpg" class>
<hr>
<h2 id="无线IMU硬件测试"><a href="#无线IMU硬件测试" class="headerlink" title="无线IMU硬件测试"></a>无线IMU硬件测试</h2><p>对于所搭建的无线IMU系统，进行了一系列的硬件测试，包括充电测试、稳压测试、通信测试、续航测试等，其中通信测试过程中遇到的玄学问题较多，也有可能是源自我对通信方面的了解不是很多，因此这里单独进行分析。注意该无线IMU系统还配有另外制作的数据接收机，由HC-12和一个单片机构成，比较简单，因此本文不进行介绍。</p>
<h3 id="通信稳定性测试"><a href="#通信稳定性测试" class="headerlink" title="通信稳定性测试"></a>通信稳定性测试</h3><p>所采用的HC-12为433M频段的无线通信模块，在串口波特率为9600bps时通信距离可达600m。但所使用的JY901姿态传感器在9600波特率时采样频率较低，因此必须提高传输波特率。经测试，通过HC-12将JY901数据发送至上位机时，采样频率与串口波特率的关系如下：BuadRate为57600时，SampleRate最大为100Hz；BaudRate为115200时，SampleRate最大为200Hz；对于100Hz以下的采样率，无法满足基本的实验需要，因此不进行考虑。然而实际通信的过程中，有可能因为通信距离以及各种干扰使采样率达不到最大水平。我基本为零的通信知识告诉我，波特率越高，通信会越不稳定，因此需要在更高的采样率与更好的稳定性之间进行折中，因此对57600和115200两种波特率进行通信稳定性的对比测试。</p>
<p>通信测试采用一组三个IMU，分别在57600和115200波特率下，将传感器环绕实验室一周（实验室环境较为复杂，有较多金属箱体会对通信产生干扰），记录整个过程接收数据频率的变化，结果如下图所示，左图为57600，右图为115200。</p>
<img src="/2021/10/01/8.%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/IMU%E6%97%A0%E7%BA%BF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/IMU_Test_B57600_F100_M3_Freq.png" class>
<p>可以看出在115200波特率下，通信的确更不稳定，接收数据的频率最低达到110Hz，接收频率波动为45%；而57600波特率下最低接收频率为89Hz，接收频率波动为10%。因此若需要更稳定的数据通信，应选择波特率为57600，而考虑到115200波特率通信在实验环境下的最低接收频率也高于100Hz，因此最终还是讲通信波特率定为115200Hz。该配置下三个传感器的俯仰角数据接收情况如下图所示，数据较为平稳。</p>
<img src="/2021/10/01/8.%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/IMU%E6%97%A0%E7%BA%BF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/IMU_Test_B115200_F200_M3_Curve.png" class>
<h3 id="无线IMU系统性能参数"><a href="#无线IMU系统性能参数" class="headerlink" title="无线IMU系统性能参数"></a>无线IMU系统性能参数</h3><blockquote>
<ul>
<li>重量：145g</li>
<li>尺寸：26mmx37mmx14mm</li>
<li>续航时长：3.5h</li>
<li>充电时长：1h</li>
<li>采样频率：200Hz</li>
<li>通信距离：实验室内均可，空旷条件下待测试</li>
</ul>
</blockquote>
<h2 id="无线IMU数据导入OpenSim"><a href="#无线IMU数据导入OpenSim" class="headerlink" title="无线IMU数据导入OpenSim"></a>无线IMU数据导入OpenSim</h2><p>在OpenSim最新的4.1版本中，新增了OpenSense模块提供对IMU数据的支持，但官方例程仅提供对Xsens支持。在所制作的无线IMU系统之上，进一步将采集的数据转化为OpenSim所支持的形式，并进行逆运动分析。所设计的无线IMU系统包含7个IMU，分别安装在盆骨和两侧的大腿、小腿、足上，上位机接收7个IMU的加速度、角速度和欧拉角数据，但只有欧拉角数据在本部分会被使用。由于OpenSense提供的是对四元数数据的支持，所以需要做一些必要的转换。数据处理与转化的基本流程如下，基于Matlab的示例程序见<a href="./OpenSenceDemo.zip">附件</a>。</p>
<img src="/2021/10/01/8.%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/IMU%E6%97%A0%E7%BA%BF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/1607072414292.png" class>
<img src="/2021/10/01/8.%E5%8F%AF%E7%A9%BF%E6%88%B4%E4%BC%A0%E6%84%9F%E7%B3%BB%E7%BB%9F/IMU%E6%97%A0%E7%BA%BF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/120201204_162212.gif" class>]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>硬件开发</tag>
      </tags>
  </entry>
  <entry>
    <title>IMU原理与人体姿态检测</title>
    <url>/2021/02/28/1.IMU%E7%9A%84%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/1.IMU%E7%9A%84%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>最近做了一套基于IMU的人体姿态检测系统，用来取代动作捕捉系统。一方面IMU的实时性和可开发性比动捕要好，另一方面IMU成本很低的同时精度也足以满足需求。本文介绍IMU的基本原理与基于IMU的人体姿态检测系统的设计。</p>
<span id="more"></span>
<hr>
<h4 id="1-IMU的组成与原理"><a href="#1-IMU的组成与原理" class="headerlink" title="1.IMU的组成与原理"></a>1.IMU的组成与原理</h4><img src="/2021/02/28/1.IMU%E7%9A%84%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/1.IMU%E7%9A%84%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/1.bmp" class>
<p>IMU可根据DOF的不同来加以区分，其中6DOF的IMU和9DOF的IMU比较常见，6DOF的IMU一般由一个三轴加速度计和一个三轴陀螺仪组成。9DOF的IMU会多一个三轴磁力计。模块所能感知状态量的个数即为DOF大小，DOF越多、精度越高的IMU也就越贵。<br>这里只讨论6DOF的IMU。</p>
<h6 id="加速度计"><a href="#加速度计" class="headerlink" title="加速度计"></a>加速度计</h6><hr>
<p>顾名思义，三轴加速度计能感受三轴的加速度，如上图中三个矢量所示。但要注意的是，当图示模块水平放置且静止，z轴方向加速度大小为<code>-g</code>，也就是说IMU测量的加速度与物体真实加速度相差一个重力加速度。<br><img src="/2021/02/28/1.IMU%E7%9A%84%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/1.IMU%E7%9A%84%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/2.bmp" class><br>加速度计的物理实现是利用牛顿第二定律，如上图所示，中间红色物体为一个质量块，两头通过具有弹簧性质的长条结构与基底相连，红色的短栅与绿色的短栅分别为电容的极板。当基底在双箭头方向有加速度<code>a</code>时，由<code>f=ma=kx</code>，质量块会沿加速度相反的方向移动，红色极板与绿色极板之间的距离会发生变化，通过测量极板电容<code>C</code>的变化就可以得到加速度的大小。在三轴加速度计中，这样的结构在三个方向各有一个，且做到了微米的尺寸，并配合相应的测量电路集成在一个芯片中（如图一所示），构成一个微机电系统（MEMS）。</p>
<h6 id="陀螺仪"><a href="#陀螺仪" class="headerlink" title="陀螺仪"></a>陀螺仪</h6><hr>
<p>角速度测量的原理比加速度要复杂一些，因为涉及了科里奥里力(Coriolis Force)。所以我们先来说一下Coriolis Force。科里奥里力是由坐标系的转动与物体在动坐标系中的相对运动引起的，其本质是物体的惯性。</p>
<img src="/2021/02/28/1.IMU%E7%9A%84%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/1.IMU%E7%9A%84%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/3.bmp" class>
<p>如果图示模块置于绝对静止的坐标系中，当在x方向施加一个驱动力使质量块运动时，根据牛顿第二定律，质量块只会在x方向上运动，而在y方向上不会运动。</p>
<img src="/2021/02/28/1.IMU%E7%9A%84%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/1.IMU%E7%9A%84%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/4.bmp" class>
<p>但如果将图示模块置于一个旋转坐标系下，由于坐标系的旋转，使得当质量块沿x方向运动时，在y方向上会受到一个力，即科里奥里力<code>F=-2mvω</code>，从而使质量块沿y方向运动。地球上的很多自然现象，如热带气旋、季风带、河道两侧冲刷程度不同，都源于科里奥里力。</p>
<img src="/2021/02/28/1.IMU%E7%9A%84%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/1.IMU%E7%9A%84%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/5.bmp" class>
<p>陀螺仪的物理实现如上图所示，外侧的蓝色与黄色部分为驱动电极，内部的红色与蓝色为测量电极。在模块的驱动方向施加正弦驱动电压，当模块发生旋转时，质量块在垂直方向受科里奥里力影响也会产生一个正弦运动，且正弦运动的幅值与平台的角速度成正比，通过垂直方向的电极测量出此幅值，便可以得到模块角速度。与三轴加速度计一样，这样的结构在三轴陀螺仪的三个方向上各有一个，从而测量出三个方向的角速度。</p>
<h5 id="2-IMU姿态解算"><a href="#2-IMU姿态解算" class="headerlink" title="2. IMU姿态解算"></a>2. IMU姿态解算</h5><p>现在我们能够从IMU中得到三轴的加速度和三轴的角速度，接下来就要从这些数据中解算出三个方向的角度。实际上，单独由加速度计或陀螺仪都可以解算出三轴的角度。</p>
<h6 id="由加速度解算角度"><a href="#由加速度解算角度" class="headerlink" title="由加速度解算角度"></a>由加速度解算角度</h6><hr>
<img src="/2021/02/28/1.IMU%E7%9A%84%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/1.IMU%E7%9A%84%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/6.png" class>
<p>由于加速度计本质是测量力，所以在传感器静止的时候，测量的结果为重力加速度。当平台运动的加速度远小于重力加速度时，可认为传感器测量的结果全部为重力加速度，因此可以根据重力加速的在三轴分量的大小来解算出角度。</p>
<img src="/2021/02/28/1.IMU%E7%9A%84%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/1.IMU%E7%9A%84%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/7.png" class>
<p>以上图为例，传感器沿<code>y</code>方向倾斜的角度为：</p>
<script type="math/tex; mode=display">
Angle_{Accel} = arccos\frac{ax}{-g}</script><h6 id="由陀螺仪解算角度"><a href="#由陀螺仪解算角度" class="headerlink" title="由陀螺仪解算角度"></a>由陀螺仪解算角度</h6><hr>
<p>由角速度解算角度很容易理解，当知道陀螺仪的初始角度时，对角速度进行积分就可以得到角度值。</p>
<script type="math/tex; mode=display">
Angle_{Gyro}=Angle_0 + \int_0^t Gyro dt</script><h6 id="数据融合"><a href="#数据融合" class="headerlink" title="数据融合"></a>数据融合</h6><hr>
<p>现在我们可以从加速度和角速度分别解算出角度，但这两种方式都存在很大的问题。一方面由于加速度计容易受到振动的影响，噪声很大，所以解算角度的噪声也很大；另一方面虽然陀螺仪测量角速度的噪声不是很大，经过积分环节后噪声进一步被变小，但由于初始角度并不能准确得到，而且角速度存在零漂问题（即模块静止时角速度不完全为0，而是有一个偏置），经过积分后这个误差会被累积。<br>因此，两种方式解算出来的角度都无法直接使用，但我们可以采用数据融合的方法，把两种角度融合在一起，得到一个既没有累计误差、噪声又小的角度数据。</p>
<h6 id="互补滤波"><a href="#互补滤波" class="headerlink" title="互补滤波"></a>互补滤波</h6><hr>
<p>一阶互补滤波是最简单但却非常实用的数据融合算法，它把由加速度解算的角度和由角速度积分的角度按照一定比例加到一起，公式如下：</p>
<script type="math/tex; mode=display">
Angle = K\cdot Angle_{accel}+(1-K)\cdot (Angle + \omega\cdot dt)</script><p>其中参数<code>K</code>表示对加速度解算角度的置信程度，由于加速度的噪声很大，所以参数<code>K</code>一般很小，典型值为<code>0.05</code>，实际使用要根据效果来调整。</p>
<p>这样的互补滤波器可以看做是一个高通滤波和一个低通滤波的叠加：公式的第一项是为低通滤波部分，目的是滤除加速度的噪声；公式的第二项为高通滤波部分，目的是滤除角速度的直流偏置（零漂）。</p>
<h6 id="Kalman滤波"><a href="#Kalman滤波" class="headerlink" title="Kalman滤波"></a>Kalman滤波</h6><hr>
<p>互补滤波虽然简单实用易理解，但我们还有更好的算法来进行数据融合，比如Kalman滤波。关于Kalman滤波的原理，有一些非常好的论文和博客，感兴趣的同学可以移步这些网站:</p>
<p><a href="http://www.cs.unc.edu/~welch/kalman/media/pdf/Kalman1960.pdf">Kalman先生1960年的论文</a><br><a href="https://list.yinxiang.com/markdown/eef42447-db3f-48ee-827b-1bb34c03eb83.php">博客 How a Kalman filter works</a><br><a href="https://blog.csdn.net/u010720661/article/details/63253509">上篇博客的中文版</a><br><a href="https://courses.engr.illinois.edu/ece420/sp2017/UnderstandingKalmanFilter.pdf">论文 Understanding Kalman Filter</a><br><a href="https://www.jianshu.com/p/d3b1c3d307e0">上篇论文的中文版</a></p>
<p>Kalman滤波的原理稍过复杂，这里并不打算深入讨论。但由于博客和论坛上关于用Kalman滤波融合加速度计和陀螺仪数据的建模方法介绍比较少，所以这里给出本问题状态空间方程的建立方法。</p>
<p>和一般系统的建模方法不同，本问题中的状态变量不是角度和角速度，而是角度和角速度的偏置：</p>
<script type="math/tex; mode=display">
State = \begin{bmatrix} Angle(k)  \\ Gyro_{bias}(k) \\  \end{bmatrix}</script><p>状态空间模型考虑带控制量的形式，其中控制量为陀螺仪测量的角速度，观测方程中只有从加速度解算得到的角度，方程如下：</p>
<script type="math/tex; mode=display">
\begin{bmatrix} Angle(k+1)  \\ Gyro_{bias}(k+1)   \end{bmatrix} = \begin{bmatrix} 1 & -dt \\ 0 & 1   \end{bmatrix}\begin{bmatrix} Angle(k)  \\ Gyro_{bias}(k) \end{bmatrix} + \begin{bmatrix} dt \\ 0  \end{bmatrix} Gyro(k) + W(k)</script><script type="math/tex; mode=display">
Angle_{accel}(k) =\begin{bmatrix} 1 & 0  \end{bmatrix}  \begin{bmatrix} Angle(k) \\ Gyro_{bias}(k)  \end{bmatrix} + V(k)</script><p>其中矩阵<code>W</code>和<code>V</code>分别为输入噪声矩阵和观测噪声矩阵，这两个矩阵的参数需要根据情况进行调整。对于本问题矩阵<code>V</code>的参数要比<code>W</code>的参数大很多，因为由加速度计观测角度的噪声很大。</p>
<hr>
<h5 id="3-使用IMU来测量关节角度"><a href="#3-使用IMU来测量关节角度" class="headerlink" title="3.使用IMU来测量关节角度"></a>3.使用IMU来测量关节角度</h5><p>这里基于IMU设计了一套用来测量人体姿态的硬件，通过在身体每个肢段上放置一个IMU，测量每段肢体在空间中的姿态角，下位机使用单片机通过串口接收每个IMU模块的数据，然后通过CAN总线发送给上位机，上位机再解算出关节角度。制作的模块如下：</p>
<img src="/2021/02/28/1.IMU%E7%9A%84%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/1.IMU%E7%9A%84%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/8.jpg" class><img src="/2021/02/28/1.IMU%E7%9A%84%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/1.IMU%E7%9A%84%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/9.jpg" class>
<p>下图是测量大腿和小腿的数据，Matlab对接收的数据进行解算并实时显示出来。</p>
<img src="/2021/02/28/1.IMU%E7%9A%84%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/1.IMU%E7%9A%84%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/10.gif" class>
<p>下图是由IMU得到的行走状态下肢三关节的角度变化。初次实验采样频率设置的有点低，只有50HZ，所以波形看起来不太平滑。</p>
<img src="/2021/02/28/1.IMU%E7%9A%84%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/1.IMU%E7%9A%84%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/11.bmp" class>]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>硬件基础</tag>
      </tags>
  </entry>
  <entry>
    <title>下肢外骨骼系统简介</title>
    <url>/2021/11/20/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>可穿戴机器人是人类长久以来的梦想，它能够像衣服一样方便的穿戴在身体上。通过外骨骼的辅助，穿戴者能够实现原本难以实现或不可能实现的任务。根据设计目的和应用领域，外骨骼可主要分为三类：辅助外骨骼、康复外骨骼和增强型外骨骼。</p>
<img src="/2021/11/20/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/1606959581158.png" class title="|center">
<span id="more"></span>
<p>辅助外骨骼<code>Assistive Exoskeleton</code>通常用来弥补穿戴者已经丧失的能力，使其在辅助下能够完成基本的日常活动，其作用类似于假肢。例如对于脊髓损伤的患者，辅助外骨骼能够帮助他们重新行走。这类外骨骼较多采用位置控制策略，并且需要较高的控制精度，因为穿戴者完全没有运动能力；控制器中会预先设定好不同模式的运动轨迹，由穿戴者的运动意图触发，在不同的模式之间切换。</p>
<p>康复外骨骼<code>Rehabilitation Exoskeleton</code>通常用来帮助恢复穿戴者受损伤的能力，使穿戴者能最终能够不借助外骨骼完成基本的日常活动。这类外骨骼通常需要在线调整控制策略，使外骨骼仅在“需要”时进行辅助，并随着穿戴者能力的提升逐渐减小辅助。控制上也有部分预定义的运动轨迹，因为穿戴者在康复时需要正确的运动轨迹进行指引，同时控制系统也会根据穿戴者的实际反应进行调整。在康复外骨骼的设计中，尺寸重量便携性一般不作考虑，大部分康复外骨骼系统都是固定在跑步机上，并在医生监督下使用。</p>
<p>最后一类下肢外骨骼是用来增强人体能力<code>Augmentation Exoskeleton</code>，设计理念可以用一句话概括：<code>making the user superman.</code>增强型外骨骼通常装备在健康个体身上，因此预定义轨迹的策略不再适用，外骨骼大多跟随穿戴者的肢体运动，例如采用阻抗/导纳控制甚至基于正反馈的灵敏度放大控制。由于穿戴者本身具备运动能力，因此这类外骨骼通常采用非精确但有高能量密度的驱动器，如串联弹性驱动<code>SEA</code>、液压驱动等。</p>
<p>由于不同类别的外骨骼有着完全不同的目的，结构设计、控制策略都有所不同，接下来我们对每个类别的外骨骼进行简单讨论。</p>
<h2 id="辅助型外骨骼"><a href="#辅助型外骨骼" class="headerlink" title="辅助型外骨骼"></a>辅助型外骨骼</h2><img src="/2021/11/20/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/1606959610532.png" class title="|center">
<p>辅助外骨骼主要用于脊髓损伤<code>spinal cord injury(SCI)</code>患者。大部分胸椎级别的脊髓损伤患者永久失去了行走能力，只能通过轮椅进行移动。然而轮椅的可达范围是非常有限的，长时间保持坐立状态也会带来很多健康问题，例如压疮、骨结节、下肢骨密度降低等，因此需求一种能够帮助穿戴者保持直立并有良好移动性的辅助设备。</p>
<img src="/2021/11/20/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/1606960023906.png" class title="|center">
<p>辅助性外骨骼一般是采用层次控制器，实际上大部分外骨骼系统都是采用层次控制器。由于SCI患者完全失去了运动能力，因此基本上不需要考虑人机交互问题，外骨骼辅助能够使穿戴者完成基本运动即达到目标，因此辅助性外骨骼的控制通常采用位置控制策略。由于穿戴者没有运动能力，所以需要先识别出穿戴者的运动意图，如“前进”、“停止”等。除了额外的操作手柄外，目前商业化的辅助外骨骼较多采用IMU或足底压力数据来进行模式分类，这些信号在用于识别运动意图时有较好的效果，除此之外还有使用EMG信号和EEG信号来判断运意图，但都有一定的局限性，如个体差异、穿戴复杂等，甚至对于SCI患者，其下肢肌肉可能不存在EMG信号。</p>
<p>当意图识别完成后，上层控制器会根据任务目标生成相应的期望轨迹，这些轨迹往往是根据任务预先定义好的。由于人的步态运动有着支撑、摆动不同的阶段，每个阶段都有不同的动力学模型，因此上层控制器会经过有限状态机来判断当前的步态状态，然后在根据步态状态和任务需求来生成轨迹。底层控制器根据随设定的轨迹进行闭环控制，大部分采用PID，有时也会加入迭代学习来提高跟踪精度。</p>
<img src="/2021/11/20/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/1606960068092.png" class title="|center">
<p>辅助型外骨骼最大的挑战是保证人机系统的平衡，可以说现有的外骨骼系统基本没有做到完全意义上的平衡控制，像Ekso、ReWalk这样的商业外骨骼也都是搭配了拐杖进行辅助。MindWalker通过类似ZMP的方法来防止跌倒，但依然没有实现完全的自平衡。自平衡问题的难点来自于两部分：一是外骨骼系统欠驱动特性，人的每条腿有6个自由度，部分冗余的自由度提高了人类运动时的稳定性，但大部分外骨骼为了简化设计都选择忽略部分自由度，这种简化设计造成系统的欠驱动；另一方面，机器人领域中为实现双足机器人的步态运动需要对系统进行精确建模，但在外骨骼领域中现有的技术难以实现对人机系统参数的精确测量。</p>
<h2 id="康复外骨骼"><a href="#康复外骨骼" class="headerlink" title="康复外骨骼"></a>康复外骨骼</h2><p>康复外骨骼是用来帮助恢复穿戴者受损伤的能力，使穿戴者能最终能够不借助外骨骼完成基本的日常活动。对于脊髓损伤患者，其运动能力的丧失一般是由于神经回路的损伤，而脑卒中患者一般是由于部分脑区受到损伤。不同于人体的骨骼和肌肉，人的神经损伤是永久性的，一旦受损就没有复原的可能。但循证医学发现，在一些连接通路断了之后，通过大量的、重复的、高强度的训练，能够重新构建出新的连接通路，甚至是重新构建一些脑区的连接，这叫神经体统的可塑性<code>Neuroplasticity</code>。</p>
<img src="/2021/11/20/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/1606961554639.png" class title="Alt text">
<p>为了重建出新的连接来替代原来损伤的通路，需要进行大量的、重复的、高强度的神经康复训练<code>Neurorehabitation</code>。这样的康复训练往往需要多个理疗师来协助患者进行运动，康复的效果很大程度上取决于理疗师辅助的力量，对理疗师的体力有很高的要求。在中国，每年新增脑卒中患者200万，而现有的康复理疗师数量远远不能满足需要，所以我国的脑卒中致死率和致残率都远远高于美国和欧洲。因此使用康复外骨骼代替理疗师对患者进行康复训练成为了很大的需求。</p>
<img src="/2021/11/20/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/120201203_102740.gif" class title="Alt text">
<p>在康复外骨骼的设计中，尺寸重量便携性一般不作考虑，大部分康复外骨骼系统都是固定在跑步机上，并在医生监督下使用。因为和辅助型外骨骼一样没有很好的平衡控制策略，因此在躯干处会连接一些支撑结构以承担体重。康复外骨骼所面对的是运动能力较弱或有有障碍的患者，其具有一定的自主运动能力，因此辅助型外骨骼中的位置控制策略不再适用。实际上，康复外骨骼一大核心问题就是辅助的柔顺性，所谓的柔顺是指人机之间交互力应当是平稳连续且舒适的，而不是剧烈变化或大到难以承受。有两种方法增加柔顺，在人机之间增加弹簧，或是通过控制算法来模拟一种柔顺特性。例如当患者穿戴外骨骼进行步态运动时，控制器预先定义好一条关节轨迹，当患者的运动轨迹与设置轨迹完全重合时，外骨骼不提供辅助，而当患者的运动轨迹与预定轨迹偏离时，外骨骼提供辅助，偏离位置越大辅助力也越大，形式上如同在关节上施加了一个虚拟的弹簧，这样方法叫做阻抗控制。</p>
<img src="/2021/11/20/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/1606962702446.png" class title="Alt text">
<p>在康复外骨骼中，辅助并不是目的，目的是康复，需要让患者尽最大努力去参与到康复训练中。单纯采用阻抗控制方法容易使患者陷入一种被动的运动中，患者不再积极主动的进行训练，而是对辅助产生依赖。为了提高康复效果，辅助策略一般需要进行在线调整，仅在患者需要的时候进行辅助，并且随着患者的恢复逐渐降低辅助水平，这种策略叫做Assisted as Need。一般是通过定义一些目标函数，结合简化的人机交互模型，在维持运动目标的前提下最大化人体输出，或是最小化外骨骼输出。</p>
<img src="/2021/11/20/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/1606962724477.png" class title="Alt text">
<h2 id="增强型外骨骼"><a href="#增强型外骨骼" class="headerlink" title="增强型外骨骼"></a>增强型外骨骼</h2><img src="/2021/11/20/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/1606962804430.png" class title="Alt text">
<p>以上讨论的两种外骨骼都是面向有运动功能障碍的患者，增强型外骨骼的用户为健康人，通过外骨骼来增强或放大穿戴者的一些能力。增强型外骨骼主要存在两个分支，或者说是两种研究思路。第一种外骨骼是面向任务型的，可以让穿戴者在搬运重物的时候感受到的重量只有实际重量的十分之一，帮助护士去搬运病人或者是帮助士兵搬运弹药。这样的外骨骼必须是全下肢的，且主体为刚性结构，这样外部的负重才能够通过通过外骨骼结构传导到地面上，从而减轻人的负担。另一种是面向用户的，外骨骼仅辅助人体本身，多数情况下仅在部分关节施加辅助，其效果相当于给人增加了额外的肌肉，穿戴者依然需要自己需完成特定的任务，但在辅助下会轻松很多，但外界作用力最终还是需要经过人体。这一类外骨骼以Harvard大学Conor研究组的柔性外骨骼最为典型，可以做到轻型、便携、舒适。</p>
<img src="/2021/11/20/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/1606962871187.png" class title="Alt text">
<p>面向任务型的外骨骼有两款比较出名的设计，一个是美国的BLEEX，一个是日本的HAL。先来说一下伯克利下肢外骨骼，Kazerooni等人对BLEEX的定位是可移动负载搬运全下肢外骨骼，它将外骨骼上的负载重量通过外骨骼的机械结构传递到地面上，而让人感觉不到这些重量的存在，同时能够跟随人体运动。它的每条腿有4个驱动自由度，驱动方式为液压驱动，髋关节两个，膝关节和踝关节各一个，其余没有驱动的方向上均为被动自由度。</p>
<img src="/2021/11/20/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/1606962901455.png" class title="Alt text">
<p>在控制上，BLEEX的研究人员提出了一种灵敏度放大控制的方法，这种方法能够在不测量人机交互力的情况下使外骨骼能够跟随人体的运动。考虑一个单自由度的情况，外骨骼的机械结构受到驱动器和人体共同作用，我们用一个控制框图来表示，其中r表示驱动器的输出力矩，d表示人体的作用力矩，G和S分别是相应对于单自由度关节角速度的传递函数。对于典型的控制系统，我们一般是要设计负反馈控制，使系统保持稳定或跟随特定目标，这时人体对于外骨骼的作用力对控制系统而言是外部扰动，是控制系统需要克服的对象。在负反馈闭环系统下人体作用力矩到关节速度的传递函数Snew相对原来的S变小，从外骨骼的角度看，外骨骼更不容易受到人的影响，但从人体的角度来看，外骨骼变得铁板一块，没办法被控制。对于负载搬运外骨骼而言，其设计目的是为了让外骨骼跟随人体运动，让人感受不到外骨骼的存在，因此灵敏度放大控制将负反馈变成了正反馈，控制系统不再抑制扰动，而是放大扰动，新的传递函数也因此变大，人体更够更轻易的影响外骨骼。</p>
<p>说到这，学控制的同学可能坐不住了，这样一个正反馈系统怎么能够保证系统的稳定性呢？的确，这样的控制系统的确是不稳定的，但对于一个人机交互系统而言，不仅有外骨骼的控制回路，还有人体的控制回路，虽然控制系统不稳定，但如果人体能够控制的住外骨骼，那整个人机交互系统就是稳定的。也就是说，系统的稳定性取决于人体的平衡能力，人的平衡能力越强，那就可以设计更加不稳定的控制器，使人承受更多的重量，因此Kazerooni改用尼采的名言来描述这种方法，那些不稳定的，都使我们更加强大。</p>
<blockquote>
<p><strong>That which does not stabilize, will only make us stronger.</strong></p>
</blockquote>
<img src="/2021/11/20/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/1606963028047.png" class title="Alt text">
<p>但在实际系统中，外骨骼受到的扰动不仅来自穿戴者的运动意图，还有来自外界真正的干扰，比如说外骨骼被人踹了一脚。控制系统并不能分辨哪些扰动是人体的，哪些是外界的，因此一并进行了放大，因此穿戴者不仅需要去维持一个系统的稳定，还要去抵抗被放大了的外界扰动。天下没有免费的午餐，想要承担更多的重量，就必须花费更多的力气去维持系统稳定，甚至这些力气可能比减轻了的重量还多。在第二年他们又提出了混合控制的策略，在步态的摆动相采用灵敏度放大控制，支撑相采用角度控制。但在这种混合控制策略下，外骨骼的最高移动速度只有0.5m/s。</p>
<img src="/2021/11/20/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/1606963089953.png" class title="Alt text">
<p>与BLEEX几乎处于同一时期的外骨骼HAL，却采用完全不一样的控制思路。HAL的研究人员考虑能否从人体的神经系统中直接获得控制外骨骼的信号，就像控制人自身的肌肉一样来控制外骨骼。控制系统通过采集相关肌肉的肌电信号，经过滤波处理后乘以一个系数作为期望力矩，这种方法被称为比例肌电控制。这种方法的另一个意义在于，来自人体神经系统的肌电信号具有超前运动的特性，因此弥补控制系统的延时。当然这种方法的问题也很多，实际采集的肌电信号包含巨大的噪声，因此很难做到精确控制。另外这种肌电反馈的机制，必须存在肌电信号，才能产生力矩输出，没有肌电信号就没有外骨骼辅助，而肌电信号又包含巨大噪声，所以在这种控制策略下外骨骼无法实现完美辅助。</p>
<img src="/2021/11/20/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/1606963132997.png" class title="Alt text">
<p>这些全下肢的刚性外骨骼都有相同的特点，太过笨重，有的甚至达到了150Kg。这个世界物理法则使得越重的物体有越大的惯性，人们原本希望穿上外骨骼之后可以变身钢铁侠，但实际却变成了相扑运动员，完全丧失了原有的机动性。于是人们开始思考，这样的外骨骼有没有意义？外骨骼的研究向着单关节、轻型便携化的方向发展，并且以代谢耗能作为终极指标。由于生物力学表明在步态运动中踝关节有着最大的力矩输出与能量输出，因此大部分单关节外骨骼都集中在踝关节辅助上，但驱动方式各有不同，MIT采用SEA，密西根采用气动人工肌肉，CMU采用刚性框架加绳驱动，哈佛采用绳索驱动的完全柔性外骨骼。但无论是怎样的外骨骼，其最终只有一个目标 - 降低代谢耗能，此后10年一直到现在，增强型外骨骼的核心研究课题就是如施加辅助才能够使代谢耗能下降。</p>
<img src="/2021/11/20/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/1606963183136.png" class title="Alt text">
<p>最早在2007年，弗吉尼亚大学的Norris、密歇根大学的Ferris首先尝试了外骨骼辅助下代谢耗能的变化，之后13年根特大学的Philippe Malcolm第一次实现了外骨骼辅助下的代谢耗能下降，进一步CMU的Juanjuan Zhang与哈佛大学的Ding Ye用代谢耗能作为目标函数来优化固定步态运动下的辅助模式，也就是人在环中优化；到19年哈佛大学Conor Walsh研究组成功的在不同的运动中使外骨骼辅助降低人体的代谢耗能。</p>
<img src="/2021/11/20/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/1606964062826.png" class title="Alt text">
<p>除了主动施加合适的辅助来降低代谢消耗，一些脑洞清奇的研究人员考虑能不能设计一种外骨骼，从人体本身吸收能量，再反过来降低人体的代谢耗能。这种有点像永动机的想法背后，体现的是对人体运动消耗能量的思考，为什么轮子朝前滚的时候基本不需要消耗能量，而人两条腿朝前走的时候就需要消耗能量呢？研究人员提出不同模型去描述双足生物的行走过程，典型的有倒立摆模型和质点弹簧模型，这些模型解释了人体行走时能量消耗的原因。Collins分析了行走过程中肌肉收缩的机制，并在此基础上设计了只有弹簧和棘轮组成的完全被动的外骨骼，并使穿戴者的代谢耗能下降了7%。这项研究发表在Nature上是因为其证明了人体不是一个完全优化结构，至少在特定的运动下能够通过一些被动原件使人体的结构得到优化。但对于外骨骼领域而言，这样纯机械结构的被动外骨骼有着主动驱动式外骨骼无法比拟的可靠性。</p>
<p>经过几十年的发展，外骨骼技术的确取得了长足的进步，尤其是康复外骨骼已经展现的巨大的应用价值。但增强型外骨骼的道路依旧漫长，现有技术对于代谢耗能的下降仍不足以产生具有变革性的应用与产品。增强型外骨骼领域还需要更加深入的研究人机交互方法、人机协调控制方法，除了已展现的对力量和耐力的增强外，还需探讨如何通过外骨骼提高人体的机动性、敏捷性、平衡性，考虑外骨骼对于复杂环境的鲁棒性、对于穿戴者个体差异的适应性，这样才能诞生出真正有应用价值和社会意义的产品。最后希望外骨骼的研究者能够更多的去思考人道主义精神，减少文明之间碰撞与冲突的可能，用知识和技术去减少人类社会的苦难，增强人类探索未知世界的能力。愿我们的征途都是星辰大海。</p>
<hr>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>Lee H, Ferguson P W, Rosen J. Lower Limb Exoskeleton Systems—Overview[M]//Wearable Robotics. Academic Press, 2020: 207-229.</li>
<li>Esquenazi A, Talaty M, Packel A, et al. The ReWalk powered exoskeleton to restore ambulatory function to individuals with thoracic-level motor-complete spinal cord injury[J]. American journal of physical medicine &amp; rehabilitation, 2012, 91(11): 911-921.</li>
<li>Wang S, Wang L, Meijneke C, et al. Design and control of the MINDWALKER exoskeleton[J]. IEEE transactions on neural systems and rehabilitation engineering, 2014, 23(2): 277-286.</li>
<li>Cramer S C, Sur M, Dobkin B H, et al. Harnessing neuroplasticity for clinical applications[J]. Brain, 2011, 134(6): 1591-1609.</li>
<li>Emken J L, Bobrow J E, Reinkensmeyer D J. Robotic movement training as an optimization problem: designing a controller that assists only as needed[C]//9th International Conference on Rehabilitation Robotics, 2005. ICORR 2005. IEEE, 2005: 307-312.</li>
<li>Zoss A, Kazerooni H, Chu A. On the mechanical design of the Berkeley Lower Extremity Exoskeleton (BLEEX)[C]//2005 IEEE/RSJ international conference on intelligent robots and systems. IEEE, 2005: 3465-3472.</li>
<li>Kazerooni H, Racine J L, Huang L, et al. On the control of the berkeley lower extremity exoskeleton (BLEEX)[C]//Proceedings of the 2005 IEEE international conference on robotics and automation. IEEE, 2005: 4353-4360.</li>
<li>Kazerooni H, Steger R, Huang L. Hybrid control of the Berkeley lower extremity exoskeleton (BLEEX)[J]. The International Journal of Robotics Research, 2006, 25(5-6): 561-573.</li>
<li>Kawamoto H, Lee S, Kanbe S, et al. Power assist method for HAL-3 using EMG-based feedback controller[C]//SMC’03 Conference Proceedings. 2003 IEEE International Conference on Systems, Man and Cybernetics. Conference Theme-System Security and Assurance (Cat. No. 03CH37483). IEEE, 2003, 2: 1648-1653.</li>
<li>Mooney L M, Rouse E J, Herr H M. Autonomous exoskeleton reduces metabolic cost of human walking[J]. Journal of neuroengineering and rehabilitation, 2014, 11(1): 151.</li>
<li>Witte K A, Zhang J, Jackson R W, et al. Design of two lightweight, high-bandwidth torque-controlled ankle exoskeletons[C]//2015 IEEE International Conference on Robotics and Automation (ICRA). IEEE, 2015: 1223-1228.</li>
<li>Bae J, Siviy C, Rouleau M, et al. A lightweight and efficient portable soft exosuit for paretic ankle assistance in walking after stroke[C]//2018 IEEE International Conference on Robotics and Automation (ICRA). IEEE, 2018: 2820-2827.</li>
<li>Zhang J, Fiers P, Witte K A, et al. Human-in-the-loop optimization of exoskeleton assistance during walking[J]. Science, 2017, 356(6344): 1280-1284.</li>
<li>Ding Y, Kim M, Kuindersma S, et al. Human-in-the-loop optimization of hip assistance with a soft exosuit during walking[J]. Science Robotics, 2018, 3(15): eaar5438.</li>
<li>Kim J, Lee G, Heimgartner R, et al. Reducing the metabolic rate of walking and running with a versatile, portable exosuit[J]. Science, 2019, 365(6454): 668-672.</li>
<li>Collins S H, Wiggin M B, Sawicki G S. Reducing the energy cost of human walking using an unpowered exoskeleton[J]. Nature, 2015, 522(7555): 212-215.</li>
</ol>
]]></content>
      <categories>
        <category>exoskeleton</category>
      </categories>
      <tags>
        <tag>外骨骼系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Stanford下肢外骨骼系统设计控制与优化</title>
    <url>/2021/11/10/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/Stanford%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%8E%A7%E5%88%B6%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>下肢外骨骼能够提高士兵、急救人员、体力工人、老年人、肢体损伤患者的动能力。在前期研究中，Stanford大学的Steven H Collins（原卡内基梅隆大学）研究组已经设计了踝关节骨骼用于步态运动过程的辅助，并成功的降低了穿戴者的代谢耗能。在此基础上，该研究组进一步设计开发了髋-膝-踝三关节外骨骼系统，用于外骨骼辅助策略的探索。本篇博客将简要介绍该三关节外骨骼的设计、控制与优化。</p>
<p><img src="/2021/11/10/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/Stanford%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%8E%A7%E5%88%B6%E4%B8%8E%E4%BC%98%E5%8C%96/image-20210405104954391.png" alt="image-20210405104954391" style="zoom:50%;"></p>
<span id="more"></span>
<h2 id="外骨骼设计"><a href="#外骨骼设计" class="headerlink" title="外骨骼设计"></a>外骨骼设计</h2><p><img src="/2021/11/10/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/Stanford%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%8E%A7%E5%88%B6%E4%B8%8E%E4%BC%98%E5%8C%96/2.png" alt="image-20210405183442911" style="zoom:50%;"></p>
<p>该外骨骼系统依然是采用emulator方式，end-effector穿戴在人体上，能够为髋关节、膝关节的弯曲和伸展以及踝关节的跖屈提供力矩辅助，两侧共计十个驱动电机与人体分离，电机的辅助通过鲍登管进行传递。整个外骨骼的机械结构由躯干、大腿、小腿和足部四个部分组成，每个部分主要由矢状面上的碳纤维板和横向的铝合金/钛合金支撑，除了换踝关节部分以外，其余的横向连接件都采用管型设计，能够提供更高的弯曲强度和扭转强度，各个部分之间通过关节轴轴进行连接。</p>
<p><img src="/2021/11/10/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/Stanford%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%8E%A7%E5%88%B6%E4%B8%8E%E4%BC%98%E5%8C%96/image-20210405183442911.png" alt="image-20210405183442911" style="zoom:50%;"></p>
<p>躯干部分由后背X型的碳纤维支架和腰部框架组成，两者之间通过一个竖直的碳纤维板进行连接。X型的碳纤维支架用来连接肩部吊带和背部护垫，一方面将外骨骼的重量更均匀的分配，另一方面增加了躯干远端的接触能够提高外骨骼与人体之间交互柔顺性。</p>
<p>腰部框架由一个铝合金管和两侧的碳纤维板组成，碳纤维板的前部和后部分别由两个鲍登管的固定结构(图中的h)，这个固定结构包括三个部分：用来转换鲍登绳方向的滑轮，用来固定鲍登外管、同时防止鲍登绳脱落的黑色尼龙结构，以及用来防止鲍登管过度弯曲的白色弹性TPU护圈。碳纤维板的中下部安装的是外骨骼的髋关节轴，每个轴都由两个轴承来支撑，关节轴的外侧装有绝对式的磁编码器。</p>
<p><img src="/2021/11/10/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/Stanford%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%8E%A7%E5%88%B6%E4%B8%8E%E4%BC%98%E5%8C%96/image-20210405183522883.png" alt="image-20210405183522883" style="zoom:50%;"></p>
<p>大腿部分采用分体式设计，上部分碳纤维板连接髋关节，下部分连接膝关节，两块碳板之间通过一组孔进行固定，可以通过孔的位置来调整大腿部分的整体长度。来自腰部的鲍登绳在经过横向支撑管上的滑轮改变方向后，连接到垂直于碳纤维板的拉力传感器上。在前侧和后侧横向支架的中间，分别有用于膝关节弯曲于伸展辅助的鲍登管的固定端；在膝关节内侧有用来减缓碰撞的尼龙保护壳，外侧有安装磁编码器测量膝关节角度。</p>
<p><img src="/2021/11/10/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/Stanford%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%8E%A7%E5%88%B6%E4%B8%8E%E4%BC%98%E5%8C%96/image-20210405203009154.png" alt="image-20210405203009154" style="zoom:50%;"></p>
<p>小腿部分和大腿部分一样采用了分体式结构，通过调节连接孔的方式改变小腿部分的长度。在前侧的横向支架和后方的铝合金悬臂上装有拉力传感器(a, f)，分别测量膝关节弯曲与伸展辅助的辅助力。这两个拉力传感器都可以沿着安装轴旋转，使得测量方向始终与拉力方向共线，同时有额外的尼龙结构防止鲍登绳松弛时拉力传感器的过度旋转。</p>
<p><img src="/2021/11/10/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/Stanford%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%8E%A7%E5%88%B6%E4%B8%8E%E4%BC%98%E5%8C%96/image-20210405203138708.png" alt="image-20210405203138708" style="zoom:35%;"></p>
<p><img src="/2021/11/10/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/Stanford%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%8E%A7%E5%88%B6%E4%B8%8E%E4%BC%98%E5%8C%96/image-20210406084432773.png" alt="image-20210406084432773" style="zoom:50%;"></p>
<p>足部部分主体沿用了之前踝关节外骨骼的设计，但脚跟处的拉绳变为了刚性的碳纤维，碳纤维板通过一个铝合金悬臂连接到关节轴上，底部通过一个钢轴连接到鞋跟，同时前脚掌的碳纤维板也换为了钢轴。在踝关节轴的内侧同样增加了一个尼龙外壳以减轻两侧之间的碰撞。</p>
<h2 id="外骨骼驱动"><a href="#外骨骼驱动" class="headerlink" title="外骨骼驱动"></a>外骨骼驱动</h2><p><img src="/2021/11/10/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/Stanford%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%8E%A7%E5%88%B6%E4%B8%8E%E4%BC%98%E5%8C%96/3.png" alt="image-20210406103333588" style="zoom:50%;"></p>
<p>这套外骨骼的每条腿共有五个驱动自由度，以驱动作用在外骨骼上的角度来看，髋关节弯曲(flexion)辅助的鲍登线从腰部碳纤维板前侧连接到大腿碳纤维板前侧的支撑横架，再通过滑轮转向后垂直连接到大腿碳纤维板上，实际的辅助仅为腰部前侧碳纤维板到大腿前侧支撑横架这一段，通过滑轮转向仅为了方便拉力传感器的安装和测量。髋关节伸展辅助的鲍登线从腰部碳纤维板后部连接到大腿碳纤维板后方伸出的横向支架上，同样通过滑轮转向后连接到大腿碳纤维板。膝关节弯曲辅助的鲍登绳从大腿后方横向支架连接到小腿后方的横向支架上，伸展辅助则是由大腿前侧支撑横架连接到小腿前侧的横向支架。对于膝关节伸展辅助，通过合适的几何设计，使得当膝关节角度为零时，拉力作用线对膝关节轴的力臂也为零，从而提供保护作用。踝关节趾屈辅助则是和之前一样，通过小腿后方的横向支撑连接到足部后方的碳合金悬臂上。</p>
<img src="/2021/11/10/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/Stanford%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%8E%A7%E5%88%B6%E4%B8%8E%E4%BC%98%E5%8C%96/image-20210406091944324.png" class title="image-20210406091944324">
<p>外骨骼的机械结构通过脚上的靴子和身体各部分的绑带将外骨骼的辅助传递到人体上，设计时绑带上的作用力被设计为法向力，从而尽可能的为人体提供力矩辅助。为了降低人体与外骨骼之间的交互力，绑带被尽可能的佩戴在辅助关节的远端肢体上，比如对于髋关节辅助，大腿上靠近膝关节的绑带和躯干的肩带与背垫都有更长的力臂，从而降低绑带上的拉力。</p>
<p><img src="/2021/11/10/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/Stanford%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%8E%A7%E5%88%B6%E4%B8%8E%E4%BC%98%E5%8C%96/image-20210406103118884.png" alt="image-20210406103118884" style="zoom:50%;"></p>
<p><img src="/2021/11/10/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/Stanford%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%8E%A7%E5%88%B6%E4%B8%8E%E4%BC%98%E5%8C%96/image-20210406103333588.png" alt="image-20210406103333588" style="zoom:50%;"></p>
<p>整套外骨骼重13.5kg，其中机械部分仅重7.5kg，靴子和鲍登管都有比较大的重量。在9名测试者的穿戴实验中，1.25m/s的步态速度下，平均代谢耗能相对于不穿戴外骨骼增加了1.18W/kg，除去静态代谢，相当于增加了38.8%的代谢消耗。</p>
<p><img src="/2021/11/10/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/Stanford%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%8E%A7%E5%88%B6%E4%B8%8E%E4%BC%98%E5%8C%96/4.png" alt="image-20210406103333588" style="zoom:30%;"></p>
<p>研究人员将该外骨骼穿戴在铝合金框架上对外骨骼的结构性能进行了测试，其中髋关节弯曲、伸展，膝关节伸展，踝关节趾屈都能提供200Nm以上的力矩，膝关节弯曲辅助最大能提供140Nm的力矩。闭环带宽的结果存在一定的问题，但总体来说带宽都大于10Hz，表明系统能提供很好的力矩跟踪特性。</p>
<h2 id="外骨骼控制"><a href="#外骨骼控制" class="headerlink" title="外骨骼控制"></a>外骨骼控制</h2><p><img src="/2021/11/10/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/Stanford%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%8E%A7%E5%88%B6%E4%B8%8E%E4%BC%98%E5%8C%96/image-20210406114738373.png" alt="image-20210406114738373" style="zoom:50%;"></p>
<p>外骨骼系统采用了和之前相同的控制方法，控制器由上层力矩规划和底层的反馈控制组成。对于上层控制器，三个关节都有各自的期望力矩曲线，其中髋关节的辅助曲线和之前的定义完全一致，因此不在赘述。对于膝关节和髋关节外辅助，由于辅助力矩包含了弯曲和伸展两个方向，对于特定的方向，只有相应的辅助进行力矩控制，而与之相对的辅助采用跟随控制，从而使辅助在方向切换时能尽可能平滑。膝关节的辅助在步态前期到步态中期采用虚拟弹簧提供伸展力矩以模拟弹簧腿的特性，在支撑中期到支撑后期提供一个基于步态时间弯曲力矩。髋关节辅助在摆动末期到支撑初期提供伸展力矩，也就是后面的鲍登绳提供拉力，在支撑中期到摆动中期提供弯曲辅助，也就是前侧的鲍登绳产生拉力，由于髋关节在步态开始时刻，也就是脚跟着地时刻，处于力矩辅助状态，为了避免可能出现的期望力矩跳变，髋关节期望力矩曲线定义步态周期的84%为起始时刻。</p>
<script type="math/tex; mode=display">
\begin{array}{c}
u(i, n)=K_{\mathrm{p}} \cdot e(i, n)+K_{\mathrm{v}} \cdot \dot{\theta}_{\mathrm{m}}(i, n)+u_{\mathrm{L}}(i+D, n) \\
u_{\mathrm{L}}(i, n+1)=\beta \cdot u_{\mathrm{L}}(i, n)+K_{\mathrm{L}} \cdot e(i, n)
\end{array}</script><p>底层控制器依然采用<strong>力矩误差反馈</strong>加<strong>电机角速度的阻尼注入</strong>再加<strong>迭代学习</strong>的方式，下图为多关节辅助时的力矩跟踪效果，其中膝关节辅助在虚拟阻抗阶段由于无法进行迭代学习，因此有较大的跟踪误差，髋关节辅助在力矩方向转换时也有一个明显的跟踪误差。跟踪误差的RMS为1.81Nm，约9%的峰值力矩。</p>
<img src="/2021/11/10/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/Stanford%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%8E%A7%E5%88%B6%E4%B8%8E%E4%BC%98%E5%8C%96/image-20210406144425976.png" class title="image-20210406144425976">
<h2 id="外骨骼辅助优化"><a href="#外骨骼辅助优化" class="headerlink" title="外骨骼辅助优化"></a>外骨骼辅助优化</h2><p>在这样的多关节下肢外骨骼平台上，我们最希望从中了解的就是多关节外骨骼的辅助效果。毫无疑问多关节辅助肯定比单关节辅助有更高的效益，但考虑到外骨骼自身结构、重量带来的负面影响，某些形式的单关节外骨骼辅助可能更有效率，因此Collins研究组在这套多关节外骨骼上采用人在环中优化方法对不同关节组合辅助进行了对比。</p>
<p><img src="/2021/11/10/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/Stanford%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%8E%A7%E5%88%B6%E4%B8%8E%E4%BC%98%E5%8C%96/image-20210406220740906.png" alt="image-20210406220740906" style="zoom:50%;"></p>
<p>外骨骼三个关节的辅助力矩曲线与之前控制器中的力矩曲线形式基本一致。其中踝关节辅助依然是四个参数；髋关节辅助包括弯曲力矩和伸展力矩，每个部分都和踝关节的单峰辅助有相同的形式，因此有八个参数；膝关节辅助由虚拟刚度、时间力矩和虚拟阻尼三部分组成，时间力矩部分具有四个参数，虚拟刚度部分和虚拟阻尼部分各有三个参数，因此共有10个参数。三个关节一共有22个优化参数。</p>
<img src="/2021/11/10/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/Stanford%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%8E%A7%E5%88%B6%E4%B8%8E%E4%BC%98%E5%8C%96/image-20210407095126152.png" class title="image-20210407095126152">
<p>人在环中优化采用的依然是CMA-ES算法。受新冠病毒的影响，该项研究的受试者仅有三名，年龄从19岁到26岁，体重从60kg到90kg。人在环中优化实验分为三组，分别为单关节辅助优化，双关节辅助优化和三关节辅助优化，其中双关节辅助只有受试者P1进行。优化的时间长度可能影响最终的优化结果，因此P1受试者的优化实验进行了较长的时间，踝关节辅助优化了12代，可以在优化代数更新的中间中断休息，整个优化在3天内完成，但由于缺乏补充材料，并不清楚更具体的实验细节；髋关节、膝关节和三关节辅助优化进行了9代，双关节辅助优化进行了6代。在P1的基础上，受试者P2和P3优化的代数要小一些，更多细节在补充材料中，但每个受试者总的实验时间不小于50小时。</p>
<p>人在环中优化完成后，优化结果通过验证实验进行评估，其中静态站立6min，零力矩模式行走10min，每个辅助模式行走20min，实验中测量了受试者的代谢肌电和关节角度。</p>
<p><img src="/2021/11/10/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/Stanford%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%8E%A7%E5%88%B6%E4%B8%8E%E4%BC%98%E5%8C%96/image-20210407133156706.png" alt="image-20210407133156706" style="zoom:50%;"></p>
<p>代谢耗能的结果均以减去了站立时静态代谢，且都是以穿戴外骨骼无辅助模式进行对比。无外骨骼的代谢相对于穿外骨骼无辅助低22%，相当于穿戴外骨骼增加了28%的代谢消耗。在各种辅助策略下，代谢耗能均有一定程度的下降。单关节辅助而策略下，踝关节的辅助效益最明显，代谢下降30%，髋关节下降26%，膝关节下降13%且不显著。单受试者的双关节辅助优化结果表示，髋-踝组合辅助的效益最大，代谢耗能下降42%。在三关节辅助下，代谢耗能有50%的下降。无论是单关节辅助还是双关节的组合，膝关节辅助的作用相比另两个关节更不明显，这个优化辅助的结果与步态分析相一致，因为踝关节是行走过程产生能量最大的关节，髋关节次之，膝关节最小。在其他的步态运动中，例如上坡、上下台阶，膝关节辅助可能会起到更大的作用。另一方面，膝关节的优化参数是三个关节中最多的，不充分的优化可能是导致膝关节辅助效益较低的一个原因，后面的优化力矩结果会进一步说明。另外一个值得关注的是，单关节辅助比多关节辅助有更大平均效益，即三个关节单独辅助的代谢下降之和，要小于三关节共同辅助的代谢下降。由于关节之间存在耦合，辅助影响了行走的整个动力学过程，单关节辅助也会的对其他的关节产生影响，使得代谢有更大程度的下降。因此考虑到结构复杂性与外骨骼的附加重量，可能但关节外骨骼，或某些组合的双关节外骨骼，可能比全下肢外骨骼更有效率。</p>
<img src="/2021/11/10/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/Stanford%E4%B8%8B%E8%82%A2%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%8E%A7%E5%88%B6%E4%B8%8E%E4%BC%98%E5%8C%96/image-20210407140302142.png" class title="image-20210407140302142">
<p>不同辅助组合下优化的关节力矩如上图所示。其中踝关节和髋关节的辅助曲线，在不同的辅助组合下具有比较好的一致性。踝关节力矩在单关节辅助下有更大的力矩峰值，在多关节辅助下有更大的上升时间，且几种不同的组合下的优化力矩基本相同。髋关节力矩在在不同的辅助组合下，力矩峰值有明显差异，但峰值时间基本一致，其中髋-踝辅助时弯曲力矩峰值最大，髋-膝辅助时伸展力矩峰值最大，而三关节辅助时的力矩峰值相对较小。膝关节辅助力矩的优化结果比较缺乏规律，尤其三关节优化的结果力矩比较小。一方面所设置的膝关节辅助曲线形式可能并不合适，目前对于膝关节的辅助研究相比于踝关节和髋关节还不够充分；另一方面由于膝关节辅助的优化参数太多，算法容易收敛到局部极值，高维优化的效果可能并不理想。因此后面非常有必要探索影响膝关节辅助效果的核心参数，就像踝关节的峰值力矩峰值与峰值时间那样，并在更需要膝关节的步态运动中探索膝关节的辅助效益。</p>
]]></content>
      <categories>
        <category>exoskeleton</category>
      </categories>
      <tags>
        <tag>外骨骼系统</tag>
      </tags>
  </entry>
  <entry>
    <title>PCB-3D模型渲染全流程</title>
    <url>/2021/10/03/%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<blockquote>
<p>以LCEDA为PCB设计软件，将3D模型完美导出至SW并渲染</p>
</blockquote>
<img src="/2021/10/03/%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/IMU_Rendering.gif" class>
<span id="more"></span>
<h2 id="Step-1-LCEDA导出PCB文件至AD"><a href="#Step-1-LCEDA导出PCB文件至AD" class="headerlink" title="Step 1:  LCEDA导出PCB文件至AD"></a>Step 1:  LCEDA导出PCB文件至AD</h2><img src="/2021/10/03/%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/%E6%88%AA%E5%B1%8F2021-10-10_%E4%B8%8B%E5%8D%883.41.35.png" class>
<ul>
<li>截取顶/底层预览图（配置好板子颜色）</li>
</ul>
<p><img src="/2021/10/03/%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/截屏2021-10-10_下午3.44.47.png" style="zoom: 45%;"><img src="/2021/10/03/%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/截屏2021-10-10_下午3.44.54.png" style="zoom: 45%;"></p>
<h2 id="Step-2-AD导入PCB文件"><a href="#Step-2-AD导入PCB文件" class="headerlink" title="Step 2:  AD导入PCB文件"></a>Step 2:  AD导入PCB文件</h2><img src="/2021/10/03/%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/%E6%88%AA%E5%B1%8F2021-10-10_%E4%B8%8B%E5%8D%883.54.39.png" class>
<ul>
<li>选中外边框，设置为PCB板的外形</li>
</ul>
<p><img src="/2021/10/03/%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/截屏2021-10-10_下午3.56.08.png" style="zoom:200%;"></p>
<ul>
<li>生成PCB库</li>
</ul>
<img src="/2021/10/03/%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/%E6%88%AA%E5%B1%8F2021-10-10_%E4%B8%8B%E5%8D%883.57.14.png" class>
<ul>
<li>进入PCB library(左下角)，为元件添加3D模型</li>
</ul>
<img src="/2021/10/03/%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/%E6%88%AA%E5%B1%8F2021-10-10_%E4%B8%8B%E5%8D%886.08.19.png" class>
<p><img src="/2021/10/03/%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/截屏2021-10-10_下午6.06.55.png" style="zoom:19%;"><img src="/2021/10/03/%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/截屏2021-10-10_下午6.07.30.png" style="zoom: 19%;"><img src="/2021/10/03/%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/截屏2021-10-10_下午6.07.39.png" style="zoom:19%;"></p>
<blockquote>
<p>推荐两个优秀的模型下载网站：<br><a href="https://grabcad.com/">https://grabcad.com/</a> (科学)<br><a href="https://www.3dcontentcentral.cn/">https://www.3dcontentcentral.cn/</a></p>
</blockquote>
<ul>
<li>更新PCB</li>
</ul>
<img src="/2021/10/03/%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/%E6%88%AA%E5%B1%8F2021-10-10_%E4%B8%8B%E5%8D%886.08.59.png" class>
<ul>
<li>设置PCB板厚度</li>
</ul>
<img src="/2021/10/03/%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/%E6%88%AA%E5%B1%8F2021-10-10_%E4%B8%8B%E5%8D%886.11.46.png" class>
<img src="/2021/10/03/%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/%E6%88%AA%E5%B1%8F2021-10-10_%E4%B8%8B%E5%8D%888.16.35.png" class>
<h2 id="Step-3-导出AD文件至SW"><a href="#Step-3-导出AD文件至SW" class="headerlink" title="Step 3:  导出AD文件至SW"></a>Step 3:  导出AD文件至SW</h2><ul>
<li>AD导出<code>.x_t</code>格式文件，导出设置中选择不导出铜皮</li>
</ul>
<img src="/2021/10/03/%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/%E6%88%AA%E5%B1%8F2021-10-10_%E4%B8%8B%E5%8D%886.12.44.png" class>
<img src="/2021/10/03/%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/Untitled.png" class>
<ul>
<li>SW打开<code>.x_t</code>格式文件，并保存为装配体</li>
</ul>
<img src="/2021/10/03/%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/%E6%88%AA%E5%B1%8F2021-10-10_%E4%B8%8B%E5%8D%886.18.08.png" class>
<ul>
<li>将PCB板设置为灰色</li>
</ul>
<img src="/2021/10/03/%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/%E6%88%AA%E5%B1%8F2021-10-10_%E4%B8%8B%E5%8D%886.22.32.png" class>
<img src="/2021/10/03/%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/%E6%88%AA%E5%B1%8F2021-10-10_%E4%B8%8B%E5%8D%886.23.24.png" class>
<ul>
<li>为PCB的顶面和底面添加纹理（贴图）</li>
</ul>
<img src="/2021/10/03/%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/%E6%88%AA%E5%B1%8F2021-10-10_%E4%B8%8B%E5%8D%886.24.05.png" class>
<img src="/2021/10/03/%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/%E6%88%AA%E5%B1%8F2021-10-10_%E4%B8%8B%E5%8D%886.25.06.png" class>
<ul>
<li>编辑纹理属性</li>
</ul>
<img src="/2021/10/03/%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/%E6%88%AA%E5%B1%8F2021-10-10_%E4%B8%8B%E5%8D%886.26.00.png" class>
<ul>
<li>在属性中选择高级模式，并选择之前保存的图像</li>
</ul>
<img src="/2021/10/03/%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/%E6%88%AA%E5%B1%8F2021-10-10_%E4%B8%8B%E5%8D%886.26.58.png" class>
<ul>
<li>在映射中将图片大小改为PCB的实际尺寸</li>
</ul>
<img src="/2021/10/03/%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/%E6%88%AA%E5%B1%8F2021-10-10_%E4%B8%8B%E5%8D%886.28.17.png" class>
<ul>
<li>其中一面贴图还需要设置为水平镜像</li>
</ul>

<h2 id="Step-4-SolidWorks-Visualize渲染"><a href="#Step-4-SolidWorks-Visualize渲染" class="headerlink" title="Step 4:  SolidWorks Visualize渲染"></a>Step 4:  SolidWorks Visualize渲染</h2><ul>
<li>在Visualize中新建项目并导入模型（由<code>.x_t</code>生成的为装配体模型）</li>
</ul>
<img src="/2021/10/03/%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/%E6%88%AA%E5%B1%8F2021-10-10_%E4%B8%8B%E5%8D%886.47.16.png" class>
<ul>
<li>根据需求调整材质颜色与属性</li>
</ul>
<img src="/2021/10/03/%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/%E6%88%AA%E5%B1%8F2021-10-10_%E4%B8%8B%E5%8D%886.49.06.png" class>
<ul>
<li>根据需求调整环境与背板</li>
</ul>
<img src="/2021/10/03/%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/%E6%88%AA%E5%B1%8F2021-10-10_%E4%B8%8B%E5%8D%886.50.51.png" class>
<ul>
<li>根据需求相机位置与姿态</li>
</ul>
<img src="/2021/10/03/%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/%E6%88%AA%E5%B1%8F2021-10-10_%E4%B8%8B%E5%8D%886.55.01.png" class>
<ul>
<li>进行渲染</li>
</ul>
<img src="/2021/10/03/%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91/%E7%AB%8B%E5%88%9BEDA%E7%9A%843D%E6%B8%B2%E6%9F%93/EB_MotorCOM.jpg" class>
<blockquote>
<p>Reference：</p>
<ol>
<li><a href="https://www.bilibili.com/read/cv6758801/">https://www.bilibili.com/read/cv6758801/</a></li>
<li><a href="https://blog.csdn.net/hxkrrzq/article/details/99180230">https://blog.csdn.net/hxkrrzq/article/details/99180230</a></li>
<li><a href="https://blog.csdn.net/huadaoyingmu/article/details/99985021">https://blog.csdn.net/huadaoyingmu/article/details/99985021</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>tutorials</category>
      </categories>
      <tags>
        <tag>硬件开发</tag>
      </tags>
  </entry>
  <entry>
    <title>阻抗控制</title>
    <url>/2020/12/02/9.%E9%98%BB%E6%8A%97%E6%8E%A7%E5%88%B6/%E9%98%BB%E6%8A%97%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<p>Hogan的三篇阻抗控制论文算是阻抗领域的经典之作，其最大贡献在于突破了原有的位控、力控的单一性，将位置、力的动态关系作为控制目标，非常适合需要与环境进行交互的控制。</p>
<p>根据个人浅显的理解，对论文进行一点总结。</p>
<img src="/2020/12/02/9.%E9%98%BB%E6%8A%97%E6%8E%A7%E5%88%B6/%E9%98%BB%E6%8A%97%E6%8E%A7%E5%88%B6/Interaction.png" class>
<span id="more"></span>
<hr>
<h2 id="Part-I-Theory"><a href="#Part-I-Theory" class="headerlink" title="Part I Theory"></a>Part I Theory</h2><p>当我们谈到interaction的时候，我们主要关注交互过程的运动和力，以及两者的乘积-交互过程的能量流动。在一些情况下，交互过程能量流动可以被近似忽略，而交互控制也因此可以被简化。例如在交互力很小的情况下（例如喷涂），可以采用纯位置控制；在作用力方向上没有位移的情况下（例如焊接），可以采用力位混合控制。在余下大部分的情况下，交互过程往往都伴随着能量的转移，这时候单一的控制量（位置、速度、交互力）就不足以控制交互过程能量流动。</p>
<p>这个问题的一个解决方法是，控制操纵器的动态行为。如果将环境视作为操纵器的扰动，通过调节操纵器对扰动的响应则可实现对于动态行为的控制。这种调节不是通过动态调整控制器的参数（如改变pid的参数），而是通过探索物理交互的本质特性来实现的。</p>
<p><img src="/2020/12/02/9.%E9%98%BB%E6%8A%97%E6%8E%A7%E5%88%B6/%E9%98%BB%E6%8A%97%E6%8E%A7%E5%88%B6/Impedance_Example.jpg" width="60%"></p>
<p>借用<a href="https://www.zhihu.com/question/43633361/answer/124417009">知乎邵天兰</a>关于机械臂开门的例子来做一个形象的解释。假定让机械臂去完成开门这个动作，由于门框的轴对门板产生了一定的运动学约束，门板的末端只能按照固定的轨迹进行运动。当采用完全的位置控制时，由于机械的规划轨迹和门的轨迹不可能做到完全一致（定位误差、传感器精度等诸多限制），这些偏差会使得门板和机械臂之间产生巨大的交互力；而若采用完全的力控，门板正常转动时的交互力又很小，很难实现较为准确的开门角度；因此必须要同时考虑位置和力的共同影响，才能较好的实现开门这个动作。实际上这样一个简单又复杂的问题，可以通过在机械臂末端添加一个弹簧来解决，机械臂采用位置控制时，弹簧的柔顺性使得即便存在一定的位置误差也不会产生很大的交互力。而阻抗控制，就是通过控制算法使机械臂表现出这样的弹簧行为。</p>
<h3 id="物理等效性"><a href="#物理等效性" class="headerlink" title="物理等效性"></a>物理等效性</h3><p>操纵器是是物理硬件（机械结构、传感器、驱动器）和软件算法（控制程序）集合而成。一个统一的框架应当将硬件和软件一同纳入其中。在Hogan的观点中，硬件和软件共同作用下的操纵器，在与环境的交互中应当表现正常物理系统应当具有的特性，也就是说，<strong>软件部分所代表的控制器，也应当具有适当的物理特性</strong>：</p>
<blockquote>
<p><strong>It is impossible to devise a controller which will cause a physical system to present an apparent behavior to its environment which is distinguishable from that of a purely physical system. </strong></p>
</blockquote>
<p>这就是阻抗控制最核心的思想，控制器不再是一个完全虚拟的概念，而是可以等效为一定物理模型，具有一定的物理特性。从另一角度来说，控制器不再是任意设计的，而受到一定的物理特性的约束。在此基础上，Hogan进一步对交互过程的两种方式，impedance和admittance，进行进一步阐述。</p>
<h3 id="因果关系"><a href="#因果关系" class="headerlink" title="因果关系"></a>因果关系</h3><p>在任意一个运动的自由度上，瞬时功率都由两项相乘而得：effort（例如力、电压）和flow（例如速度、电流）。任何一个物理系统在任意一个时刻都只能控制着两者中的一个，而不能控制两者全部（Hogan在这里更主要的是强调单自由度-单输入单输出的情况，最优控制问题也并未与此矛盾）。</p>
<p>因此从交互的能量视角出发，物理系统可以看做只存在两种类型：admittance和impedacne，其中admittance接受effort而产生flow，而impedance接受flow而产生effort，这两者有点类似于电学系统中的电阻和电导。但不同于电学系统，admittance和impedance一般是不能互换的，例如是因为速度而产生的摩擦力，而不能说是因为摩擦力而产生了速度。这种非相互转化的特性是因果关系的体现，对于一个确定的物理关系而言，例如$F=ma$，尽管从数学上可以从右到左去表达，但实际物理系统只能从左到右与产生。这种因果关系表明，对于任意一个物理系统，它只能被描述为admittance或impedance中确定的一种特性（这种确定应当是相对的）。</p>
<blockquote>
<p><strong>The most important consequence of dynamic interaction between two physical systems is that one must physically complement the other: Along any degree of freedom, if one is an impedance, the other must be an admittance and vice versa.</strong></p>
</blockquote>
<p>在交互过程中我们希望交互过程可以表现的比较柔顺“compliance”，交互力的变化比较平滑。为实现柔顺交互，进行交互的两个物理系统必须是物理互补的，即其中一个若表现出admittance，另一个则必须为impedance。在非互补的两种情况下，可能会导致非柔顺的交互过程（admittance-admittance），或者物理不可实现（impedance-impedance）。</p>
<p>对于大部分的操纵任务而言，其环境多少会包含惯性约束或运动学限制，这样的环境接收力的输入，然后产生运动响应（当然也可能没有运动），这样的物理特性只能看做是admittance。因此，与这样的环境进行交互时，操纵器必须表现出impedance，才能实现柔顺交互。</p>
<p>接下来进一步讨论如何将impedance和admittance用物理模型和数学方法进行表示。由于Hogan的论文中较多的是文字描述，公式较少，且采用的bond graphs也不为控制领域所熟悉，因此下一部分将主要参考Unified Impedance and Admittance Control以及Modern Robotics - Mechanics, Planning, and Control中的内容进行介绍。</p>
<h2 id="Part-II-Algorithm-and-Implementation"><a href="#Part-II-Algorithm-and-Implementation" class="headerlink" title="Part II Algorithm and Implementation"></a>Part II Algorithm and Implementation</h2><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>考虑一个非常简单的单自由度惯性系统，系统的动力学方程可以表示为如下形式：</p>
<script type="math/tex; mode=display">
m\ddot{x} = F+ F_\mathrm{ext} \quad\quad(1)</script><p>$F_\mathrm{ext}$表示环境提供的交互力，注意这个公式是对于真实系统的建模，对于复杂的交互系统可以建立更加复杂的模型。</p>
<p>无论是impedance control还是admittance control，其控制算法的设计目的都是通过控制操纵器的输出力$F$，使得外部力$F_\mathrm{ext}$与期望位置偏差$e=x-x_0$能够满足一定的关系，或者说外部力在与操纵器进行交互的时候具有一定的物理特性，如下图所示。区别于上面的动力学方程，这种物理特性是虚拟出来的，没有实际物理存在。一般来说，较多的采用二阶模型：</p>
<img src="/2020/12/02/9.%E9%98%BB%E6%8A%97%E6%8E%A7%E5%88%B6/%E9%98%BB%E6%8A%97%E6%8E%A7%E5%88%B6/Interaction.png" class>
<script type="math/tex; mode=display">
M_d \ddot{e}+D_d \dot{e}+K_de=F_{\mathrm{ext}} \quad\quad(1)</script><p>式中$M_d$，$D_d$，$K_d$分别表示期望惯性、阻尼、刚度。在这样的关系下，外部力在与操纵器交互的时候，就像是在推动一个有阻尼、弹簧连接的质量块一样。由于这样一个关系是完全虚拟出来的，因此式中的三个参数可以任意调整。其中，刚度参数$K_d$是最重要的，也是最主要调节的参数，它反映操纵器的刚度大小，直接决定操纵器在与环境接触吋是呈现刚性还是柔性。一般来说，减小$K_d$会使机械手与环境的接触力变小，增大则会使机械臂与环境的接触力变大。阻尼参数$D_d$的增大或减小一般不会使接触力的稳定值变化，但可以调节操纵臂与环境交互的动态过程。一般来说，增大$D_d$会使力响应的超调减小，交互力的峰值显著下降，但过大的阻尼会使力响应过程变慢。惯性参数$M_d$一般不需要进行调节，但需要根据任务适当的进行选取。当这三个参数有任意一个的值较大时，我们其称为high impedance；若三个参数都很小时，称为low impedance。</p>
<p>进一步，可以对上式进行Laplace变换：</p>
<script type="math/tex; mode=display">
(M_ds^2+D_ds+K_d)E(s)=F_\mathrm{ext}(s)</script><p>由此可以通过位置扰动到外部力的传递函数来定义impedance：$Z(s)=F_\mathrm{ext}(s)/E(s)$，这样impedance就是一个与频率相关的概念，低频时的响应主要由弹性项决定，而高频时的响应主要由惯性项决定；而admittance就可以定义为impedance的逆：$Y(s)=z^{-1}(s)=X(s)/F(s)$。</p>
<p>一个好的位置控制器应当是high impedanc - low admittance，由于$E(s)=Y(s)F_\mathrm{ext}(s)$，来自外部力的扰动才能较小的影响位置；同理好的力控制应当是low impedance - high admittance，外部位置的扰动对力的影响才会比较小。从这一点来说，无论是位置控制还是力控制，都可以看做是阻抗控制的特例，是阻抗为无穷大和无穷小下的具体实现。</p>
<h3 id="Impedance-Control"><a href="#Impedance-Control" class="headerlink" title="Impedance Control"></a>Impedance Control</h3><p>由于impedance的性质是接受flow而产生effort，因此一个impedance controller应当是以位置信息作为输入，以力的信息（关节力矩）为输出。考虑公式（1）与公式（2），得到如下的impedance控制系统：</p>
<script type="math/tex; mode=display">
F=m\ddot x - \left( M_d \ddot{e}+D_d \dot{e}+K_d e \right) \quad\quad(3)</script><img src="/2020/12/02/9.%E9%98%BB%E6%8A%97%E6%8E%A7%E5%88%B6/%E9%98%BB%E6%8A%97%E6%8E%A7%E5%88%B6/1606305246402.png" class>
<p>有时候公式（3）中的加速度，包括$\ddot x$和$\ddot e$，比较难测量，可以通过测量$F_{ext}$来进行简化：</p>
<script type="math/tex; mode=display">
F=\left(\frac{m}{M_d}-1\right) F_{\mathrm{ext}}+m \ddot{x}_{0}-\frac{m}{M_d}\left(D_d \dot{e}+K_d e\right) \quad\quad(4)</script><img src="/2020/12/02/9.%E9%98%BB%E6%8A%97%E6%8E%A7%E5%88%B6/%E9%98%BB%E6%8A%97%E6%8E%A7%E5%88%B6/1606306619679.png" class>
<h3 id="Admittance-Control"><a href="#Admittance-Control" class="headerlink" title="Admittance Control"></a>Admittance Control</h3><p>admittance接受effort而产生flow，因此admittance controller应当是以测量的交互力作为输入，以位置指令作为输出。一种简单的实现方法可以通过计算期望的加速度来得到：</p>
<script type="math/tex; mode=display">
M_d \ddot{e}_d+D_d \dot{e}+K_de=F_{\mathrm{ext}}</script><script type="math/tex; mode=display">
\ddot{x}_d =  \ddot{x}_\mathrm{0} +\frac{1}{M_d}(F_{\mathrm{ext}}-D_d \dot{e}-K_d e ) \quad\quad(5)</script><img src="/2020/12/02/9.%E9%98%BB%E6%8A%97%E6%8E%A7%E5%88%B6/%E9%98%BB%E6%8A%97%E6%8E%A7%E5%88%B6/1606308814888.png" class>
<hr>
<p>这两种控制方式各有利弊，可以看出impedence control方法可以不用测量交互力的数据，但需要知道系统的动力学模型，这种方法在与环境交互的时候稳定性（柔顺性）比较好的，但无接触时实际上为开环系统，位置控制精度受制于建模精度；admittance control方法不需要进行系统动力学建模，在伺服任务中有较高位置精度，但与同样是admittance的环境交互时柔顺性较差，系统容易不稳定。</p>
<p>在实际的使用中，impedance/admittance control的实现方式远不止上面几种，根据系统的硬件结构、测量数据、反馈信号、工作空间的不同，可以设计各种形式的impedance controller。以机械臂为例，我们可以将机械末端笛卡尔坐标系下的阻抗模型通过雅克比矩阵转化到关节空间下进行实现：</p>
<script type="math/tex; mode=display">
\tau=J^{\mathrm{T}}(\theta)\left(\underbrace{\tilde{\Lambda}(\theta) \ddot{x}+\tilde{\eta}(\theta, \dot{x})}_{\text {arm dynamics compensation }}-\underbrace{(M \ddot{x}+B \dot{x}+K x)}_{f_{\text {ext }}}\right)</script><p>以上就是Impedance Control在控制领域的具体实现。实际上Impedance的概念可以应用到诸多领域，下面一部分将主要介绍Impedance与人体运动。</p>
<h2 id="Part-III-Impedance-and-Human-Movement"><a href="#Part-III-Impedance-and-Human-Movement" class="headerlink" title="Part III - Impedance and Human Movement"></a>Part III - Impedance and Human Movement</h2><p>人体的运动系统是这世界上最神奇的事物之一。在神经肌肉骨骼的共同作用下，人类得以实现无比丰富而复杂的动作，得以使用和制作各种工具，从而由古猿进化为智人，进化为这颗星球上最具智慧的生命。人体的运动千变万化，既有舞蹈那般的优雅流畅，又有雕刻那样准确精细；既有举重那般爆发力量，又可如武术那样灵巧迅捷。千百年来，人们试图去理解人体运动的本质，理解神经系统运动控制的机制，从而实现更加拟人的机器人运动与人类相协同，从而设计更智能的假肢帮助残疾人恢复运动功能。Impedance就是这样一种理解人体运动的方式。</p>
<img src="/2020/12/02/9.%E9%98%BB%E6%8A%97%E6%8E%A7%E5%88%B6/%E9%98%BB%E6%8A%97%E6%8E%A7%E5%88%B6/Muscle.png" class>
<p>人体的运动系统由神经-肌肉-骨骼共同构成，神经信号刺激肌肉收缩，肌肉收缩带动骨骼运动。尽管人体的肌肉并不是能量保守的，但却具有很明显的阻抗特性，Hill肌肉模型就是将肌肉表示为收缩单元与串联弹簧与并联弹簧的组合，人体的驱动器-肌肉本身就类似于SEA；而用来表示肌肉收缩动力学的力-长度与力-速度关系，则可以看作是阻抗控制中的刚度参数和阻尼参数。</p>
<p>由于肌肉只能单向驱动一个关节，因此为了实现关节层次的阻抗调节，需要相对立的两块肌肉共同收缩，这在生理学上称为<strong>Cocontraction of antagonistic muscle groups</strong>。想象着你从空中跳跃而下，在接触地面之时你需要保持腿部各关节的肌肉收缩来实现关节刚度的增加，以避免不必要的伤害；再考虑球场上你面对传来的篮球，下意识增加手腕处对立肌肉的收缩，从而能稳稳地接住它。<strong>通过调节关节阻抗来对抗环境的不稳定，是人体生理神经系统的基本准则；而通过学习利用自身或环境的动力学、减少不必要的阻抗和肌肉消耗，是我们适应这个世界基本方式。</strong></p>
<p>当从阻抗的角度去理解人体运动时，能够得到比直观想象更是深刻一些的思考。人体肌肉系统一个特点是具有高度冗余，连接一个关节两侧骨骼的肌肉远远多于驱动该关节所必须的肌肉，甚至存在很多跨越多个关节的肌肉，例如上肢中最简单的肘关节就是由肱肌、肱桡肌、二头肌短头和二头肌长头共同作用。<strong>这种肌肉系统的冗余与复杂性对于阻抗控制来说起到什么作用？</strong></p>
<h3 id="Muscle-Redundancies"><a href="#Muscle-Redundancies" class="headerlink" title="Muscle Redundancies"></a>Muscle Redundancies</h3><img src="/2020/12/02/9.%E9%98%BB%E6%8A%97%E6%8E%A7%E5%88%B6/%E9%98%BB%E6%8A%97%E6%8E%A7%E5%88%B6/fig4.png" class>
<p>考虑由大臂、小臂和躯干组成的二连杆模型在平面进行运动的情况，如图(a)所示。将手部视为刚体并忽略腕关节的自由度。为简化分析，将肌肉用弹簧进行描述，弹簧的刚度系数可以由神经信号进行调整。首先研究只有单关节肌肉的情况，图(b)所示。记相对关节角度为$\rho_1$,$\rho_2$，肩关节和肘关节的刚度系数分别为$K_s$,$K_e$，则关节力矩可以表示为如下形式：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{c}
T_{1} \\
T_{2}
\end{array}\right]=\left[\begin{array}{cc}
K_s & 0 \\
0 & K_e
\end{array}\right]\left[\begin{array}{l}
\rho_{1} \\
\rho_{2}
\end{array}\right]</script><p>式中的矩阵称为刚度矩阵，反应关节阻抗特性。由于我们更关心末端执行器-手部，与环境交互时的阻抗特性，因此进一步将上面的阻抗关系变化到笛卡尔坐标下。考虑相对关节角度与绝对关节角度之间的变化关系：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{c}
\rho_{1} \\
\rho_{2}
\end{array}\right]=\left[\begin{array}{rr}
1 & 0 \\
-1 & 1
\end{array}\right]\left[\begin{array}{l}
\theta_{1} \\
\theta_{2}
\end{array}\right] = T\left[\begin{array}{l}
\theta_{1} \\
\theta_{2}
\end{array}\right]=K_\theta \theta</script><p>绝对关节角坐标系下的阻抗关系为：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{c}
T_{1} \\
T_{2}
\end{array}\right]=T^T\left[\begin{array}{cc}
K_s & 0 \\
0 & K_e
\end{array}\right]T\left[\begin{array}{l}
\theta_{1} \\
\theta_{2}
\end{array}\right]
=\left[\begin{array}{cc}
K_s+K_e & -K_e \\
-K_e & K_e
\end{array}\right]\left[\begin{array}{l}
\theta_{1} \\
\theta_{2}
\end{array}\right]</script><p>末端位置到关节角度的雅克比矩阵为：</p>
<script type="math/tex; mode=display">
J=\left[\begin{array}{cc}
-L_{1} \sin \theta_{1} & -L_{2} \sin \theta_{2} \\
L_{1} \cos \theta_{1} & L_{2} \cos \theta_{2}
\end{array}\right]</script><p>关节阻抗到末端阻抗的变换关系为：</p>
<script type="math/tex; mode=display">
\tau=J^TF \Rightarrow  K_\theta d\theta = J^TK_x dx \Rightarrow K_\theta  = J^TK_x J \Rightarrow K_x  = (J^T)^{-1}K_\theta J^{-1}</script><p>假定$L_1=L_2=1$，并令$\Lambda=C_1S_2-S_1C_2$，则有：</p>
<script type="math/tex; mode=display">
K_x = \frac{K_s}{\Lambda^2} \left[\begin{array}{cc}
C_2^2 & S_2C_2\\
S_2C_2 & S_2^2
\end{array}\right]+
 \frac{K_e}{\Lambda^2} \left[\begin{array}{cc}
(C_1+C_2)^2 & (S_1+S_2)(C_1+C_2)\\
(S_1+S_2)(C_1+C_2) & (S_1+S_2)^2
\end{array}\right]</script><p>虽然在相对关节角度坐标系下刚度矩阵是对角的，但在末端笛卡尔坐标系下刚度矩阵一般不再具有对角性。通过调节关节刚度$K_s$和$K_e$，可以实现对末端笛卡尔坐标系下的阻抗调节，且肌肉的冗余度越高，则对于阻抗的调节就越灵活。但由于刚度矩阵有三个自由变量（对称性），因此调节$K_s$和$K_e$无法实现任意形式阻抗模式。考虑当$\theta_1=0, \theta_2=90^{\circ} $时，$\Lambda=1$，$K_x$可以表示为如下形式：</p>
<script type="math/tex; mode=display">
K_x = {K_s} \left[\begin{array}{cc}
0 & 0\\
0 & 1
\end{array}\right]+
{K_e}\left[\begin{array}{cc}
1 & 1\\
1 & 1
\end{array}\right]</script><p>上式表明无论人体如何调整关节的刚度系数或是肌肉的收缩程度，都不可能使末端笛卡尔坐标下的刚度矩阵等于单位矩阵。若进一步用刚度椭圆来表示表示刚度矩阵（长轴和短轴分别代表刚度矩阵的两个特征值，长轴和短轴的方向分别为特征向量的方向），可以看出随着关节刚度的调节，末端笛卡尔坐标系下刚度椭圆的长轴只能够在如下深蓝和深红两条虚线内变化。在这样的阻抗特性下，手臂末端更容易对抗平行于蓝色虚线的扰动，而容易收到垂直于蓝色虚线的扰动的影响；也就是说在这样的阻抗特性下，你会很容易写出丿，却很难写出㇏。</p>
<p><img src="/2020/12/02/9.%E9%98%BB%E6%8A%97%E6%8E%A7%E5%88%B6/%E9%98%BB%E6%8A%97%E6%8E%A7%E5%88%B6/Stiffness.png" width="60%"></p>
<p>现在向这个二连杆机构引入双关节肌肉，在双关节肌肉和单关节肌肉的共同作用下，相对关节角度坐标系下的阻抗特性如下：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{c}
T_{1} \\
T_{2}
\end{array}\right]=\left[\begin{array}{cc}
K s+K t & K t \\
K t & K e+K t
\end{array}\right]\left[\begin{array}{l}
\rho_{1} \\
\rho_{2}
\end{array}\right]</script><p>将其变换到末端笛卡尔坐标系下，可得：</p>
<script type="math/tex; mode=display">
K_x = \frac{K_s}{\Lambda^2} \left[\begin{array}{cc}
C_2^2 & S_2C_2\\
S_2C_2 & S_2^2
\end{array}\right]+
 \frac{K_e}{\Lambda^2} \left[\begin{array}{cc}
(C_1+C_2)^2 & (S_1+S_2)(C_1+C_2)\\
(S_1+S_2)(C_1+C_2) & (S_1+S_2)^2
\end{array}\right]+
\frac{K_t}{\Lambda^2} \left[\begin{array}{cc}
C_1^2 & S_1C_1\\
S_1C_1 & S_1^2
\end{array}\right]</script><p>第三个参数$K_t$增加了刚度矩阵的可调节范围，甚至在一定工作空间内可以实现任意形式的阻抗特性。依然考虑$\theta_1=0, \theta_2=90^{\circ} $的情况：</p>
<script type="math/tex; mode=display">
K_x = {K_s} \left[\begin{array}{cc}
0 & 0\\
0 & 1
\end{array}\right]+
{K_e}\left[\begin{array}{cc}
1 & 1\\
1 & 1
\end{array}\right]+
{K_t}\left[\begin{array}{cc}
1 & 0\\
0 & 0
\end{array}\right]</script><p>可以看出只要取$K_s=1, K_e=0, K_t=1$就可以使$K_x$为单位矩阵，甚至当前位姿下，通过调节$K_s, K_e, K_t$几乎可以实现任意形式的刚度矩阵，末端笛卡尔坐标系下可以表现出任意形式的阻抗特性，正如下图所展示的那样。</p>
<p><img src="/2020/12/02/9.%E9%98%BB%E6%8A%97%E6%8E%A7%E5%88%B6/%E9%98%BB%E6%8A%97%E6%8E%A7%E5%88%B6/Stiffness2.png" width="60%"></p>
<p><strong>由此，人体肌肉系统的冗余与复杂是有明确意义的，这经过亿万年进化而来的肌肉系统，增加了人体阻抗-尤其是末端阻抗的可调范围，使人类尽可能少的受到自身能力的限制，能够根据需要任意调整与环境交互时的阻抗特性，灵巧的使用各种工具来拓宽其生存边界与层次。</strong></p>
<h3 id="Impedance-Learning"><a href="#Impedance-Learning" class="headerlink" title="Impedance Learning"></a>Impedance Learning</h3><p>而人体的运动控制，可以很自然的看做是对于阻抗特性的学习。还是以手臂二自由度平面运动为例，在2001年的一篇Nature论文The central nervous system stabilizes unstable dynamics by learning optimal impedance中，研究人员通过与交互的机械臂在运动区域内构建了一个扩散力场（如下图所示）：当手臂末端运动偏离预定轨迹时会在$x$方向上受到干扰作用力，且随着偏差加大，作用力也越大，因此具有不稳定的特性。</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
F_{x} \\
F_{y}
\end{array}\right]=\left[\begin{array}{l}
\beta x \\
0
\end{array}\right]</script><p><img src="/2020/12/02/9.%E9%98%BB%E6%8A%97%E6%8E%A7%E5%88%B6/%E9%98%BB%E6%8A%97%E6%8E%A7%E5%88%B6/1606907817857.png" width="60%"></p>
<p>研究人员令受试者分别在无力场、有扩散力场的条件下，分别控制手臂末端沿y方向进行运动。在没有力场的作用下，受试者能够实现良好的运动轨迹；在刚施加扩散力场后，受试者的运动变得不稳定，而经过一段时间的学习后，受试者恢复了良好的运动轨迹。研究人员测量了不同受试者在力场作用前后的末端阻抗特性，刚度椭圆无一例外的增加了x方向上的长度，也就是增加了x方向上的刚度系数，使得能够对抗来自x方向上扩散力场的扰动。</p>
<p><img src="/2020/12/02/9.%E9%98%BB%E6%8A%97%E6%8E%A7%E5%88%B6/%E9%98%BB%E6%8A%97%E6%8E%A7%E5%88%B6/1606908189253.png" width="60%"></p>
<p>在扩散力场的作用下，人体的神经系统学会了新的阻抗特性来适应环境。类似的例子还有很多，当你骑自行车时，你用双手控制车把使车把表现出阻抗特性，使受到扰动后能恢复车把与前进方向平行；当你使用螺丝刀时，你控制螺丝刀在非法向方向上保持较高的阻抗，使得螺丝刀不会因为扰动而滑落。对于一切稳定和不稳定的环境，人体学习调整自身的肌肉表现适当的阻抗形式使交互过程保持稳定，再学习利用环境和自身的动力学特性使交互的动态过程更有效率。</p>
<p><strong>因此，人体运动控制本质是对阻抗特性的控制，学习环境（外部条件）、位姿（内部状态）与阻抗之间的映射关系，学习刚（admittance）柔（impedance）之间的相互转化，学习鲁棒与最优之间的动态平衡；而最终，促成了人类丰富多彩的世界。</strong></p>
<hr>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>Hogan N. Impedance control: An approach to manipulation: Part I—Theory[J]. 1985.</li>
<li>Hogan N. Impedance control: An approach to manipulation: Part II—Implementation[J]. 1985.</li>
<li>Ott C, Mukherjee R, Nakamura Y. Unified impedance and admittance control[C]//2010 IEEE International Conference on Robotics and Automation. IEEE, 2010: 554-561.</li>
<li>Kevin M.. Lynch, Park F C. Modern Robotics: Mechanics, Planning, and Control[M]. Cambridge University Press, 2017.</li>
<li>Milner T E. Adaptation to destabilizing dynamics by means of muscle cocontraction[J]. Experimental brain research, 2002, 143(4): 406-416.</li>
<li>Burdet E, Osu R, Franklin D W, et al. The central nervous system stabilizes unstable dynamics by learning optimal impedance[J]. Nature, 2001, 414(6862): 446-449.</li>
</ol>
]]></content>
      <categories>
        <category>阻抗研究</category>
      </categories>
      <tags>
        <tag>控制算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Matlab Signal Analyzer 信号分析</title>
    <url>/2021/10/08/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90/Matlab%20Signal%20Analyzer/</url>
    <content><![CDATA[<p>以跑台地反力为案列，介绍Matlab信号分析工具箱Signal Analyzer的基本使用<br><img src="/2021/10/08/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90/Matlab%20Signal%20Analyzer/6.png" class title="Untitled"></p>
<span id="more"></span>
<blockquote>
<p>参考资料：</p>
<p><a href="https://zhuanlan.zhihu.com/p/19763358">傅里叶分析之掐死教程（完整版）更新于2014.06.06</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/34989414">信号频域分析方法的理解（频谱、能量谱、功率谱、倒频谱、小波分析）</a></p>
<p><a href="https://www.zhihu.com/question/22864189/answer/40772083">如何通俗地讲解傅立叶分析和小波分析间的关系？</a></p>
</blockquote>
<h2 id="1-数据导入"><a href="#1-数据导入" class="headerlink" title="1-数据导入"></a>1-数据导入</h2><h3 id="加载数据，设置采样频率和开始时间"><a href="#加载数据，设置采样频率和开始时间" class="headerlink" title="加载数据，设置采样频率和开始时间"></a>加载数据，设置采样频率和开始时间</h3><img src="/2021/10/08/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90/Matlab%20Signal%20Analyzer/1.png" class title="截屏2021-10-20 下午7.34.59.png">
<p><img src="/2021/10/08/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90/Matlab%20Signal%20Analyzer/2.png" alt="截屏2021-10-20 下午7.35.16.png"></p>

<h2 id="功率谱分析"><a href="#功率谱分析" class="headerlink" title="功率谱分析"></a>功率谱分析</h2><blockquote>
<p><strong>频谱与功率谱密度：</strong></p>
<ul>
<li>根据信号的性质可分为确定信号和随机信号，确定信号又分为能量信号和功率信号，而随机信号只有功率信号；</li>
<li>只有能量信号才可以进行FFT得到频谱，功率信号不满足FFT的假设条件，只能进行功率谱分析（或着对信号进行有限截断进行FFT）；</li>
<li>对于确定信号而言功率谱可以简单看作是频谱模的平方（功率谱没有相频概念），对随机信号而言，可以看作是多次平均；</li>
</ul>
</blockquote>
<h3 id="进行功率分析"><a href="#进行功率分析" class="headerlink" title="进行功率分析"></a>进行功率分析</h3><img src="/2021/10/08/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90/Matlab%20Signal%20Analyzer/3.png" class title="Untitled">
<h3 id="设置坐标轴显示范围，以及其他参数"><a href="#设置坐标轴显示范围，以及其他参数" class="headerlink" title="设置坐标轴显示范围，以及其他参数"></a>设置坐标轴显示范围，以及其他参数</h3><img src="/2021/10/08/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90/Matlab%20Signal%20Analyzer/4.png" class title="Untitled">
<h2 id="3-数据平滑和滤波"><a href="#3-数据平滑和滤波" class="headerlink" title="3-数据平滑和滤波"></a>3-数据平滑和滤波</h2><h3 id="拷贝原始数据到新的变量，并进行滑动均值滤波"><a href="#拷贝原始数据到新的变量，并进行滑动均值滤波" class="headerlink" title="拷贝原始数据到新的变量，并进行滑动均值滤波"></a>拷贝原始数据到新的变量，并进行滑动均值滤波</h3><img src="/2021/10/08/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90/Matlab%20Signal%20Analyzer/5.png" class title="Untitled">
<img src="/2021/10/08/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90/Matlab%20Signal%20Analyzer/6.png" class title="Untitled">
<h3 id="拷贝原始数据到新的变量，并进行低通滤波"><a href="#拷贝原始数据到新的变量，并进行低通滤波" class="headerlink" title="拷贝原始数据到新的变量，并进行低通滤波"></a>拷贝原始数据到新的变量，并进行低通滤波</h3><img src="/2021/10/08/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90/Matlab%20Signal%20Analyzer/7.png" class title="Untitled">
<img src="/2021/10/08/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90/Matlab%20Signal%20Analyzer/8.png" class title="Untitled">
]]></content>
      <categories>
        <category>tutorials</category>
      </categories>
      <tags>
        <tag>Matlab</tag>
        <tag>信号分析</tag>
      </tags>
  </entry>
  <entry>
    <title>PyCosmed数字识别</title>
    <url>/2020/01/20/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90/PyCosmed%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<p>PyCosmed数字识别程序回顾与优化。</p>
<span id="more"></span>
<h3 id="图像预处理"><a href="#图像预处理" class="headerlink" title="图像预处理"></a>图像预处理</h3><p>首先要将截取的图片转为灰度图像，然后绘制灰度直方图，确定二值化阈值<code>150</code>，然后进行二值化：</p>
<img src="/2020/01/20/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90/PyCosmed%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/Figure_1.png" class>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取图像</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_img</span>(<span class="params">index</span>):</span></span><br><span class="line">    img = Image.<span class="built_in">open</span>(<span class="string">&quot;E:\\Python\\PyCosmed\\v3.0\DIGIT2\\&quot;</span>+<span class="built_in">str</span>(index)+<span class="string">&quot;.png&quot;</span>)</span><br><span class="line">    plt.subplot(<span class="number">221</span>)</span><br><span class="line">    plt.imshow(img)</span><br><span class="line">    <span class="keyword">return</span> img</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分析灰度直方图，从而选择合适的二值化阈值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gray_hist</span>(<span class="params">img</span>):</span></span><br><span class="line">    img_arr = np.array(img.convert(<span class="string">&#x27;L&#x27;</span>))    <span class="comment">#  convert - 转换图像格式   L - 八位黑白像素</span></span><br><span class="line">                                            <span class="comment">#  array - image格式转为array数组</span></span><br><span class="line">    plt.subplot(<span class="number">223</span>)</span><br><span class="line">    plt.imshow(img_arr)</span><br><span class="line"></span><br><span class="line">    img_arr = img_arr.flatten()             <span class="comment">#  flatten - 转化为一维数组</span></span><br><span class="line">    plt.subplot(<span class="number">222</span>)</span><br><span class="line">    plt.hist(img_arr,bins=<span class="number">256</span>)              <span class="comment">#  hist - 绘制直方图  bins - 条形数</span></span><br><span class="line">    plt.ylim((<span class="number">0</span>,<span class="number">50</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图像二值化</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarize</span>(<span class="params">img, threshold=threshold</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;二值化&quot;&quot;&quot;</span></span><br><span class="line">    img = img.convert(<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">    table = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        <span class="keyword">if</span> i &lt; threshold:</span><br><span class="line">            table.append(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            table.append(<span class="number">1</span>)</span><br><span class="line">    bin_img = img.point(table, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    plt.subplot(<span class="number">222</span>)</span><br><span class="line">    plt.imshow(bin_img)</span><br><span class="line">    <span class="keyword">return</span> bin_img</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="图像分割"><a href="#图像分割" class="headerlink" title="图像分割"></a>图像分割</h3><p>加入分割宽度机制，避免数字相连情况:</p>
<img src="/2020/01/20/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90/PyCosmed%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/Figure_2.png" class>
<p>分割后的图像集：</p>
<img src="/2020/01/20/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90/PyCosmed%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/Figure_4.png" class>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vertical_cut</span>(<span class="params">img</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;纵向切割&quot;&quot;&quot;</span></span><br><span class="line">    px = <span class="built_in">list</span>(np.<span class="built_in">sum</span>(np.array(img) == <span class="number">0</span>, axis=<span class="number">0</span>))</span><br><span class="line">    py = <span class="built_in">list</span>(np.<span class="built_in">sum</span>(np.array(img) == <span class="number">0</span>, axis=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 列表保存像素累加值大于0的列</span></span><br><span class="line">    x0 = []</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(px)):</span><br><span class="line">        <span class="keyword">if</span> px[x] &gt; <span class="number">0</span>:</span><br><span class="line">            x0.append(x)</span><br><span class="line">    y0 = []</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(py)):</span><br><span class="line">        <span class="keyword">if</span> py[y] &gt; <span class="number">1</span>:</span><br><span class="line">            y0.append(y)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 找出边界</span></span><br><span class="line">    cut_list = [x0[<span class="number">0</span>]]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(x0)):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(x0[i] - x0[i - <span class="number">1</span>]) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">abs</span>(x0[i-<span class="number">1</span>] - cut_list[-<span class="number">1</span>]) &lt; <span class="number">10</span>:</span><br><span class="line">                cut_list.extend([x0[i - <span class="number">1</span>]+<span class="number">1</span>, x0[i]])</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">abs</span>(x0[i-<span class="number">1</span>] - cut_list[-<span class="number">1</span>]) &lt; <span class="number">16</span>:</span><br><span class="line">                cut_list.extend([x0[i-<span class="number">1</span>]+<span class="number">1</span>, x0[i-<span class="number">1</span>]+<span class="number">8</span>])</span><br><span class="line">                cut_list.extend([x0[i-<span class="number">1</span>]+<span class="number">8</span>, x0[i]])</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">abs</span>(x0[i-<span class="number">1</span>] - cut_list[-<span class="number">1</span>]) &lt; <span class="number">24</span>:</span><br><span class="line">                cut_list.extend([x0[i-<span class="number">1</span>]+<span class="number">1</span>, x0[i-<span class="number">1</span>]+<span class="number">8</span>])</span><br><span class="line">                cut_list.extend([x0[i-<span class="number">1</span>]+<span class="number">8</span>, x0[i-<span class="number">1</span>]+<span class="number">16</span>])</span><br><span class="line">                cut_list.extend([x0[i-<span class="number">1</span>]+<span class="number">16</span>, x0[i]])</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">abs</span>(x0[-<span class="number">1</span>] - cut_list[-<span class="number">1</span>]) &lt; <span class="number">10</span>:</span><br><span class="line">        cut_list.append(x0[-<span class="number">1</span>]+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">abs</span>(x0[-<span class="number">1</span>] - cut_list[-<span class="number">1</span>]) &lt; <span class="number">17</span>:</span><br><span class="line">        cut_list.extend([cut_list[-<span class="number">1</span>]+<span class="number">8</span>, cut_list[-<span class="number">1</span>]+<span class="number">8</span>])</span><br><span class="line">        cut_list.append(x0[-<span class="number">1</span>]+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">abs</span>(x0[-<span class="number">1</span>] - cut_list[-<span class="number">1</span>]) &lt; <span class="number">25</span>:</span><br><span class="line">        cut_list.extend([cut_list[-<span class="number">1</span>]+<span class="number">8</span>, cut_list[-<span class="number">1</span>]+<span class="number">8</span>])</span><br><span class="line">        cut_list.extend([cut_list[-<span class="number">1</span>]+<span class="number">8</span>, cut_list[-<span class="number">1</span>]+<span class="number">8</span>])</span><br><span class="line">        cut_list.append(x0[-<span class="number">1</span>]+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    cut_list_y = [y0[<span class="number">0</span>]]</span><br><span class="line">    cut_list_y.append(y0[-<span class="number">1</span>]+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    cut_imgs = []</span><br><span class="line">    <span class="comment"># 切割顺利的话应该是整对</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(cut_list) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cut_list) // <span class="number">2</span>):</span><br><span class="line">            cut_img = img.crop([cut_list[i * <span class="number">2</span>], cut_list_y[<span class="number">0</span>], cut_list[i * <span class="number">2</span> + <span class="number">1</span>], cut_list_y[<span class="number">1</span>]])</span><br><span class="line">            plt.imshow(cut_img)</span><br><span class="line">        <span class="keyword">return</span> cut_imgs</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&#x27;Vertical cut failed.&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<h3 id="计算Hash码"><a href="#计算Hash码" class="headerlink" title="计算Hash码"></a>计算Hash码</h3><p>分割后的图像被统一缩放到<code>8*15</code>的大小，然后计算其Hash码，并提取每个字符的标准Hash码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 标准Hash码</span></span><br><span class="line">hash_vals = &#123;</span><br><span class="line">    <span class="string">&quot;0&quot;</span>: <span class="string">&quot;110000111000000110011001100110000001100000111100001111000011110000111100001111000001100010011001100110011000000111000011&quot;</span>,</span><br><span class="line">    <span class="string">&quot;1&quot;</span>: <span class="string">&quot;111000000000000000000000111110001111100011111000111110001111100011111000111110001111100011111000111110001111100011111000&quot;</span>,</span><br><span class="line">    <span class="string">&quot;2&quot;</span>: <span class="string">&quot;100000111000000111110001111110011111100111111001111110011111000111110011111000111100011111001111100111110000000000000000&quot;</span>,</span><br><span class="line">    <span class="string">&quot;3&quot;</span>: <span class="string">&quot;100000111000000111111000111111001111110011111001110000011100000111111000111111001111110011111100111110000000000110000011&quot;</span>,</span><br><span class="line">    <span class="string">&quot;4&quot;</span>: <span class="string">&quot;111100011111000111100001111000011100100111001001100110011001100100111001000000000000000011111001111110011111100111111001&quot;</span>,</span><br><span class="line">    <span class="string">&quot;5&quot;</span>: <span class="string">&quot;110000001100000010011111100111111001111110011111100000111000000011111000111111001111110011111100111110000000000100000011&quot;</span>,</span><br><span class="line">    <span class="string">&quot;6&quot;</span>: <span class="string">&quot;111110011110000111000111110011111001111110011111000000010000000100011000001111000011110000011100100110001000000111000011&quot;</span>,</span><br><span class="line">    <span class="string">&quot;7&quot;</span>: <span class="string">&quot;000000000000000011111001111110011111100111110011111100111111001111100111111001111100011111001111110011111000111110011111&quot;</span>,</span><br><span class="line">    <span class="string">&quot;8&quot;</span>: <span class="string">&quot;111000111100000110011000100111001001110010001001110000011100000110001000100111000001110000011100100111001000000011000011&quot;</span>, </span><br><span class="line">    <span class="string">&quot;9&quot;</span>: <span class="string">&quot;110000111000000110011001000110000011110000111100000111001001100010000000111010001111100111110001111000111000011110001111&quot;</span>,</span><br><span class="line">    <span class="string">&quot;.&quot;</span>: <span class="string">&quot;111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000000011100000&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hashing</span>(<span class="params">img</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算哈希值&quot;&quot;&quot;</span></span><br><span class="line">    img = img.resize((<span class="number">8</span>, <span class="number">15</span>), Image.LANCZOS)</span><br><span class="line">    px = np.array(img).flatten()</span><br><span class="line">    hash_val = (px &gt; px.mean()).astype(<span class="built_in">int</span>)</span><br><span class="line">    hash_val = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">str</span>(e) <span class="keyword">for</span> e <span class="keyword">in</span> hash_val)</span><br><span class="line">    <span class="keyword">return</span> hash_val</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hamming</span>(<span class="params">hash1, hash2</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算汉明距离&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(hash1) != <span class="built_in">len</span>(hash2):</span><br><span class="line">        print(<span class="string">&#x27;hash1: &#x27;</span>, hash1)</span><br><span class="line">        print(<span class="string">&#x27;hash2: &#x27;</span>, hash2)</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;Undefined for sequences of unequal length&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(i != j <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">zip</span>(hash1, hash2))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recognize</span>(<span class="params">img</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;识别结果&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># img = img.convert(&#x27;L&#x27;)</span></span><br><span class="line">    <span class="comment"># img = binarize(img)</span></span><br><span class="line">    <span class="comment"># chars = vertical_cut(img)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 相近度列表</span></span><br><span class="line">    nearness = &#123;&#125;</span><br><span class="line">    <span class="comment"># expr = &#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># for char in chars:</span></span><br><span class="line">    hash_val = hashing(img)</span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> hash_vals:</span><br><span class="line">        nearness[h] = hamming(hash_val, hash_vals[h])</span><br><span class="line">    expr = <span class="built_in">sorted</span>(nearness.items(), key=<span class="keyword">lambda</span> d: d[<span class="number">1</span>])[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> expr</span><br></pre></td></tr></table></figure>
<h3 id="识别结果"><a href="#识别结果" class="headerlink" title="识别结果"></a>识别结果</h3><p>分割数据集下的识别结果：</p>
<img src="/2020/01/20/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90/PyCosmed%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/Figure_5.png" class>
<p>原始图像下的识别结果：</p>
<img src="/2020/01/20/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90/PyCosmed%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/Figure_6.png" class>
<h3 id="One-More-Thing"><a href="#One-More-Thing" class="headerlink" title="One More Thing"></a>One More Thing</h3><p>另外对分割图像集进行个 主成分分析（PCA），在第一主成分和第二主成分平面上不具有明显的可分性，故没有进一步研究：</p>
<img src="/2020/01/20/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90/PyCosmed%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/Figure_7.png" class>
]]></content>
      <categories>
        <category>工程开发</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>An Introduction for IMU 1 - IMU原理与MPU6050数据采集</title>
    <url>/2021/03/01/IMU%E7%B3%BB%E7%BB%9F/1-IMU%E5%8E%9F%E7%90%86%E4%B8%8EMPU6050%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/</url>
    <content><![CDATA[<p>本系列博客将从IMU的基础概念和基本原理出发，基于Arduino单片机和MPU6050传感器，介绍数据采集、数据融合、姿态解算，进一步设计无线IMU模块，开发人体姿态测量系统，并同步到生物力学分析软件OpenSim中进行逆运动学分析，等。</p>
<span id="more"></span>
<h2 id="IMU的测量原理"><a href="#IMU的测量原理" class="headerlink" title="IMU的测量原理"></a>IMU的测量原理</h2><p>IMU全称Inertial Measurement Unit，惯性测量单元，主要用来检测和测量加速度与旋转运动的传感器。根据测量原理不同，可分为微机电传感器(MEMS)和光纤陀螺仪，其中光纤陀螺主要用于航空航天与军事领域，民用IMU大都是基于惯性原理的MEMS传感器。IMU根据所能感知状态量的个数(DOF)进行区分，其中6DOF的IMU最为常见，也就是可以测量三轴加速度和三轴角速度。9DOF的IMU会多一个三轴磁力计，10DOF的IMU再多一个气压计。</p>
<img src="/2021/03/01/IMU%E7%B3%BB%E7%BB%9F/1-IMU%E5%8E%9F%E7%90%86%E4%B8%8EMPU6050%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/1.png" class width="1">
<p>加速度计的物理实现是利用牛顿第二定律，如上左图所示，中间红色物体为一个质量块，两头通过具有弹簧性质的长条结构与基底相连，红色的短栅与绿色的短栅分别为电容的极板。当基底在双箭头方向有加速度a时，由$f=ma=kx$，质量块会沿加速度相反的方向移动，红色极板与绿色极板之间的距离会发生变化，通过测量极板电容$C$的变化就可以得到加速度的大小。在三轴加速度计中，这样的结构在三个方向各有一个，且做到了微米的尺寸，并配合相应的测量电路集成在一个芯片中，构成一个微机电系统。</p>
<p><img src="/2021/03/01/IMU%E7%B3%BB%E7%BB%9F/1-IMU%E5%8E%9F%E7%90%86%E4%B8%8EMPU6050%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/3.png" alt="3" style="zoom:30%;"></p>
<p>角速度测量的原理比加速度要复杂一些，利用了在旋转坐标系下运动的物体会受到科里奥里力(Coriolis Force)的特性。科里奥里力是由坐标系的转动与物体在动坐标系中的相对运动引起的，其本质是物体的惯性。如果图示模块置于绝对静止的坐标系中，当在x方向施加一个驱动力使质量块运动时，根据牛顿第二定律，质量块只会在x方向上运动，而在y方向上不会运动。但如果将图示模块置于一个旋转坐标系下，由于坐标系的旋转，使得当质量块沿x方向运动时，在y方向上会受到一个力，即科里奥里力<code>F=-2mvω</code>，从而使质量块沿y方向运动。地球上的很多自然现象，如热带气旋、季风带、河道两侧冲刷程度不同，都源于科里奥里力。</p>
<p>陀螺仪的物理实现如上右图所示，外侧的蓝色与黄色部分为驱动电极，它们在模块的驱动方向施加交变电压，使内部的质量块以及红色的测量电极沿着驱动方向运动。当整个平台发生旋转时，质量块受科里奥里力影响会在垂直方向上发生运动，且周期运动的幅值与平台的角速度成正比，通过测量质量块上的红色电极和固定在底座上蓝色电极之间的电容，便可以得到角速度的大小。</p>
<hr>
<h2 id="MPU6050"><a href="#MPU6050" class="headerlink" title="MPU6050"></a>MPU6050</h2><p><img src="/2021/03/01/IMU%E7%B3%BB%E7%BB%9F/1-IMU%E5%8E%9F%E7%90%86%E4%B8%8EMPU6050%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/2.png" width="80%"></p>
<p>MPU6050是InvenSense公司推出的一款高性能三轴加速度+三轴陀螺仪的六轴传感器芯片， 该芯片内部整合了 3 轴陀螺仪和 3 轴加速度传感器，并可利用自带的数字运动处理器（DMP: Digital Motion Processor）硬件加速引擎，体积较小，减少了大量的封装空间。主要特性如下：</p>
<ul>
<li>6位ADC和信号调理的三轴MEMS陀螺仪，具有 131 LSBs/° /sec 敏感度与全格感测范围为±250、±500、±1000 与±2000°/sec 的 3 轴角速度感测器(陀螺仪)；</li>
<li>16位ADC和信号调理的三轴MEMS加速度计，范围为±2g、±4g、±8g 和±16g 的 3 轴加速度传感器；</li>
<li>自带数字运动处理(DMP: Digital Motion Processing)引擎，内建运作时间偏差与磁力感测器校正演算技术，以数字形式输出 6 轴或 9 轴（需外接磁传感器）的旋转矩阵、四元数、欧拉角格式的融合演算数据，可减少 MCU 复杂的融合演算数据、感测器同步化、姿势感应等的负荷；</li>
<li>VDD 供电电压为 2.5V±5%、 3.0V±5%、 3.3V±5%； VLOGIC 可低至 1.8V± 5%；</li>
<li>陀螺仪工作电流： 5mA，陀螺仪待机电流： 5uA；加速度计工作电流： 500uA，加速度计省电模式电流： 40uA@10Hz；</li>
<li>支持最高 400Khz 的 IIC 通信，IIC地址为 0X68（AD0接GND）或0x69（AD0接VDD）；</li>
</ul>
<h2 id="MPU6050数据读取"><a href="#MPU6050数据读取" class="headerlink" title="MPU6050数据读取"></a>MPU6050数据读取</h2><p>本篇博客通过Arduino Nano读取MPU6050的数据，相同的程序也适用于其他的Arduino开发版。程序主要通过调用现有的MPU6050库，同时将数据通过匿名上位机以波形的方式显示出来，相关的库函数、上位机软件、上位机的Arduino通信函数可以到<a href="https://download.csdn.net/download/qq_35007540/16595570?spm=1001.2014.3001.5503">CSDN资源</a>下载，也可以在<a href="https://github.com/JYChenNK/IMU_SYS/tree/main/1-readMPU-Arduino/ref_lib">GITHUB</a>上下载，本部分读取IMU数据的程序请在<a href="https://download.csdn.net/download/qq_35007540/16595587?spm=1001.2014.3001.5503">此处</a>下载。库函数的安装方法，以及匿名上位机的使用方法请参考其他论坛和博客，若使用存在问题烦请给我留言。</p>
<p><img src="/2021/03/01/IMU%E7%B3%BB%E7%BB%9F/1-IMU%E5%8E%9F%E7%90%86%E4%B8%8EMPU6050%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/7.png" alt="7" style="zoom:80%;"></p>
<p>Arduino通过I2C于MPU6050进行通信，因此除了供电引脚外，还需要连接I2C引脚。根据上面的Arduino Nano引脚图，需要将MPU6050的SCL连接到Arduino Nano的A5引脚，SDA连接到Arduino的A4引脚。具体连线图如下所示：</p>
<p><img src="/2021/03/01/IMU%E7%B3%BB%E7%BB%9F/1-IMU%E5%8E%9F%E7%90%86%E4%B8%8EMPU6050%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/5.jpeg" alt="5" style="zoom:35%;"></p>
<p>程序主要调用了MPU6050的库，同时为了能够通过上位机显示数据波形，还调用了项目文件下的<code>ANO.h</code>里的函数来向上位机发送数。调用部分包括如下内容：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;I2Cdev.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MPU6050.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ANO.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Wire.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>在setup之前需要先定义一些MPU6050的相关变量，包括MPU6050对象的定义，以及三轴的加速度与角速度：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MPU6050 IMU;</span><br><span class="line"><span class="keyword">int16_t</span> ax, ay, az;</span><br><span class="line"><span class="keyword">int16_t</span> gx, gy, gz;</span><br></pre></td></tr></table></figure>
<p>在setup函数中，分别对串口、I2C总线以及MPU6050进行初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Initialize Serial</span></span><br><span class="line">  Serial.begin(<span class="number">115200</span>);</span><br><span class="line">  <span class="comment">// Initialize I2C &amp; IMU</span></span><br><span class="line">  <span class="comment">// By default, the measurement range of acc is 2g, and the gyro&#x27;s range is 250 deg/s</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE</span></span><br><span class="line">      Wire.begin();</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">elif</span> I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_FASTWIRE</span></span><br><span class="line">      Fastwire::setup(<span class="number">400</span>, <span class="literal">true</span>);</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  IMU.initialize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里有两点需要注意：</p>
<ul>
<li>I2C初始化的时候会和硬件存在一定关系，大部分开发版通过软件的方式进行I2C通信，也就是<code>Wire.h</code>库，但有些开发版具有硬件I2C，可以更快的速度通信（400kHz）。</li>
<li>MPU6050的<code>initialize</code>函数默认将MPU6050的测量范围设置为加速度2g，角速度250deg/s。因此初始化之后还需合理的设置传感器的测量范围，以及offset。</li>
</ul>
<p>初始化完成后便可以通过<code>getMotion6</code>函数读取MPU6050的数据，这里进一步将读取的数据用<code>ANO_DT_Send_Senser</code>函数通过串口发送给上位机：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Get IMU Raw Data</span></span><br><span class="line">  IMU.getMotion6(&amp;ax, &amp;ay, &amp;az, &amp;gx, &amp;gy, &amp;gz);</span><br><span class="line">  <span class="comment">// Send Data to PC</span></span><br><span class="line">  ANO_DT_Send_Senser(ax,ay,az,gx,gy,gz,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">  delay(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图为上下移动传感器时上位机的波形曲线，黄色为竖直方向Z轴的加速度，完整的程序请在<a href="https://download.csdn.net/download/qq_35007540/16595587?spm=1001.2014.3001.5503">此处</a>下载。</p>
<p><img src="/2021/03/01/IMU%E7%B3%BB%E7%BB%9F/1-IMU%E5%8E%9F%E7%90%86%E4%B8%8EMPU6050%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/4.gif" alt="4" style="zoom: 80%;"></p>
<h2 id="MPU6050的DMP数据读取"><a href="#MPU6050的DMP数据读取" class="headerlink" title="MPU6050的DMP数据读取"></a>MPU6050的DMP数据读取</h2><p>MPU6050得到的原始数据仅有加速度与角速度，但很多时候我们最需要用的是三轴的姿态角信息。通过加速度和角速度估计姿态角叫做IMU的姿态解算，下一篇博客将介绍姿态解算的原理与两种姿态计算的方法-互补滤波与卡尔曼滤波。其实MPU6050内部自带了姿态解算算法，也就是DMP。DMP是MPU6050内部的运动引擎，全称Digital Motion Processor，直接输出姿态解算后的四元数，可以减轻外围微处理器的工作负担且避免了繁琐的滤波和数据融合。Invensense提供了DMP的数据接口，但并非完全开源，Arduino平台下也有DMP读取的库，本篇博客也直接调用库函数来实现DMP数据的读取，相关的库和依赖还是在上文的链接中下载。</p>
<p>DMP的数据需要采用中断的方式进行读取，当DMP数据准备完成后，MPU6050的INT引脚会输出一个高电平脉冲，因此除了I2C引脚外，还需要将MPU6050的INT引脚接到Arduino Nano的0号中断通道，也就是数字引脚D2（中断通道序号和物理引脚序号的映射关系参考Arduino论坛），连线图如下：</p>
<p><img src="/2021/03/01/IMU%E7%B3%BB%E7%BB%9F/1-IMU%E5%8E%9F%E7%90%86%E4%B8%8EMPU6050%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/6.jpeg" alt="5" style="zoom:35%;"></p>
<p>读取DMP数据需要加载DMP的支持，因此用<code>MPU6050_6Axis_MotionApps20.h</code>代替<code>MPU6050.h</code>。同时为了对读取DMP数据的频率进行评估，以及向上位机定时发送数据，还另外调用了定时中断库，所有的调用如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MsTimer2.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;I2Cdev.h&quot;</span></span></span><br><span class="line"><span class="comment">//#include &quot;MPU6050.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MPU6050_6Axis_MotionApps20.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ANO.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Wire.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>程序首先需要定义一些MPU6050相关的对象和变量，包括MPU6050对象、DMP相关的状态变量、传感器的数据变量、以及用于计算DMP返回频率的变量等。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MPU6050 Object</span></span><br><span class="line">MPU6050 IMU;</span><br><span class="line"><span class="comment">// DMP state variables</span></span><br><span class="line"><span class="keyword">bool</span> dmpReady = <span class="literal">false</span>;  <span class="comment">// set true if DMP init was successful</span></span><br><span class="line"><span class="keyword">bool</span> mpuInterrupt = <span class="literal">false</span>;     <span class="comment">// indicates whether MPU interrupt pin has gone high</span></span><br><span class="line"><span class="keyword">uint8_t</span> mpuIntStatus;   <span class="comment">// holds actual interrupt status byte from MPU</span></span><br><span class="line"><span class="keyword">uint8_t</span> devStatus;      <span class="comment">// return status after each device operation (0 = success, !0 = error)</span></span><br><span class="line"><span class="keyword">uint16_t</span> packetSize;    <span class="comment">// expected DMP packet size (default is 42 bytes)</span></span><br><span class="line"><span class="keyword">uint16_t</span> fifoCount;     <span class="comment">// count of all bytes currently in FIFO</span></span><br><span class="line"><span class="keyword">uint8_t</span> fifoBuffer[<span class="number">64</span>]; <span class="comment">// FIFO storage buffer</span></span><br><span class="line"><span class="comment">// Measurement Data </span></span><br><span class="line"><span class="keyword">int16_t</span> acc[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int16_t</span> gyro[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">float</span> euler[<span class="number">3</span>];</span><br><span class="line">Quaternion q;</span><br><span class="line"><span class="comment">// Data Receive Frequence Count</span></span><br><span class="line"><span class="keyword">int</span> dataCounter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> dataFreq = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>传感器的初始化代码如下，包括初始化I2C总线、初始化MPU6050芯片、初始化DMP模块；当DMP模块被成功初始化之后，使能DMP模块，并设置Arduino的0号中断通道（数字引脚D2）为外部中断上升沿触发，然后从MPU6050获取DMP返回正确数据包的长度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IMU_Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Initialize I2C &amp; IMU</span></span><br><span class="line">  <span class="comment">// By default, the measurement range of acc is 2g, and the gyro&#x27;s range is 250 deg/s</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE</span></span><br><span class="line">      Wire.begin();</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">elif</span> I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_FASTWIRE</span></span><br><span class="line">      Fastwire::setup(<span class="number">400</span>, <span class="literal">true</span>);</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  IMU.initialize();</span><br><span class="line">  delay(<span class="number">200</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Initialize DMP</span></span><br><span class="line">  devStatus = IMU.dmpInitialize();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (devStatus == <span class="number">0</span>) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// turn on the DMP</span></span><br><span class="line">    IMU.setDMPEnabled(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// enable Arduino interrupt detection</span></span><br><span class="line">    attachInterrupt(<span class="number">0</span>, dmpDataReady, RISING);</span><br><span class="line">    mpuIntStatus = IMU.getIntStatus();</span><br><span class="line">    <span class="comment">// set our DMP Ready flag</span></span><br><span class="line">    dmpReady = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// get expected DMP packet size for later comparison</span></span><br><span class="line">    packetSize = IMU.dmpGetFIFOPacketSize();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    Serial.println(<span class="string">&quot;IMU Init Failed!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// INTERRUPT DETECTION ROUTINE</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dmpDataReady</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mpuInterrupt = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上初始化完成后，当MPU6050的中断引脚产生高电平信号，且FIFO缓存区数据的长度大于正确数据包的长度后，就可以读取DMP数据了。数据读取的代码如下，首先对初始化状态和外部中断状态进行判断；当外部中断触发后，首先读取MPU6050当前的中断状态，当状态为0x02表示解算完成（0x10表示缓存溢出中断，需要清空FIFO），再循环读取FIFO寄存器的数据长度，当长度大于一个正确数据包的长度后，从FIFO中读取数据<code>getFIFOBytes</code>，然后将数据解算为四元数<code>dmpGetQuaternion</code>，再变化到欧拉角<code>dmpGetEuler</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IMU_DMP_read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// return if IMU is not initialized</span></span><br><span class="line">  <span class="keyword">if</span> (!dmpReady) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// wait for MPU interrupt or extra packet(s) available</span></span><br><span class="line">  <span class="keyword">if</span>(!mpuInterrupt) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// reset interrupt flag and get INT_STATUS byte</span></span><br><span class="line">  mpuInterrupt = <span class="literal">false</span>;</span><br><span class="line">  mpuIntStatus = IMU.getIntStatus();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// get current FIFO count</span></span><br><span class="line">  fifoCount = IMU.getFIFOCount();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// check for overflow</span></span><br><span class="line">  <span class="keyword">if</span> ((mpuIntStatus &amp; <span class="number">0x10</span>) || fifoCount == <span class="number">1024</span>) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// reset so we can continue cleanly</span></span><br><span class="line">    IMU.resetFIFO();</span><br><span class="line">    Serial.println(<span class="string">&quot;FIFO overflow!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// otherwise, check for DMP data ready interrupt (this should happen frequently)</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (mpuIntStatus &amp; <span class="number">0x02</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// wait for correct available data length, should be a VERY short wait</span></span><br><span class="line">    <span class="keyword">while</span> (fifoCount &lt; packetSize) </span><br><span class="line">      fifoCount = IMU.getFIFOCount();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read a packet from FIFO</span></span><br><span class="line">    IMU.getFIFOBytes(fifoBuffer, packetSize);</span><br><span class="line">    <span class="comment">// track FIFO count here in case there is &gt; 1 packet available</span></span><br><span class="line">    <span class="comment">// (this lets us immediately read more without waiting for an interrupt)</span></span><br><span class="line">    fifoCount -= packetSize;</span><br><span class="line"></span><br><span class="line">    IMU.dmpGetQuaternion(&amp;q, fifoBuffer);</span><br><span class="line">    IMU.dmpGetEuler(euler, &amp;q);</span><br><span class="line">    </span><br><span class="line">    dataCounter++;</span><br><span class="line"></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主程序中初始化串口和IMU，同时开启5ms定时中断向上位机发送欧拉角数据，同时对DMP接受到的数据频率进行统计；主循环中不断执行DMP的数据读取，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Serial.begin(<span class="number">115200</span>);</span><br><span class="line">  IMU_Init();</span><br><span class="line">  MsTimer2::<span class="built_in">set</span>(<span class="number">5</span>,sendPC);</span><br><span class="line">  MsTimer2::start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  IMU_DMP_read(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendPC</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> timeCounter = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  timeCounter += <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span>(timeCounter &gt; <span class="number">1000</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    dataFreq = dataCounter;</span><br><span class="line">    dataCounter = <span class="number">0</span>;</span><br><span class="line">    timeCounter = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Send Data to PC</span></span><br><span class="line">  ANO_DT_Send_Senser(euler[<span class="number">1</span>]*<span class="number">180</span>/M_PI,euler[<span class="number">2</span>]*<span class="number">180</span>/M_PI, euler[<span class="number">0</span>]*<span class="number">180</span>/M_PI, dataFreq,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图为旋转传感器时上位机的波形曲线，前三条曲线为欧拉角；第四条蓝色曲线为DMP读取的频率，实测结果约为66Hz，可能和软件I2C有关，其他一些博客在STM32 F407平台上测试结果为100Hz，官方手册中最高为200Hz。本部分的完整程序请在<a href="https://download.csdn.net/download/qq_35007540/16596089">此处</a>下载。</p>
<p><img src="/2021/03/01/IMU%E7%B3%BB%E7%BB%9F/1-IMU%E5%8E%9F%E7%90%86%E4%B8%8EMPU6050%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/8.gif" alt="8" style="zoom:80%;"></p>
]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>IMU系统</tag>
      </tags>
  </entry>
  <entry>
    <title>MicroLabBox教程 1 - Basic Info &amp; Quick Start</title>
    <url>/2021/06/11/dSPACE/dSPACE-01/Basic%20Info%20&amp;%20Quick%20Start/</url>
    <content><![CDATA[<p>本篇简要介绍dSPACE - MicroLabBox的背景知识，演示使用Simulink快速开发dSPACE的基本流程。</p>
<img src="/2021/06/11/dSPACE/dSPACE-01/Basic%20Info%20&%20Quick%20Start/0.png" class title="Untitled">
<span id="more"></span>
<h2 id="MicroLabBox"><a href="#MicroLabBox" class="headerlink" title="MicroLabBox"></a><strong>MicroLabBox</strong></h2><ul>
<li><strong><a href="https://www.dspace.com/zh/zho/home/products.cfm">MicroLabBox</a></strong>是由德国dSPACE公司开发的一套基于MATLAB/Simulink的控制系统开发及半实物仿真的软硬件系统，<strong>用于实验室的一体化开发，在汽车行业的原型机开发中有非常广泛的应用；</strong></li>
<li>dSPACE的实时系统拥有<strong>实时性强</strong>、<strong>可靠性高</strong>、扩充性好等优点，处理器具有高速的计算能力，并配备了丰富的I/O支持，用户可以根据需要进行组合；软件环境的功能强大且使用方便，包括实现代码自动生成/下载和试验/调试的整套工具，是<strong>快速控制原型验证</strong>和<strong>半实物仿真（硬件在环仿真）</strong>的首选实时平台；</li>
</ul>
<h2 id="MicroLabBox的开发流程"><a href="#MicroLabBox的开发流程" class="headerlink" title="MicroLabBox的开发流程"></a><strong>MicroLabBox的开发流程</strong></h2><img src="/2021/06/11/dSPACE/dSPACE-01/Basic%20Info%20&%20Quick%20Start/01.png" class title="image-20211102013716732">
<hr>
<img src="/2021/06/11/dSPACE/dSPACE-01/Basic%20Info%20&%20Quick%20Start/02.png" class title="未标题-1.png">
<h2 id="First-Routine"><a href="#First-Routine" class="headerlink" title="First Routine"></a>First Routine</h2><h3 id="Step-1-创建Simulink文件并编写程序"><a href="#Step-1-创建Simulink文件并编写程序" class="headerlink" title="Step-1 创建Simulink文件并编写程序"></a>Step-1 创建Simulink文件并编写程序</h3><ul>
<li>新建Simulink Model并<strong>选择RTI1202模版</strong></li>
</ul>
<img src="/2021/06/11/dSPACE/dSPACE-01/Basic%20Info%20&%20Quick%20Start/3.png" class title="Untitled">
<img src="/2021/06/11/dSPACE/dSPACE-01/Basic%20Info%20&%20Quick%20Start/4.png" class title="Untitled">
<ul>
<li>从Simulink Library中拖拽需要的<strong>dSPACE功能包（IO接口）</strong>，并完成完整的程序</li>
</ul>
<img src="/2021/06/11/dSPACE/dSPACE-01/Basic%20Info%20&%20Quick%20Start/5.png" class title="Untitled">
<img src="/2021/06/11/dSPACE/dSPACE-01/Basic%20Info%20&%20Quick%20Start/6.png" class title="Untitled">
<ul>
<li>编译程序，生成<code>.sdf</code>文件</li>
</ul>
<img src="/2021/06/11/dSPACE/dSPACE-01/Basic%20Info%20&%20Quick%20Start/7.png" class title="Untitled">
<p><strong>Tips</strong></p>
<ul>
<li>编译前，确保dSPACE已经上电，并通过网线连接到电脑，否则报错</li>
<li>编译的文件会生成在Matlab当前工作目录下，编译前确保路径正确</li>
</ul>
<h3 id="Step-2-创建ControlDesk工程并设计交互界面"><a href="#Step-2-创建ControlDesk工程并设计交互界面" class="headerlink" title="Step-2 创建ControlDesk工程并设计交互界面"></a>Step-2 创建ControlDesk工程并设计交互界面</h3><ul>
<li>打开dSPACE，新建工程，设置项目地址、项目名称、实验名称</li>
</ul>
<img src="/2021/06/11/dSPACE/dSPACE-01/Basic%20Info%20&%20Quick%20Start/8.png" class title="Untitled">
<img src="/2021/06/11/dSPACE/dSPACE-01/Basic%20Info%20&%20Quick%20Start/9.png" class title="Untitled">
<ul>
<li>选择硬件平台（默认，无需操作），设置该实验的<code>sdf</code>文件</li>
</ul>
<img src="/2021/06/11/dSPACE/dSPACE-01/Basic%20Info%20&%20Quick%20Start/10.png" class title="Untitled">
<img src="/2021/06/11/dSPACE/dSPACE-01/Basic%20Info%20&%20Quick%20Start/11.png" class title="Untitled">
<ul>
<li>ControlDesk交互界面</li>
</ul>
<img src="/2021/06/11/dSPACE/dSPACE-01/Basic%20Info%20&%20Quick%20Start/12.png" class title="Untitled">
<ul>
<li>根据需要设计交互界面</li>
</ul>
<blockquote>
<p><strong>步骤</strong></p>
<ul>
<li>在控件栏中拖选需要的控件至交互界面区</li>
<li>从程序变量区选择需要的变量拖动到控件上以建立连接</li>
<li>编辑控件属性使之匹配变量的需要</li>
</ul>
</blockquote>
<img src="/2021/06/11/dSPACE/dSPACE-01/Basic%20Info%20&%20Quick%20Start/13.png" class title="Untitled">
<img src="/2021/06/11/dSPACE/dSPACE-01/Basic%20Info%20&%20Quick%20Start/14.png" class title="Untitled">
<h3 id="Step-3-下载并运行程序"><a href="#Step-3-下载并运行程序" class="headerlink" title="Step-3 下载并运行程序"></a>Step-3 下载并运行程序</h3><img src="/2021/06/11/dSPACE/dSPACE-01/Basic%20Info%20&%20Quick%20Start/15.png" class title="Untitled">
<img src="/2021/06/11/dSPACE/dSPACE-01/Basic%20Info%20&%20Quick%20Start/16.png" class title="Untitled">
<blockquote>
<p>在Ch1和Ch4引脚之间连接LED，通过点击按钮控制LED的亮灭</p>
</blockquote>
<h2 id="Step-4-修改程序并重新烧录"><a href="#Step-4-修改程序并重新烧录" class="headerlink" title="Step-4 修改程序并重新烧录"></a>Step-4 修改程序并重新烧录</h2><ul>
<li>和step 2中相同的方法创建另外2个数字量输出，新增一个数字量输入接口，重新烧录程序</li>
</ul>
<img src="/2021/06/11/dSPACE/dSPACE-01/Basic%20Info%20&%20Quick%20Start/17.png" class title="Untitled">
<blockquote>
<p><strong>Tips</strong></p>
<ul>
<li>确保Matlab当前工作目录在之前的sdf文件目录下</li>
<li>在编译之前需要在ControlDesk中Go offline</li>
<li>在ControlDesk中重新加载程序（Go Online）</li>
</ul>
</blockquote>
<img src="/2021/06/11/dSPACE/dSPACE-01/Basic%20Info%20&%20Quick%20Start/18.png" class title="Untitled">
<img src="/2021/06/11/dSPACE/dSPACE-01/Basic%20Info%20&%20Quick%20Start/19.png" class title="Untitled">
<img src="/2021/06/11/dSPACE/dSPACE-01/Basic%20Info%20&%20Quick%20Start/20.png" class title="Untitled">
<ul>
<li><strong>Tips</strong><ul>
<li>如果正确的编译得到了新的程序（sdf文件），在Go Online时需要点击2/3次确认按钮</li>
<li>重新设计交互界面，并运行</li>
</ul>
</li>
</ul>
<img src="/2021/06/11/dSPACE/dSPACE-01/Basic%20Info%20&%20Quick%20Start/21.png" class title="Untitled">
<ul>
<li><strong>Tips</strong><ul>
<li>对于含有曲线的控件，需要点击Start Measuring以开启测量</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>tutorials</category>
        <category>dSPACE</category>
      </categories>
      <tags>
        <tag>dSPACE</tag>
      </tags>
  </entry>
  <entry>
    <title>An Introduction for IMU 2 - IMU数据融合与姿态解算</title>
    <url>/2021/03/02/IMU%E7%B3%BB%E7%BB%9F/2-IMU%E6%95%B0%E6%8D%AE%E8%9E%8D%E5%90%88%E4%B8%8E%E5%A7%BF%E6%80%81%E8%A7%A3%E7%AE%97/</url>
    <content><![CDATA[<p>在上一篇博客中，我们已经介绍了IMU的内部工作原理，以及如何通过Arduino读取MPU6050的数据。虽然可以从DMP直接读取姿态角，但其数据返回的频率相对较低，同时由于DMP库不是开源的，其内部的工作原理、输出姿态角的准确性都不清楚；而除了MPU以外的IMU传感器基本不带有DMP功能，因此大部分时候还是需要我们自己在单片机里实现IMU姿态角的计算。本片博客将介绍如何使用采集到的加速度和角速度数据进行数据融合，也就是IMU的姿态解算。</p>
<span id="more"></span>
<h2 id="IMU姿态解算"><a href="#IMU姿态解算" class="headerlink" title="IMU姿态解算"></a>IMU姿态解算</h2><p>MPU6050得到的原始数据仅有加速度与角速度，单独由加速度计或陀螺仪都可以解算出三轴的角度。</p>
<p><img src="/2021/03/02/IMU%E7%B3%BB%E7%BB%9F/2-IMU%E6%95%B0%E6%8D%AE%E8%9E%8D%E5%90%88%E4%B8%8E%E5%A7%BF%E6%80%81%E8%A7%A3%E7%AE%97/1.png" alt="1" style="zoom:50%;"></p>
<p>根据IMU的测量原理可知，加速度计测量的是底座对于质量块作用的力所产生的加速度。当模块处于静止时，质量块会受到向下的重力加速度，而加速度计的底座向质量块提供相反的加速度使质量块保持静止，因此在静止条件下加速度计会测量到1g竖直向上的加速度。当模块倾斜且<strong>保持静止</strong>时，可以通过重力加速度在另外一个/两个轴线上的分量计算得到模块的姿态角度：</p>
<script type="math/tex; mode=display">
{ AngleY }_{ {acc }}=\arctan \frac{accY}{accZ}</script><p>另一方面，由于角速度是角度的导数，通过对角速度积分也可以得到姿态角：</p>
<script type="math/tex; mode=display">
{ AngleY_{gyro } }={ AngleY }_{0}+\int_{0}^{T} { gyroYdt }</script><p>虽然可以从加速度和角速度分别解算出角度，但这两种方式都存在很大的问题。一方面由于加速度计容易受到振动的影响，噪声很大，所以解算角度的噪声也很大，同时加速度解算的角度仅适用于静态过程；另一方面虽然陀螺仪测量角速度的噪声不是很大，经过积分环节后噪声进一步被变小，但由于初始角度并不能准确得到，而且角速度存在零漂问题，经过积分后误差会被累积。因此，两种方式解算出来的角度都无法直接使用，但我们可以采用数据融合的方法，把两种角度融合在一起，得到一个既没有累计误差、噪声又小的角度数据。</p>
<hr>
<h2 id="互补滤波"><a href="#互补滤波" class="headerlink" title="互补滤波"></a>互补滤波</h2><p>一阶互补滤波是最简单但却非常实用的数据融合算法，它把由加速度解算的角度和由角速度积分的角度按照一定比例加到一起，公式如下：</p>
<script type="math/tex; mode=display">
Angle = K\cdot Angle_{acc}+(1-K)\cdot (Angle + \omega\cdot dt)</script><p>其中参数<code>K</code>表示对加速度解算角度的置信程度，由于加速度的噪声很大，所以参数<code>K</code>一般很小，典型值为<code>0.05</code>，实际使用要根据效果来调整。互补滤波器可以看做是一个高通滤波和一个低通滤波的叠加：公式的第一项是为低通滤波部分，目的是滤除加速度的噪声；公式的第二项为高通滤波部分，目的是滤除角速度的直流偏置（零漂）。</p>
<p>互补滤波容易理解，实现简单，运算量低；滤波器只有一个参数，所以比较容易调整；经过简单的传感器校准后，在大部分应用场景下都能取得比较好的效果。若需要更高的动态性能，可以考虑使用卡尔曼滤波。</p>
<hr>
<h2 id="卡尔曼滤波"><a href="#卡尔曼滤波" class="headerlink" title="卡尔曼滤波"></a>卡尔曼滤波</h2><p>卡尔曼滤波通过构建线性模型下的最优滤波器实现对IMU的数据融合与姿态解算，其中状态变量设置为角度和角速度的偏置：</p>
<script type="math/tex; mode=display">
State = \begin{bmatrix} Angle(k)  \\ Gyro_{bias}(k) \\  \end{bmatrix}</script><p>状态空间模型考虑带控制量的形式，并建立为如下形式，其中状态方程的控制量为陀螺仪测量的角速度，观测方程的观测量为加速度解算得到的角度：</p>
<script type="math/tex; mode=display">
\begin{bmatrix} Angle(k+1)  \\ Gyro_{bias}(k+1)   \end{bmatrix} = \begin{bmatrix} 1 & -dt \\ 0 & 1   \end{bmatrix}\begin{bmatrix} Angle(k)  \\ Gyro_{bias}(k) \end{bmatrix} + \begin{bmatrix} dt \\ 0  \end{bmatrix} Gyro(k) + Q(k)</script><script type="math/tex; mode=display">
Angle_{acc}(k) =\begin{bmatrix} 1 & 0  \end{bmatrix}  \begin{bmatrix} Angle(k) \\ Gyro_{bias}(k)  \end{bmatrix} + R(k)</script><p>其中矩阵<code>Q</code>和<code>R</code>分别为输入噪声矩阵和观测噪声矩阵，是滤波器的可调参数，表征模型与测量的准确性。由加速度计观测角度的噪声较大，同时动态过程中加速度解算的角度并不准确，所以对于本问题矩阵<code>R</code>的参数要比<code>Q</code>的参数大很多。</p>
<p>下面给出<strong>卡尔曼滤波的递推公式</strong>，关于对卡尔曼滤波的理解，可以参考<a href="https://zhuanlan.zhihu.com/p/39912633">其他博客</a>。</p>
<p>状态方程：</p>
<script type="math/tex; mode=display">
X(k+1)=AX(k)+BU(k)+Q(k)\\
Y(k)=CX(k)+R(k)\\</script><p>状态一步预测：</p>
<script type="math/tex; mode=display">
\hat X(k+1|k) = A\hat X(k|k)+BU(k)\\
P(k+1|k)=AP(k|k)A^T+Q(k)</script><p>状态更新：</p>
<script type="math/tex; mode=display">
K(k+1)=P(k+1|k)C^T[CP(k+1|k)C^T+R(k+1)]^{-1}=\frac{P(k+1|k)C^T}{CP(k+1|k)C^T+R(k+1)}</script><script type="math/tex; mode=display">
\hat X(k+1|k+1)=\hat X(k+1|k)+K(k+1)[Y(k+1)-CX(k+1|k)]</script><script type="math/tex; mode=display">
P(k+1|k+1)=P(k+1|k)-K(k+1)CP(k+1|k)</script><hr>
<h2 id="Arduino下的实现代码"><a href="#Arduino下的实现代码" class="headerlink" title="Arduino下的实现代码"></a>Arduino下的实现代码</h2><p>本部分介绍如何在Arduino下实现IMU的数据融合与姿态计算，分别通过一阶互补滤波和卡尔曼滤波进行实现。对于卡尔曼滤波器，目前网络博客上的嵌入式代码更多采用数组元素的加减乘除操作，来实现矩阵的各种运算，对于初学者来说增加了一定的难度。本文调用了Arduino的矩阵运算库来实现卡尔曼滤波器，执行上会增加一定的计算量和运算时间，但更方便初学者理解。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;BasicLinearAlgebra.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;math.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> BLA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> dt      = <span class="number">0.005</span>;</span><br><span class="line"><span class="keyword">float</span> Q_angle = <span class="number">0.001</span>;</span><br><span class="line"><span class="keyword">float</span> Q_gyro  = <span class="number">0.003</span>;</span><br><span class="line"><span class="keyword">float</span> R_angle = <span class="number">0.5</span>;</span><br><span class="line"><span class="keyword">float</span> K1      = <span class="number">0.05</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> Angle_Kalman, Bias_Kalman, Angle_FOCF;</span><br><span class="line"></span><br><span class="line">BLA::Matrix&lt;<span class="number">2</span>,<span class="number">1</span>&gt; X = &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">BLA::Matrix&lt;<span class="number">1</span>,<span class="number">1</span>&gt; Y = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">BLA::Matrix&lt;<span class="number">1</span>,<span class="number">1</span>&gt; U = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">BLA::Matrix&lt;<span class="number">2</span>,<span class="number">2</span>&gt; A = &#123;<span class="number">1</span>,dt,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">BLA::Matrix&lt;<span class="number">2</span>,<span class="number">1</span>&gt; B = &#123;dt,<span class="number">0</span>&#125;;</span><br><span class="line">BLA::Matrix&lt;<span class="number">1</span>,<span class="number">2</span>&gt; C = &#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">BLA::Matrix&lt;<span class="number">2</span>,<span class="number">2</span>&gt; P = &#123;<span class="number">0.1</span>,<span class="number">0.1</span>,<span class="number">0.1</span>,<span class="number">0.1</span>&#125;;</span><br><span class="line">BLA::Matrix&lt;<span class="number">2</span>,<span class="number">1</span>&gt; K = &#123;<span class="number">0.1</span>,<span class="number">0.1</span>&#125;;</span><br><span class="line">BLA::Matrix&lt;<span class="number">2</span>,<span class="number">2</span>&gt; Q = &#123;Q_angle,<span class="number">0</span>,<span class="number">0</span>,Q_gyro&#125;;</span><br><span class="line">BLA::Matrix&lt;<span class="number">1</span>,<span class="number">1</span>&gt; R = &#123;R_angle&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calIMU</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="comment">// Get IMU Raw Data</span></span><br><span class="line">  IMU.getMotion6(&amp;ax, &amp;ay, &amp;az, &amp;gx, &amp;gy, &amp;gz);  <span class="comment">//获取MPU6050陀螺仪和加速度计的数据</span></span><br><span class="line">  <span class="comment">// Convert Data to right unit</span></span><br><span class="line">  gyro = gx*<span class="number">250.0</span>/<span class="number">32767</span>,accel_z= az*<span class="number">2.0</span>*<span class="number">9.8</span>/<span class="number">32767</span>;</span><br><span class="line">  <span class="comment">// Calculate angle directly by two methods</span></span><br><span class="line">  accel_angle = <span class="built_in">atan2</span>(ay,az)*<span class="number">180.0</span>/PI, gyro_angle += (gyro+<span class="number">1</span>)*dt;</span><br><span class="line">  <span class="comment">// One-Order Complementary Filter</span></span><br><span class="line">  Fist_Older_Complementary_Filter(gyro,accel_angle);</span><br><span class="line">  <span class="comment">// Kalman Filter</span></span><br><span class="line">  Kalman_Filter(gyro,accel_angle);</span><br><span class="line">  <span class="comment">// Send Data to PC</span></span><br><span class="line">  ANO_DT_Send_Senser(gyro*<span class="number">100</span>, accel_z*<span class="number">100</span>, accel_angle*<span class="number">100</span>, gyro_angle*<span class="number">100</span>, Angle_FOCF*<span class="number">100</span>, Angle_Kalman*<span class="number">100</span>, Bias_Kalman*<span class="number">100</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fist_Older_Complementary_Filter</span><span class="params">(<span class="keyword">float</span> Gyro, <span class="keyword">float</span> Accel_Angle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Angle_FOCF = K1*Accel_Angle + (<span class="number">1</span> - K1)*(Angle_FOCF + Gyro * dt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kalman_Filter</span><span class="params">(<span class="keyword">float</span> Gyro, <span class="keyword">float</span> Accel_Angle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  U(<span class="number">0</span>,<span class="number">0</span>) = Gyro;</span><br><span class="line">  Y(<span class="number">0</span>,<span class="number">0</span>) = Accel_Angle;</span><br><span class="line">  </span><br><span class="line">  X = A*X + B*U;</span><br><span class="line">  P = A*P*~A + Q;</span><br><span class="line">  K = P*~C*((C*P*~C+R).Inverse());</span><br><span class="line">  X += K*(Y - C*X);</span><br><span class="line">  P -= K*C*P;</span><br><span class="line"></span><br><span class="line">  Angle_Kalman = X(<span class="number">0</span>, <span class="number">0</span>), Bias_Kalman = X(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单轴姿态解算的效果如下，其中黄色为加速度计解算的角度，蓝色为陀螺仪积分得到的角度，红色和绿色分别为一阶互补滤波和卡尔曼滤波的角度曲线。在Arduino Nano平台下，输出频率为200Hz，实测单次解算耗时约3.2ms。完整的解算代码可在<a href="https://github.com/JYChenNK/IMU_SYS/tree/main/2-calIMU-Filter">此处下载</a>。</p>
<p><img src="/2021/03/02/IMU%E7%B3%BB%E7%BB%9F/2-IMU%E6%95%B0%E6%8D%AE%E8%9E%8D%E5%90%88%E4%B8%8E%E5%A7%BF%E6%80%81%E8%A7%A3%E7%AE%97/GIF 2021-3-31 14-42-51.gif" alt="GIF 2021-3-31 14-42-51" style="zoom:8 0%;"></p>
]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>IMU系统</tag>
      </tags>
  </entry>
  <entry>
    <title>MicroLabBox教程 2 - dSPACE硬件接口 基础篇</title>
    <url>/2021/06/12/dSPACE/dSPACE-02/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<p>本篇介绍dSPACE简单硬件接口的基本使用方法，包含数字量输入输出、模拟量输入输出、PWM信号输入输出，以及供电模块。</p>
<span id="more"></span>
<h3 id="数字量输出"><a href="#数字量输出" class="headerlink" title="数字量输出"></a>数字量输出</h3><img src="/2021/06/12/dSPACE/dSPACE-02/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E5%9F%BA%E7%A1%80%E7%AF%87/Untitled.png" class title="Untitled">
<ul>
<li><strong>Tips</strong><ul>
<li>管脚配置：<ul>
<li>dSPACE的数字量引脚分为A、B两组，A组为基本DIO，B为高级DIO（只接受互补信号）</li>
<li>基本DIO分为三个端口，每端口16个通道，可以设置为按组输出模式</li>
</ul>
</li>
<li>输出配置：可配置为2.5\3.3\5V三种电平</li>
<li>接受信号类型：布尔，或布尔向量（Matlab/Simulink默认类型为浮点型，对于输入需要加以数据类型转换）</li>
</ul>
</li>
</ul>
<blockquote>
<p>两种修改数据类型的方法</p>
<ul>
<li>在模块中修改输出属性</li>
<li>使用convert模块转换数据类型</li>
</ul>
</blockquote>
<img src="/2021/06/12/dSPACE/dSPACE-02/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E5%9F%BA%E7%A1%80%E7%AF%87/Untitled1.png" class title="Untitled">
<img src="/2021/06/12/dSPACE/dSPACE-02/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E5%9F%BA%E7%A1%80%E7%AF%87/Untitled2.png" class title="Untitled">
<h3 id="数字量输入"><a href="#数字量输入" class="headerlink" title="数字量输入"></a>数字量输入</h3><img src="/2021/06/12/dSPACE/dSPACE-02/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E5%9F%BA%E7%A1%80%E7%AF%87/Untitled3.png" class title="Untitled">
<ul>
<li><strong>Tips</strong><ul>
<li>管脚配置：dSPACE的所有数字量引脚均可设置为输入或输出模式，和输出一样可以配置为按组输</li>
<li>为保证模块正常工作，输入模块后面必须接有其他模块</li>
</ul>
</li>
</ul>
<h3 id="数字量信号的管脚映射"><a href="#数字量信号的管脚映射" class="headerlink" title="数字量信号的管脚映射"></a>数字量信号的管脚映射</h3><blockquote>
<p>ch1 - ch48  →  DB50 → 拓展板</p>
</blockquote>
<img src="/2021/06/12/dSPACE/dSPACE-02/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211102025047013.png" class title="image-20211102025047013">
<hr>
<h3 id="模拟量输出和输入"><a href="#模拟量输出和输入" class="headerlink" title="模拟量输出和输入"></a>模拟量输出和输入</h3><img src="/2021/06/12/dSPACE/dSPACE-02/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E5%9F%BA%E7%A1%80%E7%AF%87/2221635676258_.pic.jpg" class title="2221635676258_.pic.jpg">
<ul>
<li><strong>Tips</strong><ul>
<li>dSPACE有一组模拟量输出通道AO1，和两组模拟量输入通道AI1和AI2，AO1有16个通道，AI1包含24个通道，AI2有8个通道（32个输入，16个输出）；</li>
<li>所有模拟量引脚均为BNC接口，其内芯为信号线，外部为地线/反相线，测量/输出电压均为两线之差；</li>
<li>模拟量输入/输出范围均为-10V / +10V；</li>
<li>dSPACE模拟量输入输出模块内部对电压进行了标准化，输出/输入的范围为-1/+1，<strong>即指令1代表输出10V电压</strong>，需要进行单位转换（输入信号需要放大10倍，输出信号需要缩小10倍）</li>
</ul>
</li>
</ul>
<img src="/2021/06/12/dSPACE/dSPACE-02/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E5%9F%BA%E7%A1%80%E7%AF%87/Untitled5.png" class title="Untitled">
<img src="/2021/06/12/dSPACE/dSPACE-02/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E5%9F%BA%E7%A1%80%E7%AF%87/Untitled6.png" class title="Untitled">
<hr>
<h3 id="PWM输出和输入"><a href="#PWM输出和输入" class="headerlink" title="PWM输出和输入"></a>PWM输出和输入</h3><blockquote>
<p><strong>dPSACE所有DIO1管脚（48个通道）都支持配置为PWM输入和输出模式</strong></p>
</blockquote>
<img src="/2021/06/12/dSPACE/dSPACE-02/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E5%9F%BA%E7%A1%80%E7%AF%87/Untitled7.png" class title="Untitled">
<ul>
<li><strong>Tips</strong><ul>
<li>输出指定周期、指定占空比的PWM信号，周期单位为秒，占空比范围0-1，1代表100%占空比（一条直线），二者都可以在线修改</li>
</ul>
</li>
</ul>
<img src="/2021/06/12/dSPACE/dSPACE-02/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E5%9F%BA%E7%A1%80%E7%AF%87/Untitled8.png" class title="Untitled">
<ul>
<li>Tips<ul>
<li>dSPACE中包含两种PWM输入模块，一种返回脉冲宽度时间（单位s），另一种返回PWM频率（Hz）和占空比（0-1）</li>
</ul>
</li>
</ul>
<hr>
<h3 id="Power-Supply"><a href="#Power-Supply" class="headerlink" title="Power Supply"></a>Power Supply</h3><img src="/2021/06/12/dSPACE/dSPACE-02/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E5%9F%BA%E7%A1%80%E7%AF%87/WechatIMG223.jpeg" class title="WechatIMG223.jpeg">
<img src="/2021/06/12/dSPACE/dSPACE-02/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E5%9F%BA%E7%A1%80%E7%AF%87/Untitled9.png" class title="Untitled">
<ul>
<li>Tips<ul>
<li>dSPACE中包含两组电源输出，A组输出固定12V电压，不可被编程，上电即工作；B组为可调电压输出（2-20V），但输出功率较小；</li>
<li>对于数字电路/模块供电的情况，在工作功率/电流极低的情况下，可以使用数字量输入输出引脚直接供电，<strong>功率模块禁止此操作</strong>；</li>
<li><strong>任何涉及供电的配置、连线、测试务必十分小心！！！</strong></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>tutorials</category>
        <category>dSPACE</category>
      </categories>
      <tags>
        <tag>dSPACE</tag>
      </tags>
  </entry>
  <entry>
    <title>MicroLabBox教程 3 - dSPACE硬件接口 中级篇</title>
    <url>/2021/06/13/dSPACE/dSPACE-03/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E4%B8%AD%E7%BA%A7%E7%AF%87/</url>
    <content><![CDATA[<p>本篇主要介绍dSPACE的复杂硬件输入接口，包括正交编码器、串口、CAN总线、UDP。</p>
<span id="more"></span>
<h3 id="正交编码器输入"><a href="#正交编码器输入" class="headerlink" title="正交编码器输入"></a>正交编码器输入</h3><p><a href="https://zhuanlan.zhihu.com/p/350368518">编码器计数原理与电机测速原理—多图解析</a></p>
<img src="/2021/06/13/dSPACE/dSPACE-03/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E4%B8%AD%E7%BA%A7%E7%AF%87/Snipaste_2021-11-01_23-24-15.png" class title="Snipaste_2021-11-01_23-24-15.png">
<img src="/2021/06/13/dSPACE/dSPACE-03/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E4%B8%AD%E7%BA%A7%E7%AF%87/image-20211124170638327.png" class title="image-20211124170638327">
<p>💡 Tips</p>
<ul>
<li>dSPACE内用于接受正交编码器信号的解码器仅有6个，即最多能同时采集6路正交编码器信号；</li>
<li>可设置使用DIO1或DIO2连接编码器信号线，其中DIO2必须需要互补信号输入，用于保证强电磁干扰下的信号可靠性；</li>
<li>可在参数界面设置是否使用Z相信号输入，三根信号线必须以ABZ的顺序接入连续的3个dSPACE数字量引脚，仅首引脚号可设置；</li>
<li>编码器的测量模式可在角度模式和位置模式之间选择，角度模式下输出角度，位置模式下输出线数；</li>
</ul>
<hr>
<h2 id="RS-232-485串口"><a href="#RS-232-485串口" class="headerlink" title="RS-232/485串口"></a>RS-232/485串口</h2><p><a href="https://zhuanlan.zhihu.com/p/96506127">USART-串口通信</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/25893717">UART、RS232、TTL关系浅析</a></p>
<img src="/2021/06/13/dSPACE/dSPACE-03/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E4%B8%AD%E7%BA%A7%E7%AF%87/image-20211124170823354.png" class title="image-20211124170823354">
<img src="/2021/06/13/dSPACE/dSPACE-03/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E4%B8%AD%E7%BA%A7%E7%AF%87/Snipaste_2021-11-03_11-05-09.png" class title="Snipaste_2021-11-03_11-05-09.png">
<img src="/2021/06/13/dSPACE/dSPACE-03/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E4%B8%AD%E7%BA%A7%E7%AF%87/image-20211124170935214.png" class title="image-20211124170935214">
<img src="/2021/06/13/dSPACE/dSPACE-03/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E4%B8%AD%E7%BA%A7%E7%AF%87/image-20211124170949481.png" class title="image-20211124170949481">
<blockquote>
<p>使用时请注意接口的线序</p>
</blockquote>
<img src="/2021/06/13/dSPACE/dSPACE-03/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E4%B8%AD%E7%BA%A7%E7%AF%87/image-20211124171028615.png" class title="image-20211124171028615">
<hr>
<h3 id="CAN总线通信"><a href="#CAN总线通信" class="headerlink" title="CAN总线通信"></a>CAN总线通信</h3><p><a href="https://zhuanlan.zhihu.com/p/162708070#:~:text=CAN%E6%80%BB%E7%BA%BF%E6%98%AF%E4%B8%80%E7%A7%8D%E7%94%A8%E4%BA%8E%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%9A%84ECU%EF%BC%88%E7%94%B5%E5%AD%90%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%EF%BC%89%E4%B9%8B%E9%97%B4%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BA%BF%EF%BC%8CCAN%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%B8%80%E7%A7%8DISO%20%E5%9B%BD%E9%99%85%E6%A0%87%E5%87%86%E5%8C%96%E7%9A%84%E4%B8%B2%E8%A1%8C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%EF%BC%8C%E6%9C%89,ISO-11898%20%E5%92%8C%20ISO-11519%E4%B8%A4%E4%B8%AA%E7%B3%BB%E5%88%97%E3%80%82">一篇易懂的CAN通讯协议指南1</a></p>
<img src="/2021/06/13/dSPACE/dSPACE-03/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E4%B8%AD%E7%BA%A7%E7%AF%87/image-20211124171133316.png" class title="image-20211124171133316">
<p><strong>以DJI的M3508的电调C620为例，介绍如何使用dSPACE进行CAN总线数据通信</strong></p>
<ul>
<li>阅读文档，获取设备CAN总线通信的相关信息，包括：CAN总线通信速度、设备标志符(ID)、帧类型、帧格式、发送/接受报文格式和数据含义</li>
</ul>
<img src="/2021/06/13/dSPACE/dSPACE-03/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E4%B8%AD%E7%BA%A7%E7%AF%87/image-20211124171225993.png" class title="image-20211124171225993">
<ul>
<li>使用dSPACE的CAN总线模块</li>
</ul>

<img src="/2021/06/13/dSPACE/dSPACE-03/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E4%B8%AD%E7%BA%A7%E7%AF%87/image-20211124171256939.png" class title="image-20211124171256939">
<hr>
<h2 id="Ethernet-UDP通信"><a href="#Ethernet-UDP通信" class="headerlink" title="Ethernet UDP通信"></a>Ethernet UDP通信</h2><ul>
<li>基础概念 - IP地址，端口</li>
</ul>
<img src="/2021/06/13/dSPACE/dSPACE-03/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E4%B8%AD%E7%BA%A7%E7%AF%87/image-20211124171426517.png" class title="image-20211124171426517">
<ul>
<li>配置通信参数</li>
</ul>
<img src="/2021/06/13/dSPACE/dSPACE-03/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E4%B8%AD%E7%BA%A7%E7%AF%87/Snipaste_2021-11-04_10-21-58.png" class title="Snipaste_2021-11-04_10-21-58.png">
<img src="/2021/06/13/dSPACE/dSPACE-03/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E4%B8%AD%E7%BA%A7%E7%AF%87/image-20211124171742608.png" class title="image-20211124171742608">
<ul>
<li>按通信协议对发送数据进行打包、对接受数据进行解码</li>
</ul>
<img src="/2021/06/13/dSPACE/dSPACE-03/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E4%B8%AD%E7%BA%A7%E7%AF%87/Snipaste_2021-11-04_12-13-20.png" class title="Snipaste_2021-11-04_12-13-20.png">

<p>💡 使用帮助文档<br>对于dSAPCE提供的Simulink模块，右键Help打开dSPACE Help界面，可查看该模块的具体使用方法；</p>
]]></content>
      <categories>
        <category>tutorials</category>
        <category>dSPACE</category>
      </categories>
      <tags>
        <tag>dSPACE</tag>
      </tags>
  </entry>
  <entry>
    <title>MicroLabBox教程 5 - dSPACE程序设计 初级篇</title>
    <url>/2021/06/15/dSPACE/dSPACE-05/dSPACE%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%88%9D%E7%BA%A7%E7%AF%87/</url>
    <content><![CDATA[<p>本篇介绍dSPACE程序设计的一些基本方法、思维与技巧。<br><span id="more"></span></p>
<p>本部分在<code>Task1 - 关节角度指示器</code>的基础上进行讲解。<br><strong>Task 1 - 关节角度指示器</strong></p>
<blockquote>
<ul>
<li>dSPACE连接磁编码器和RGB模块，磁编码器的V G S分别连接DIO1的ch5-ch7，RGB的信号线连接DIO1的ch29-ch31；</li>
<li>当踝关节角度在-15deg到15deg之间，RGB模块亮绿灯；</li>
<li>当踝关节的角度由-15deg减小到-25deg，或由15deg增加到25deg，RBG模块由绿灯渐变为红灯；</li>
<li>当踝关节角度小于-25deg或大于25deg，RGB模块红灯闪烁；</li>
</ul>
</blockquote>
<img src="/2021/06/15/dSPACE/dSPACE-05/dSPACE%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%88%9D%E7%BA%A7%E7%AF%87/Untitled.png" class title="Untitled">
<hr>
<h2 id="1-使用局部寄存变量"><a href="#1-使用局部寄存变量" class="headerlink" title="1 - 使用局部寄存变量"></a>1 - 使用局部寄存变量</h2><blockquote>
<p>实现功能：通过点击按钮，对磁编码器测量到的踝关节角度进行校准；</p>
</blockquote>
<p>⭐ <strong>dSPACE中Simulink模型的执行过程（1）</strong></p>
<p>dSPACE运行时Simulink的主要模块每隔一固定时间会被全部执行一次；Matlab Function中直接定义的变量均为局部变量，每个周期执行完之后都会被释放掉，没有记忆性；</p>

<h3 id="实现变量寄存的两种方式"><a href="#实现变量寄存的两种方式" class="headerlink" title="实现变量寄存的两种方式"></a>实现变量寄存的两种方式</h3><ul>
<li><strong>1 - 寄存器（延时模块）</strong></li>
</ul>
<img src="/2021/06/15/dSPACE/dSPACE-05/dSPACE%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%88%9D%E7%BA%A7%E7%AF%87/image-20211124173611883.png" class title="image-20211124173611883">
<ul>
<li><strong>2- 局部寄存变量（persistent &amp; 初始化）</strong></li>
</ul>
<img src="/2021/06/15/dSPACE/dSPACE-05/dSPACE%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%88%9D%E7%BA%A7%E7%AF%87/image-20211124173637760.png" class title="image-20211124173637760">
<hr>
<h2 id="2-模块化与参数化"><a href="#2-模块化与参数化" class="headerlink" title="2 - 模块化与参数化"></a>2 - 模块化与参数化</h2><ul>
<li><strong>低耦合，高内聚</strong> - 将复杂函数功能模块化、功能化</li>
</ul>

<ul>
<li>使用<strong>SubSystem</strong>对功能化模块进行封装</li>
</ul>

<ul>
<li>使用<strong>Mask</strong>对模块参数进行封装</li>
</ul>
<img src="/2021/06/15/dSPACE/dSPACE-05/dSPACE%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%88%9D%E7%BA%A7%E7%AF%87/image-20211124173716755.png" class title="image-20211124173716755">

<p>💡 <strong><em>参数的作用域</em></strong></p>
<ul>
<li>通过Mask定义的参数仅在其内部所有模块和子模块中起作用；</li>
<li>在Simulink的Model Properties → Callbacks → InitFcn*下定义的参数可在全局调用；</li>
<li>参数可以在子系统中按名称进行传递；</li>
</ul>
<img src="/2021/06/15/dSPACE/dSPACE-05/dSPACE%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%88%9D%E7%BA%A7%E7%AF%87/image-20211124173742558.png" class title="image-20211124173742558">
<hr>
<h2 id="3-状态机"><a href="#3-状态机" class="headerlink" title="3 - 状态机"></a>3 - 状态机</h2><p><a href="https://zhuanlan.zhihu.com/p/47434856">什么是状态机？</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA">有限状态机 - 维基百科，自由的百科全书</a></p>
<blockquote>
<p>实现功能：当关节角度超过最大角度时，RGB保持红灯闪烁，直到上位机点击按钮清除该错误状态；</p>
</blockquote>
<ul>
<li><code>if-else</code> → <strong>系统状态</strong>、<strong>状态转移条件</strong>、<strong>状态执行动作</strong></li>
</ul>
<img src="/2021/06/15/dSPACE/dSPACE-05/dSPACE%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%88%9D%E7%BA%A7%E7%AF%87/image-20211124173837024.png" class title="image-20211124173837024">
<ul>
<li><strong>外骨骼的控制系统需要在静止、校准以及不同辅助模式下切换，都需要通过状态机来实现</strong></li>
</ul>
<hr>
<h2 id="4-使用全局寄存变量"><a href="#4-使用全局寄存变量" class="headerlink" title="4 - 使用全局寄存变量"></a>4 - 使用全局寄存变量</h2><blockquote>
<p>实现功能：当系统清除错误状态时，同时清空踝关节角度的校准偏置（<code>angle_bias=0</code>）</p>
<ul>
<li>错误形式</li>
</ul>
</blockquote>
<img src="/2021/06/15/dSPACE/dSPACE-05/dSPACE%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%88%9D%E7%BA%A7%E7%AF%87/Untitled15.png" class>
<p>⭐ <strong>dSPACE中Simulink模型的执行过程（2）</strong></p>
<p>在每隔控制周期，dSPACE按照<strong>信号流向</strong>，从首至尾<strong>顺序执行；禁止存在环路信号</strong></p>
<ul>
<li><strong>方法 1 - 使用单位延迟</strong></li>
</ul>
<img src="/2021/06/15/dSPACE/dSPACE-05/dSPACE%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%88%9D%E7%BA%A7%E7%AF%87/Untitled16.png" class title="Untitled">
<ul>
<li><p><strong>方法 2 - 使用全局寄存变量</strong></p>
<ul>
<li><p><strong>Step 1 创建 -</strong> 创建并设置全局变量，设置变量的维度和初值</p>
<img src="/2021/06/15/dSPACE/dSPACE-05/dSPACE%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%88%9D%E7%BA%A7%E7%AF%87/Untitled17.png" class title="Untitled">
</li>
<li><p><strong>Step 2 调用 -</strong>  在Matlab Function中通过<code>global</code>调用全局变量，并在<strong>Port and Data Manger</strong>中进行声明</p>
<img src="/2021/06/15/dSPACE/dSPACE-05/dSPACE%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%88%9D%E7%BA%A7%E7%AF%87/Untitled18.png" class title="Untitled">
</li>
<li><p><strong>Step 3 检查 -</strong>  正确调用后，寄存器模块内会列出所有调用该变量的模块</p>
<img src="/2021/06/15/dSPACE/dSPACE-05/dSPACE%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%88%9D%E7%BA%A7%E7%AF%87/Untitled19.png" class title="Untitled"></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>tutorials</category>
        <category>dSPACE</category>
      </categories>
      <tags>
        <tag>dSPACE</tag>
      </tags>
  </entry>
  <entry>
    <title>MicroLabBox教程 6 - dSPACE程序设计 中级篇</title>
    <url>/2021/06/16/dSPACE/dSPACE-06/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E4%B8%AD%E7%BA%A7%E7%AF%87/</url>
    <content><![CDATA[<p>本篇介绍使用Simulink进行dSPACE程序设计的技巧，涉及向量、矩阵的使用，以及定时器与中断；</p>
<span id="more"></span>
<h2 id="1-MUX"><a href="#1-MUX" class="headerlink" title="1 - MUX"></a>1 - MUX</h2><ul>
<li>使用Matlab Function进行向量合成，<strong>不要使用Mux</strong>，其输出无法识别</li>
</ul>
<hr>
<h2 id="2-通过索引使用不定长数组"><a href="#2-通过索引使用不定长数组" class="headerlink" title="2 - 通过索引使用不定长数组"></a>2 - 通过索引使用不定长数组</h2><blockquote>
<p>点击按钮后，接下来N秒内，RGB模块每秒显示一种红绿之间的随机颜色，其中N为可调参数(1-10)，N种随机颜色在按钮触发时被完全定义；</p>
</blockquote>
<img src="/2021/06/16/dSPACE/dSPACE-06/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E4%B8%AD%E7%BA%A7%E7%AF%87/Untitled.png" class title="Untitled">
<p>💡 Simulink的Matlab Function不支持创建可变长度数组，可以创建固定长度数组，再通过索引调用；</p>
<hr>
<h2 id="3-数组越界与计算超时"><a href="#3-数组越界与计算超时" class="headerlink" title="3 - 数组越界与计算超时"></a>3 - 数组越界与计算超时</h2><ul>
<li>进行数组索引时，元素不可越界，否则dSPACE直接宕机；（重启机器+重启ControlDesk）</li>
<li><p>当单个计算周期的计算耗时超过采样时间，ControlDesk会卡住；（重新开始测量）</p>
<ul>
<li><p>可通过Task Info → turnaroundTime 查看dSPACE的计算耗时，并改进算法效率；</p>
  <img src="/2021/06/16/dSPACE/dSPACE-06/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E4%B8%AD%E7%BA%A7%E7%AF%87/1.png" class title="Untitled">
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="4-定时器与定时中断"><a href="#4-定时器与定时中断" class="headerlink" title="4 - 定时器与定时中断"></a>4 - 定时器与定时中断</h2><blockquote>
<p>在多数的嵌入式系统中，往往存在多个不同运行频率的程序段；以控制系统为例，包含观测器和控制器两部分，观测器的执行频率一般高于控制器，以保障在控制计算之前系统当前的状态信息得到有效估计。</p>
</blockquote>
<ul>
<li><p><strong>Step 1 -</strong> 使用dSPACE的Timer Interrupt作为定时中断触发，并配置定时间隔</p>
  <img src="/2021/06/16/dSPACE/dSPACE-06/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E4%B8%AD%E7%BA%A7%E7%AF%87/2.png" class>
</li>
<li><p><strong>Step 2 -</strong> 在定时执行模块中添加触发连接，并将触发配置为function call</p>
  <img src="/2021/06/16/dSPACE/dSPACE-06/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E4%B8%AD%E7%BA%A7%E7%AF%87/3.png" class title="Untitled">
</li>
<li><p><strong>Step - 3</strong> 在不同执行速度的模块之间添加缓冲器，并取消勾选Ensure deterministic data transfer，以实异步通信</p>
  <img src="/2021/06/16/dSPACE/dSPACE-06/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E4%B8%AD%E7%BA%A7%E7%AF%87/4.png" class title="Untitled">
</li>
<li><p><strong>Step - 4</strong> 对于含有全局变量的情况，在模型配置中将Multi data store选项设置为none</p>
  <img src="/2021/06/16/dSPACE/dSPACE-06/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E4%B8%AD%E7%BA%A7%E7%AF%87/5.png" class title="Untitled">
</li>
<li><p><strong>Step - 5</strong> 配置定时器的中断优先级</p>
  <img src="/2021/06/16/dSPACE/dSPACE-06/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E4%B8%AD%E7%BA%A7%E7%AF%87/6.png" class title="Untitled">
</li>
</ul>
<p>⭐ <strong>dSPACE中Simulink模型的执行过程（3）</strong></p>
<ul>
<li><p>dSPACE使用独立的定时器去运行该定时器下的模块和程序，其中TimerA被用来执行基础定时程序；</p>
</li>
<li><p>每个<strong>定时模块</strong>/<strong>中断模块</strong>可以看作是一个独立的线程，线程之间需要缓冲器（消息队列，FIFO）来实现数据的传递；</p>
</li>
</ul>
<hr>
<h2 id="5-硬件中断"><a href="#5-硬件中断" class="headerlink" title="5 - 硬件中断"></a>5 - 硬件中断</h2><p><a href="https://www.qqxiuzi.cn/bianma/ascii.htm">ASCII编码转换，ASCII码在线查询工具</a></p>
<blockquote>
<p>实现功能：使用串口接收中断，在每次接受到串口数据时，向上位机发送‘Hello’</p>
</blockquote>
<ul>
<li>使用串口接收中断和模块，并搭建中断执行模块</li>
</ul>
<img src="/2021/06/16/dSPACE/dSPACE-06/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E4%B8%AD%E7%BA%A7%E7%AF%87/image-20211124175203609.png" class title="image-20211124175203609">
<hr>
<h2 id="6-异步通信"><a href="#6-异步通信" class="headerlink" title="6 - 异步通信"></a>6 - 异步通信</h2><blockquote>
<p>实现功能：在每次接受到串口数据时，RGB红灯闪烁三秒</p>
</blockquote>
<img src="/2021/06/16/dSPACE/dSPACE-06/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E4%B8%AD%E7%BA%A7%E7%AF%87/image-20211124175242419.png" class title="image-20211124175242419">
<p>💡在进行异步通信时，不同线程之间的缓冲器会使得信号被降采样，因此在异步通信中传递触发信号时，确保信号能够被正确传递；</p>
<h2 id="7-中断优先级"><a href="#7-中断优先级" class="headerlink" title="7 - 中断优先级"></a>7 - 中断优先级</h2><img src="/2021/06/16/dSPACE/dSPACE-06/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E4%B8%AD%E7%BA%A7%E7%AF%87/image-20211124175323799.png" class title="image-20211124175323799">
<p>⭐ <strong>dSPACE中Simulink模型的执行过程（4）</strong></p>
<blockquote>
<p>当dSPACE运行低优先级的中断处理函数（线程）时，当有高优先级的中断触发，则dSPACE会暂停当前任务，转去处理高优先级的任务，处理玩之后在返回继续执行之前的任务</p>
</blockquote>
<hr>
<h2 id="8-Host-Service"><a href="#8-Host-Service" class="headerlink" title="8 - Host Service"></a>8 - Host Service</h2><blockquote>
<p>通过Host Service指定上位机数据采集、显示和记录的频率，以满足特定的需求；<br>尽量避免在一个模型中配置多个Host Service，可能会导致数据采集紊乱；</p>
</blockquote>
<img src="/2021/06/16/dSPACE/dSPACE-06/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E4%B8%AD%E7%BA%A7%E7%AF%87/13.png" class title="Untitled">
<img src="/2021/06/16/dSPACE/dSPACE-06/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E4%B8%AD%E7%BA%A7%E7%AF%87/14.png" class title="Untitled">]]></content>
      <categories>
        <category>tutorials</category>
        <category>dSPACE</category>
      </categories>
      <tags>
        <tag>dSPACE</tag>
      </tags>
  </entry>
  <entry>
    <title>MicroLabBox教程 4 - dSPACE硬件接口 高级篇</title>
    <url>/2021/06/14/dSPACE/dSPACE-04/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/</url>
    <content><![CDATA[<p>本篇简单介绍如何将不支持的设备连接至dSPACE。</p>
<span id="more"></span>
<h2 id="Demo-1-dSPCAE控制跑台"><a href="#Demo-1-dSPCAE控制跑台" class="headerlink" title="Demo 1 - dSPCAE控制跑台"></a>Demo 1 - dSPCAE控制跑台</h2><img src="/2021/06/14/dSPACE/dSPACE-04/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/Untitled.png" class title="Untitled">
<img src="/2021/06/14/dSPACE/dSPACE-04/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/Untitled_1.png" class title="Untitled">
<img src="/2021/06/14/dSPACE/dSPACE-04/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/Untitled_2.png" class title="Untitled">
<hr>
<h2 id="Demo-2-dSPACE实时采集呼吸代谢数据"><a href="#Demo-2-dSPACE实时采集呼吸代谢数据" class="headerlink" title="Demo 2 - dSPACE实时采集呼吸代谢数据"></a>Demo 2 - dSPACE实时采集呼吸代谢数据</h2><img src="/2021/06/14/dSPACE/dSPACE-04/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/Untitled_3.png" class title="Untitled">
<img src="/2021/06/14/dSPACE/dSPACE-04/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/image-20211124172814323.png" class title="image-20211124172814323">
<img src="/2021/06/14/dSPACE/dSPACE-04/dSPACE%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/Untitled_7.png" class title="Untitled">]]></content>
      <categories>
        <category>tutorials</category>
        <category>dSPACE</category>
      </categories>
      <tags>
        <tag>dSPACE</tag>
      </tags>
  </entry>
  <entry>
    <title>MicroLabBox教程 7 - dSPACE程序设计 高级篇</title>
    <url>/2021/06/17/dSPACE/dSPACE-07/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/</url>
    <content><![CDATA[<p>本篇以NKAEX-MINI为例，介绍控制系统程序设计的基本方法</p>
<span id="more"></span>
<h2 id="程序整体框架"><a href="#程序整体框架" class="headerlink" title="程序整体框架"></a>程序整体框架</h2><p><strong>整体结构</strong></p>
<img src="/2021/06/17/dSPACE/dSPACE-07/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/Snipaste_2021-11-11_22-29-52.png" class title="Snipaste_2021-11-11_22-29-52.png">
<p><strong>传感器模组</strong></p>
<img src="/2021/06/17/dSPACE/dSPACE-07/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/Snipaste_2021-11-11_22-30-16.png" class title="Snipaste_2021-11-11_22-30-16.png">
<p><strong>控制器结构: 状态机 - 高层控制器 - 底层控制器 - 驱动器输出</strong></p>
<img src="/2021/06/17/dSPACE/dSPACE-07/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/Snipaste_2021-11-11_22-31-18.png" class title="Snipaste_2021-11-11_22-31-18.png">
<hr>
<h2 id="传感器模块与电机输出"><a href="#传感器模块与电机输出" class="headerlink" title="传感器模块与电机输出"></a>传感器模块与电机输出</h2><img src="/2021/06/17/dSPACE/dSPACE-07/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/Snipaste_2021-11-11_22-30-16.png" class title="Snipaste_2021-11-11_22-30-16.png">
<h3 id="拉力传感器与惠斯通电桥"><a href="#拉力传感器与惠斯通电桥" class="headerlink" title="拉力传感器与惠斯通电桥"></a>拉力传感器与惠斯通电桥</h3><img src="/2021/06/17/dSPACE/dSPACE-07/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/image-20211124181203343.png" class title="image-20211124181203343">
<h3 id="电机控制信号与电机控制软件"><a href="#电机控制信号与电机控制软件" class="headerlink" title="电机控制信号与电机控制软件"></a>电机控制信号与电机控制软件</h3><ul>
<li>控制模式每次需要配置为模拟量，启动控制前需要监控输入的模拟量是否在安全范围内</li>
</ul>
<img src="/2021/06/17/dSPACE/dSPACE-07/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/Snipaste_2021-11-12_14-01-29.png" class title="Snipaste_2021-11-12_14-01-29.png">
<ul>
<li>配置操作模式，设置速度模式、模拟量控制，配置最大速度（仅需配置一次）</li>
</ul>
<img src="/2021/06/17/dSPACE/dSPACE-07/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/image-20211124183228134.png" class title="image-20211124183228134">
<ul>
<li>调节模拟量增益（仅一次），和偏置（每次上电均需校准）；整定电机参数（每个月校准一次）</li>
</ul>
<img src="/2021/06/17/dSPACE/dSPACE-07/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/image-20211124183335223.png" class title="image-20211124183335223">
<blockquote>
<p>在每次实验之前，需要对模拟量信号的偏移进行调整<br>若需要进行参数整定，确保电机没有负载</p>
</blockquote>
<h3 id="肌电传感器的信号滤波"><a href="#肌电传感器的信号滤波" class="headerlink" title="肌电传感器的信号滤波"></a>肌电传感器的信号滤波</h3><img src="/2021/06/17/dSPACE/dSPACE-07/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/Untitled_9.png" class title="Untitled">
<p><strong>传感器连线</strong></p>
<img src="/2021/06/17/dSPACE/dSPACE-07/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/image-20211124181607135.png" class title="image-20211124181607135">
<p><strong>外骨骼传感信号转接板</strong></p>
<img src="/2021/06/17/dSPACE/dSPACE-07/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/image-20211124181708169.png" class title="image-20211124181708169">
<p><strong>电机编码器信号转接板</strong></p>
<img src="/2021/06/17/dSPACE/dSPACE-07/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/Untitled_12.png" class title="Untitled">
<hr>
<h2 id="步态状态机"><a href="#步态状态机" class="headerlink" title="步态状态机"></a>步态状态机</h2><blockquote>
<p>指定系统的工作状态，划分步态支撑相与摆动相，进行异常监测</p>
<ul>
<li>Mode → 系统工作状态</li>
<li>State  → 步态支撑/摆动相状态</li>
</ul>
</blockquote>
<img src="/2021/06/17/dSPACE/dSPACE-07/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/Untitled_13.png" class title="Untitled">
<hr>
<h2 id="High-Level-Controller"><a href="#High-Level-Controller" class="headerlink" title="High Level Controller"></a>High Level Controller</h2><blockquote>
<p>根据系统状态规划电机的工作模式，生成期望力矩曲线，并向输出Low Lever控制器发送期望速度、期望位置或期望力矩；</p>
</blockquote>
<img src="/2021/06/17/dSPACE/dSPACE-07/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/Untitled_14.png" class title="Untitled">
<ul>
<li>期望力矩曲线</li>
</ul>
<img src="/2021/06/17/dSPACE/dSPACE-07/dSPACE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%20-%20%E9%AB%98%E7%BA%A7%E7%AF%87/Untitled_15.png" class title="Untitled">
<ul>
<li>期望关节角度</li>
</ul>
<script type="math/tex; mode=display">\theta_{des,motor}=R\cdot\theta_{exo}-\theta_{margin}</script>]]></content>
      <categories>
        <category>tutorials</category>
        <category>dSPACE</category>
      </categories>
      <tags>
        <tag>dSPACE</tag>
      </tags>
  </entry>
  <entry>
    <title>肌电信号-原理与应用基础</title>
    <url>/2021/12/01/%E7%94%9F%E7%89%A9%E5%8A%9B%E5%AD%A6/%E8%82%8C%E7%94%B5%E4%BF%A1%E5%8F%B7-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<img src="/2021/12/01/%E7%94%9F%E7%89%A9%E5%8A%9B%E5%AD%A6/%E8%82%8C%E7%94%B5%E4%BF%A1%E5%8F%B7-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/image-20211202160304804.png" class title="image-20211202160304804">
<span id="more"></span>
<h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1 - 基本概念"></a>1 - 基本概念</h2><blockquote>
<p>“Electromyography (EMG) is an experimental technique concerned with the development, recording and analysis of myoelectric signals. Myoelectric signals are formed by physiological variations in the state of muscle fiber membranes.” (Basmajian, J.V. &amp; De Luca, C.J., 1985).</p>
</blockquote>
<p>肌电信号(Electromyography, EMG)，是指测量引发肌肉收缩的电信号，并反应肌肉的收缩程度，在医疗、康复、运动科学等诸多应用科学领域中广泛使用。在外骨骼领域中，肌电信号是评估外骨骼辅助有效性的重要指标之一。一般来说，我们可以从肌电信号中获得如下信息：</p>
<ul>
<li><strong>时机</strong> - 肌肉何时被激活</li>
<li><strong>力量</strong> - 肌肉收缩有多强烈</li>
<li><strong>疲劳</strong> - 肌肉能否调动它的全部力量</li>
</ul>
<p>在<strong>生物力学</strong>中，表面肌电信号应用更为广泛。其采用非侵入式的测量方式，电信号通过粘贴在皮肤上的电极进行获取。与之相对的侵入式肌电信号，需要将一根探针直接插入相应的肌肉。表面肌电信号非侵入、不会限制受试者的运动，但其信号质量一般低于侵入式测量。</p>
<hr>
<h2 id="2-测量原理"><a href="#2-测量原理" class="headerlink" title="2 - 测量原理"></a>2 - 测量原理</h2><p>如上所述，表面肌电传感器通过测量<strong>皮肤表面的电位变化</strong>来感知肌肉收缩，这种电位变化被称为动作电位(<a href="https://www.biomechanist.net/muscle-contraction/">action potential</a>，AP)。来自神经细胞的肌肉激励信号，通过运动终板传导至肌肉的退极化区(resulting depolarization zone, 约为1-3mm²)。在初始激励之后，运动单元的动作电位(MUAP)会沿肌纤维以2-6米/秒的速度传递，动作电位的传递过程类似于带有负电荷的离子沿肌纤维的方向移动(如下动图所示)。如果现在将一对电极沿平行肌纤维的方向放置于待测肌肉上方(如下右图)，则动作电位先后经过AB两个电极时，电极会测量到一个完整周期的类正弦信号。</p>
<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img src="/2021/12/01/%E7%94%9F%E7%89%A9%E5%8A%9B%E5%AD%A6/%E8%82%8C%E7%94%B5%E4%BF%A1%E5%8F%B7-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/action-potential-crash-course.gif" alt="action-potential-crash-course.gif" style="zoom:50%;"></div><div class="group-picture-column" style="width: 50%;"><img src="/2021/12/01/%E7%94%9F%E7%89%A9%E5%8A%9B%E5%AD%A6/%E8%82%8C%E7%94%B5%E4%BF%A1%E5%8F%B7-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/Untitled.png" alt="Untitled" style="zoom: 100%;"></div></div></div></div>
<!-- <img src="肌电信号-原理与应用基础/action-potential-crash-course.gif" alt="action-potential-crash-course.gif" style="zoom: 88%;" /><img src="肌电信号-原理与应用基础/Untitled.png" alt="Untitled" style="zoom: 31%;" /> -->
<p>一般情况下，多个运动单元会被同时激活，动作电位同时在多个肌纤维上传递，而电极测量的信号是由多个肌纤维上的动作电位合成的结果。一个典型的电极测量的原始肌电信号如下图蓝色波形所示，其由大量的动作电平合成而得；信号的幅值越高说明同一时叠加的动作电位越多，激活的肌纤维数量也越多；由于每一个动作电位产生的电压信号积分为零，因此合成的肌电信号平均值(一段时间的积分)也基本为零。表面肌电信号非常微弱，幅值在µV到低mV范围内，因此一般会使用1000到10000倍的放大器放大测量信号。根据相关文献，肌电图信号的能量分布基本上在0 ~ 500 Hz的频率范围内，主要成分在50 ~ 150 Hz的范围内。</p>
<img src="/2021/12/01/%E7%94%9F%E7%89%A9%E5%8A%9B%E5%AD%A6/%E8%82%8C%E7%94%B5%E4%BF%A1%E5%8F%B7-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/image-20211202160503752.png" class title="image-20211202160503752">
<hr>
<h2 id="3-表面肌电信号的干扰与降噪"><a href="#3-表面肌电信号的干扰与降噪" class="headerlink" title="3 - 表面肌电信号的干扰与降噪"></a>3 - 表面肌电信号的干扰与降噪</h2><p>表面电极有诸多优点，但也非常容易收到各种噪声的干扰，和相邻肌肉的串扰。下面讨论一些常见的干扰，以及可以采用的预防和降噪方法。</p>
<h3 id="a-生理噪声-physiological-noise"><a href="#a-生理噪声-physiological-noise" class="headerlink" title="a-生理噪声(physiological noise)"></a>a-生理噪声(physiological noise)</h3><p>生理噪音是指由身体内部生理活动所产生的，并可被表面电极接收到的电信号，例如<strong>心电信号</strong>和<strong>呼吸肌的收缩信号</strong>。对于这类干扰，可以将传感器放置远离干扰噪声源的地方并使用滤波方法来减少，但避免使用陷波滤波器。</p>
<h3 id="b-环境噪声-Ambient-Noise"><a href="#b-环境噪声-Ambient-Noise" class="headerlink" title="b-环境噪声(Ambient Noise)"></a>b-环境噪声(Ambient Noise)</h3><p>环境噪声包括<strong>电气工频干扰</strong>70-60Hz)和<strong>电缆伪影</strong>(cable artifacts，由线缆移动而导致的信号失真)。</p>
<p>电磁辐射在环境中几乎无处不在，但可以采用<strong>差动电极</strong>来减少这些干扰。表面肌电信号传感器由两个电极组成，它们沿着肌肉纤维以一定距离(通常为10mm)附着在皮肤上。两个电极都记录了基本噪声，也记录了具有延时的MUAPs(延时是因为电位沿着肌纤维扩散，从而首先到达第一个电极，然后到达第二个电极)。通过简单的差分计算消除环境噪声：</p>
<script type="math/tex; mode=display">V_{res}=(V_B+N_{env})-(V_A+N_{env})=V_B-V_A</script><p>对于电缆伪影，多数表面肌电传感器都会在测量电极后紧跟第一级放大器，从而传感器电缆的移动而产生的电缆伪迹减少到最小。</p>
<h3 id="c-基线噪声-Baseline-Noise"><a href="#c-基线噪声-Baseline-Noise" class="headerlink" title="c-基线噪声(Baseline Noise)"></a>c-基线噪声(Baseline Noise)</h3><p>基线噪声是肌电信号中最常见的噪声之一。它属于电化学噪声，由电极和皮肤中盐的离子交换所产生，当肌肉完全放松时所测量的信号主要就是基线噪声(以及生理噪声和环境噪声)。由于噪声发生在放大电路之前，所以基本无法被消除。基线噪声的大小与电极电阻的平方根成正比，因此可以通过增加电极的表面积来减少噪声，以及在使用肌电传感器前做好电极和皮肤的清洁工作。</p>
<h3 id="d-运动伪影-Movement-Artifacts"><a href="#d-运动伪影-Movement-Artifacts" class="headerlink" title="d-运动伪影(Movement Artifacts)"></a>d-运动伪影(Movement Artifacts)</h3><p>运动伪影也来自电极与皮肤之间的界面。一般来说，产生运动伪影的原因有两个：</p>
<ol>
<li>当肌肉收缩和放松时，肌肉的长度和横截面发生变化。这导致覆盖皮肤的拉伸和放松，进而导致皮肤电极界面的电化学平衡发生变化。</li>
<li>当肌肉产生一个力脉冲或从外部施加到身体上的力脉冲(例如脚跟撞击)，脉冲也会被转移到电极上。</li>
</ol>
<p>这两种情况都不可能完全消除干扰，只能通过对皮肤/电极进行良好的预处理和使用良好的过滤方法来缓解。</p>
<h3 id="4-肌肉串扰-Crosstalk-from-Other-Muscles"><a href="#4-肌肉串扰-Crosstalk-from-Other-Muscles" class="headerlink" title="4-肌肉串扰(Crosstalk from Other Muscles)"></a>4-肌肉串扰(<strong>Crosstalk from Other Muscles</strong>)</h3><p>当我们记录了表面肌电信号后，我们需要注意这个信号是否会收到其他肌肉的影响。如果需要确定某一个特定肌肉的激活情况，相对独立的肌肉能够被较为准确的测量(如胫骨前肌)，而位于肌群中的肌肉很难被准确测量(如位于股四头肌群中的股直肌)。即使小心翼翼地将电极放置在相应的肌肉上，信号仍然会被附近肌肉影响。通过选择两个差分电极之间相对较小的距离可以防止串扰，根据经验，两个电极之间的距离应不超过10mm。更多关于防止串扰的方法可以在其他文献中找到。</p>
<h3 id="f-脂肪组织-Fatty-Tissue"><a href="#f-脂肪组织-Fatty-Tissue" class="headerlink" title="f-脂肪组织(Fatty Tissue)"></a>f-脂肪组织(Fatty Tissue)</h3><p>一般来说，人体具有良好的导电性，但不同组织之间存在着很大的差异。其中脂肪组织起着决定性的作用，它类似于一个低通滤波器，过滤掉信号的高频部分。肌肉和电极之间的脂肪组织越多，过滤的作用就越强，当<strong>脂肪厚度大于40mm</strong>，肌电信号基本无法被检测到。这种特性也使得在不同受试者之间进行直接对比肌电信号的电压幅值比较非常困难，所以一般会根据肌肉的最大自主收缩(MVC)的对肌电信号进行归一化。</p>
<h3 id="g-皮肤和肌肉之间的相对运动-Relative-Movement-Between-Skin-and-Muscle"><a href="#g-皮肤和肌肉之间的相对运动-Relative-Movement-Between-Skin-and-Muscle" class="headerlink" title="g-皮肤和肌肉之间的相对运动(Relative Movement Between Skin and Muscle)"></a>g-皮肤和肌肉之间的相对运动(Relative Movement Between Skin and Muscle)</h3><p>当肌肉收缩时，它会在皮肤下面移动，贴在皮肤上的表面肌电传感器的测量区域也会发生变化。一方面，肌肉的动态收缩会导致信号来源(肌肉膜)和传感器之间的脂肪组织过滤器发生变化，从而影响信号的振幅和频谱；另一方面，它可能导致所测量的肌肉从传感器的视野中消失，而另一块不感兴趣的肌肉则成为了测量对象，进一步加重肌肉串扰的影响。</p>
<p>可以通过分析等距收缩(即没有长度变化的收缩)来避免运动带来的影响，这也是为什么等距收缩是研究最多的收缩类型。但在应用科学中，等距收缩对于肌肉运动的基本理解并不是那么重要，也很少发生在自然运动中。如何处理动态记录的数据以及这对数据解释的其他影响将在数据分析一节中解释。</p>
<p>肌电信号的质量取决于传感器的类型、放大器的质量、传感器的放置以及电极-皮肤的接触特性。如果您的实验室没有足够的预算来购买最新的表面肌电信号和放大器，您仍然可以改善后两点个方面。这些在准备阶段中发挥着核心作用，并对数据质量有巨大的影响。</p>
<hr>
<h2 id="4-肌电信号采集的准备工作"><a href="#4-肌电信号采集的准备工作" class="headerlink" title="4 - 肌电信号采集的准备工作"></a>4 - 肌电信号采集的准备工作</h2><h3 id="如何在皮肤上粘贴肌电传感器"><a href="#如何在皮肤上粘贴肌电传感器" class="headerlink" title="如何在皮肤上粘贴肌电传感器"></a>如何在皮肤上粘贴肌电传感器</h3><p>肌电电极应该尽可能的被<strong>粘贴在肌腹的中间</strong>。肌腹的信号幅值最大，信噪比更高，且更少的受到周围肌肉的串扰影响。每个肌电传感器应至少使用两个电极，通过差动电极将环境噪声影响降低到最小。电极应该<strong>沿着肌纤维的方向排列</strong>，使得动作电位先到达一个电极，再到达另一个电极。需要特别要注意肌肉纤维的排列和<strong>羽状角</strong>。表面肌电信号的幅值与电极间距离成正比，带宽与电极间距离成反比，因此两个电极之间的距离应该尽可能保持恒定以方便数据分析(如果不是由传感器给出的话)。</p>
<h3 id="如何清理皮肤"><a href="#如何清理皮肤" class="headerlink" title="如何清理皮肤"></a>如何清理皮肤</h3><p>表面肌电信号的质量很大程度上取决于皮肤和传感器之间的接触条件。清理皮肤的目的是尽可能减少皮肤的电阻，使表面肌电信号能够被准确地捕捉到(现代放大器通常设计为皮肤阻抗水平在5到50欧姆之间)。一般来说，在准备皮肤时要考虑两点：</p>
<ol>
<li><strong>剃除毛发</strong>。特别是受试者有大量出汗或需要分析高度动态的运动时，剃除毛发可以防止电极松动。出于卫生原因，请使用一次性剃须刀，使用后应立即丢弃。</li>
<li><strong>清洁皮肤</strong>。去除具有高抵抗力的死皮细胞，清洗皮肤上的污垢和汗水。大多数情况下，用浸过纯酒精的布轻轻擦拭皮肤就足够了。如果有更高的需求，可以用细砂纸去除表层的死皮细胞。可以通过万用表测量电极之间的电阻来检查皮肤清洁是否到位，下表可以作为一个粗略评估:</li>
</ol>
<img src="/2021/12/01/%E7%94%9F%E7%89%A9%E5%8A%9B%E5%AD%A6/%E8%82%8C%E7%94%B5%E4%BF%A1%E5%8F%B7-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/Untitled1.png" class title="Untitled">
<p>为了进一步了解肌电信号的质量，建议计算和检查信噪比(signal-to-noise ratio, SNR)：</p>
<script type="math/tex; mode=display">SNR=\frac{sEMG\ Amplitude}{Baseline \ Noise\ Amplitude}</script><img src="/2021/12/01/%E7%94%9F%E7%89%A9%E5%8A%9B%E5%AD%A6/%E8%82%8C%E7%94%B5%E4%BF%A1%E5%8F%B7-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/Untitled2.png" class title="Untitled">
<p>如果信噪比不理想，尝试检查传感器的粘贴或进一步清理皮肤；如果没问题，那就开始测量数据吧！</p>
<hr>
<h2 id="5-肌电信号的后处理"><a href="#5-肌电信号的后处理" class="headerlink" title="5 - 肌电信号的后处理"></a>5 - 肌电信号的后处理</h2><p>这里我们使用Matlab的信号分析工具箱Signal Analyzer，介绍肌电信号的后处理方法。实验数据是通过Delesys的无线肌电系统Trigo，并通过模拟量接口由dSPACE以5kHz的频率进行采集，测量了单个男性受试者以1.25m/s的速度在跑步机上行走时比目鱼肌、腓肠肌、胫骨前肌、股直肌、腘绳肌等8块的肌电信号，你可以在这里下载该实验的原始数据。</p>
<img src="/2021/12/01/%E7%94%9F%E7%89%A9%E5%8A%9B%E5%AD%A6/%E8%82%8C%E7%94%B5%E4%BF%A1%E5%8F%B7-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/Snipaste_2021-12-01_18-03-40.png" class title="Snipaste_2021-12-01_18-03-40.png">
<p>上图展示将数据加载进Signal Analyzer并进行显示，右侧为29s至30s(约一步)的比目鱼肌肌电信号。根据上面对于噪声干扰的分析，红色方框内的为基线噪声，绿色方框内的为运动伪影(因为这部分信号的频率和后面紫色框内的频率有显著差异)，紫色方框内为肌电的收缩信号。为了得到更有效的分析数据，挖掘肌电信号的信息，一般需要对原始肌电信号的后处理，主要涉及如下步骤：</p>
<img src="/2021/12/01/%E7%94%9F%E7%89%A9%E5%8A%9B%E5%AD%A6/%E8%82%8C%E7%94%B5%E4%BF%A1%E5%8F%B7-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/Untitled3.png" class title="Untitled">
<h3 id="高通滤波-High-Pass-Filter"><a href="#高通滤波-High-Pass-Filter" class="headerlink" title="高通滤波(High Pass Filter)"></a>高通滤波(High Pass Filter)</h3><p>对于大部分实验室而言，会使用数据采集卡或实时处理器，采集肌电系统的信号并和其他设备进行同步，并且大多数情况下会是模拟信号。不同设备间的电平基准可能存在不同，因此可能导致信号包含一定的直流偏置。如上所示的实验数据，其直流偏置约为<code>-0.003</code>。这部分的误差是由采集设备所造成的，因此并没有被归到上面的信号干扰中。直流偏置可以根据信号的平均值进行消除，也可以通过高通滤波器进行消除。这里采用Signal Analyzer的滤波功能，对原始数据先进行截止频率为20Hz的高通滤波。关于截止频率的选择，后面有更详细的解释。</p>
<img src="/2021/12/01/%E7%94%9F%E7%89%A9%E5%8A%9B%E5%AD%A6/%E8%82%8C%E7%94%B5%E4%BF%A1%E5%8F%B7-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/Untitled4.png" class title="Untitled">
<h3 id="整流矫正-Rectification"><a href="#整流矫正-Rectification" class="headerlink" title="整流矫正(Rectification)"></a>整流矫正(Rectification)</h3><p>由于肌电信号包含大量的噪声，所以在分析之前我们一般需要对数据进行平滑。但如上所述，原始肌电信号是双极性的，正负电压值的对称分布，若直接进行滑动均值滤波，会得到一条近乎直线的信号。所以为了提取有效信息，一般会对信号进行整流校正，也就是对每个数据点取绝对值。Signal Analyzer没有内置的信号整流功能，但可以通过Add Custom Function来添加，经过整流后的肌电信号如下图紫色曲线所示。</p>
<img src="/2021/12/01/%E7%94%9F%E7%89%A9%E5%8A%9B%E5%AD%A6/%E8%82%8C%E7%94%B5%E4%BF%A1%E5%8F%B7-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/Untitled5.png" class title="Untitled">
<h3 id="低通滤波-Low-Pass-Filter"><a href="#低通滤波-Low-Pass-Filter" class="headerlink" title="低通滤波(Low Pass Filter)"></a>低通滤波(Low Pass Filter)</h3><p>之后可以采用低通滤波对信号进行平滑，以提取信号的轮廓。在dSPACE中我们一般使用Butterworth低通滤波器，而这种形式滤波器在Signal Analyzer中没有集成，也需要自行定义(Signal Analyzer自带的低通滤波器非Butterworth滤波器)。论文中常用的低通截止频率有6Hz、10Hz、15Hz，阶数常为2阶或4阶。下面右图展示了3种截止频率下的滤波效果。</p>
<img src="/2021/12/01/%E7%94%9F%E7%89%A9%E5%8A%9B%E5%AD%A6/%E8%82%8C%E7%94%B5%E4%BF%A1%E5%8F%B7-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/Untitled6.png" class title="Untitled">
<h3 id="平滑-Smoothing"><a href="#平滑-Smoothing" class="headerlink" title="平滑(Smoothing)"></a>平滑(Smoothing)</h3><p>采用低通滤波会不可避免的向信号引入延迟，从而有可能导致对肌肉活跃度有错误的解读。比如上图中6Hz滤波的红色曲线，延时已经非常显著了。在后处理阶段，我们可以采用smooth(特指matlab函数)方法来平滑数据，而不进入延迟，但要注意这些方法无法在实时采集中使用。肌电信号常用的平滑方法是滑动均方根滤波：</p>
<script type="math/tex; mode=display">f_{r m s}=\sqrt{\frac{1}{T_{2}-T 1} \int_{T_{1}}^{T_{2}}[f(t)]^{2} \triangle t}</script><p>$T_2 - T_1$表示平滑的时间窗口大小，在运动科学研究中大约是20ms(快速运动)到500ms(缓慢或静态运动)。时间窗口越大，数据越平滑，但也越有可能误解肌电信号变化趋势。下图对比了均方根平滑和低通滤波的效果，可以看出均方根平滑能更准确反应肌电轮廓信息。</p>
<img src="/2021/12/01/%E7%94%9F%E7%89%A9%E5%8A%9B%E5%AD%A6/%E8%82%8C%E7%94%B5%E4%BF%A1%E5%8F%B7-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/Untitled7.png" class title="Untitled">
<p>上面所使用的均方根平滑也是一个自定义的函数，但Signal Analyzer也提供了多种其他的平滑方法，比如均值平滑、中值平滑、高斯平滑等，多数也有较好的平滑效果，例如窗口为0.1s的高斯平滑(如下所示)。</p>
<img src="/2021/12/01/%E7%94%9F%E7%89%A9%E5%8A%9B%E5%AD%A6/%E8%82%8C%E7%94%B5%E4%BF%A1%E5%8F%B7-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/Untitled8.png" class title="Untitled">
<hr>
<h2 id="6-功率谱分析"><a href="#6-功率谱分析" class="headerlink" title="6 - 功率谱分析"></a>6 - 功率谱分析</h2><p>在采集和处理数据时，我们需要时刻关注，信号是否反应真实的肌电。上面进行数据处理的过程中，我们基本采用经验和参考来进行滤波，而没有去关注信号的频率特性。本文第三部分部分讨论了诸多的干扰形式，我们也可以根据肌电信号和噪声的特性设计更合适的滤波器来处理数据，得到更真实的肌肉活动信息。</p>
<blockquote>
<p>除了用来设计滤波器外，频谱/功率谱分析还可以评估肌肉的疲劳程度，这将在下一部分予以介绍。</p>
</blockquote>
<img src="/2021/12/01/%E7%94%9F%E7%89%A9%E5%8A%9B%E5%AD%A6/%E8%82%8C%E7%94%B5%E4%BF%A1%E5%8F%B7-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/Untitled9.png" class title="Untitled">
<p>上图展示高通滤波后(去除直流偏置对于频谱的影响)肌电信号的功率谱，主要信号的频率分布在0-600Hz的范围内，这其中包含了肌电以及所有的噪声。频谱在20-250Hz频段内信号最为集中；在200-500Hz频段内有一个较宽的突起，反应一种稳定分布的信号(这很有可能来自肌电信号)；超过600Hz后分布一个比较稳定的白噪声，并带有几个小尖峰。</p>
<p>为了进一步确定肌电信号和频段，分离肌电信号和各种噪声，可以提取出步态摆动阶段到支撑前期的肌电信号，这段时间我们所研究的肌肉-比目鱼肌-基本处于完全放松状态，所测量的信号完全由各种噪声组成。下图展示了这些噪声的功率谱，其主要分布在低频段，在0-100Hz之间有较大的幅值，并随频率逐渐减少，同时也可以看出高频段的几个尖峰也都来自噪声。两个曲线所夹便是真实肌电信号的部分，分布在50Hz到600Hz之间。</p>
<blockquote>
<p>在这篇博客的<a href="https://www.biomechanist.net/electromyography-basics-of-practical-application/">参考博客</a>中，作者通过肌电传感器上内置惯性传感器的加速度数据来分析来自运动伪影噪声的频谱，其频段主要分布在20Hz到50Hz之间，和我们的结果相类似。</p>
</blockquote>
<img src="/2021/12/01/%E7%94%9F%E7%89%A9%E5%8A%9B%E5%AD%A6/%E8%82%8C%E7%94%B5%E4%BF%A1%E5%8F%B7-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/Untitled10.png" class title="Untitled">
<p>在频谱分析的基础上，我们可以设计带通滤波器对信号进行滤波，以去除噪声的影响。但注意到噪声和肌电信号在很大频率范围内的频谱是相互叠加的，因此基本不可能将两者完全分开，但我们也有理由相信滤除一些低频和高频的成分是有意义的。一些文献使用低频20Hz、高频500Hz的带通滤波，而且多数肌电传感中已经内置了这样的带通滤波电路(比如我们的Delesys)，但也有一些文献质疑这样会滤除太多的肌电成分。</p>
<p>为了增加对肌电信号和噪声特性的理解，让我们尝试更激进的滤波参数。但注意这一部分的内容并没有更多的文献支撑，仅作为一个开放性的讨论。下图展示使用低通150Hz、高通600Hz的带通滤波后的数据(绿色)，可以发现在肌肉放松阶段的噪声(基线噪声、运动伪影)有了显著的减少，而收缩阶段的肌电信号没有本质改变。</p>
<img src="/2021/12/01/%E7%94%9F%E7%89%A9%E5%8A%9B%E5%AD%A6/%E8%82%8C%E7%94%B5%E4%BF%A1%E5%8F%B7-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/Untitled11.png" class title="Untitled">
<p>对带通滤波后的信号进一步进行整流和平滑处理，可得到噪声更小、放松阶段信号更平稳的肌电数据，如下右图所示；但同样可以观察到收缩阶段信号峰值有明显衰减，表明一部分有效的肌电信号也被滤波器所滤除。</p>
<img src="/2021/12/01/%E7%94%9F%E7%89%A9%E5%8A%9B%E5%AD%A6/%E8%82%8C%E7%94%B5%E4%BF%A1%E5%8F%B7-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/Untitled12.png" class title="Untitled">
<hr>
<h2 id="7-数据分析"><a href="#7-数据分析" class="headerlink" title="7 - 数据分析"></a>7 - 数据分析</h2><p>正如本文开始所述，通过肌电信号可以得到关于肌肉的<strong>时机</strong>、<strong>力量</strong>和<strong>疲劳</strong>三种信息，它们分别对应肌电信号的时间(相位)、幅值和中值频率。</p>
<h3 id="肌肉的激活时间"><a href="#肌肉的激活时间" class="headerlink" title="肌肉的激活时间"></a>肌肉的激活时间</h3><p>一般来说，在分析肌肉的激活时间时，一般不关心肌肉的收缩类型(同心\偏心\等距)和收缩程度，而仅关注肌肉合适收缩和放松(开和关)。为了以一种标准化的方式确定肌肉何时被激活，会先采集一组肌肉放松状态时的信号，并确定背景噪声的的均值和方差；当肌电信号超过噪声均值两倍标准差(95%置信度)，并持续一定的时间(通常是10 - 50ms)，认为肌肉激活。这种方法也被称为双阈值方法，因为必须同时超过振幅阈值和时间阈值。</p>
<p>由于人体任何形式的运动都具有协调性变异性，即使在非常标准的运动中，不同周期的表面肌电信号也有非常显著的差异。因此，一般会通过多次重复来描述某一运动模式。为此每个周期被划分为固定数量的段(例如100)，每个段的数据点被平均。之后我们就可以检查肌肉在运动周期的百分之几被激活，以及何时完全放松。</p>
<p><img src="/2021/12/01/%E7%94%9F%E7%89%A9%E5%8A%9B%E5%AD%A6/%E8%82%8C%E7%94%B5%E4%BF%A1%E5%8F%B7-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/image-20211202161648751.png" alt="image-20211202161648751" style="zoom: 50%;"></p>
<h3 id="肌肉的收缩力"><a href="#肌肉的收缩力" class="headerlink" title="肌肉的收缩力"></a>肌肉的收缩力</h3><p>可以明确的是，表面肌电信号和肌肉产生的力之间有关系，但，这个关系非常复杂，很难通过简单的变换关系的得到。它涉及从神经肌肉的收缩动力学、肌肉骨骼模型、人体关节的运动特性的共同影响，与最大肌肉力、肌肉收缩速度、肌肉长度、羽状角、肌肉肌腱刚度都有关。我们可以推测，当肌电信号的幅值增加时，肌肉中产生的力量或收缩速度也会增加，但这种定性的分析有时可能无法满足定量评估的需求。</p>
<p>多年来这个复杂问题始终没有得到很好的解决，这也是为什么绝大多数的肌肉研究都集中在等距收缩，这种收缩下肌肉力和肌电信号的关系会尽可能小的受到肌肉移动、运动伪影、肌肉串扰的因素的影响。在等距收缩时，表面肌电信号和肌肉力基本成线性关系，线性度因肌肉而异。然而在人体的自然运动中基本不存在等距收缩的过程，毕竟等距收缩不会产生任何形式的运动。如果想由表面肌电信号分析非等距运动的肌肉力特性，必须将分析限制在运动接近等距收缩的时间内。例如选择关节角速度等于零时的左右一小段时间(1%周期)，并评估平均肌肉活跃度。</p>
<p>在不同的实验中，由于受试者肌肉特性、脂肪特性、皮肤特性、电极粘贴位置的不同，基本无法做到测量信号有相同的幅值等级。因此在进行幅度分析时，需要对信号进行归一化，以保证幅值是可以对比的。在实践中经常使用最大主动收缩(maximum voluntary contraction, MVC)的峰值作为归一化标准，肌电信号也就表示为MVC的百分比。但可能存在某些肌肉的MVC非常高，但在特定运动下收缩程度较小，从而使信号整体数值较低。对此也可以采用其他合适的归一化策略，但要确保归一化是有效的。</p>
<h3 id="肌肉疲劳"><a href="#肌肉疲劳" class="headerlink" title="肌肉疲劳"></a>肌肉疲劳</h3><p>个体肌肉疲劳是生物力学分析中的一个重要因素。在没有测量肌电信号时，当肌肉不能保持一定的收缩时，才会被归类为疲劳(这个时间点也被称为疲劳点，point of failure)。然而，肌肉疲劳是一个渐进的过程，我们可以通过肌电信号频率特性来获取肌肉的疲劳信息。</p>
<p><img src="/2021/12/01/%E7%94%9F%E7%89%A9%E5%8A%9B%E5%AD%A6/%E8%82%8C%E7%94%B5%E4%BF%A1%E5%8F%B7-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/Untitled13.png" alt="Untitled" style="zoom: 25%;"></p>
<p>表面肌电信号的功率谱分布曲线如上所示，这个图仅是一个示意，实际频谱不会如此光滑；另外这个频谱采用的是正常坐标，而上一小节我们绘制的功率谱则是半对数坐标。一般情况下，我们会采用4种特征来刻画肌电信号的功率谱特性：<strong>总功率</strong>、<strong>峰值功率</strong>(频谱的最大值)、<strong>均值频率</strong>(mean frequency,以功率幅值为系数的频率加权平均)，以及<strong>中值频率</strong>(median frequency, 将区域分成两等份的频率)。</p>
<p>当受试者持续执行适当强度、高频的肌肉收缩时，这些频率参数会随时间推移而发生变化。其中均值频率和中值频率会随时间的增加而降低，反应动作电位在肌纤维中的传导速度的下降。下图展示的23分钟行走过程胫骨前肌的肌电信号，并分别对开始和结束2分钟的信号进行功率谱分析。由于该部分实验数据的采集频率仅有500Hz， 我们仅能得到0-250Hz范围内的频谱特性，但依然可以从中得到一些现象。可以看出，后两分钟肌电信号的整体能量有明显的下降，反应在是时域上信号的幅值有明显的降低；尽管并不是非常明显，我们依然可以看出最后两分钟信号的功率分布有向低频方向移动的趋势，通过计算，它们的中值频率分别为177.5Hz和164.9Hz，下降了12.6Hz。</p>
<img src="/2021/12/01/%E7%94%9F%E7%89%A9%E5%8A%9B%E5%AD%A6/%E8%82%8C%E7%94%B5%E4%BF%A1%E5%8F%B7-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/Untitled14.png" class title="Untitled">
<p>肌肉疲劳研究有两方面应用。首先是识别肌无力问题，以及因此所导致的运动功能障碍和疾病。二是进行力量训练的监测，因训练引起的短期疲劳是肌肉生长的基本要求。</p>
<hr>
<p><strong>Reference</strong></p>
<p><a href="https://www.biomechanist.net/electromyography-basics-of-practical-application/">Electromyography - Basics of Practical Application</a></p>
<p><a href="https://www.youtube.com/watch?v=J7_LEoYuqww">EMG II Electromyography II Muscle electrical activity</a></p>
<p><a href="https://isek.org/resources/">Resources - International Society of Electrophysiology and Kinesiology (ISEK)</a></p>
<p><a href="http://www.seniam.org/">Welcome to SENIAM</a></p>
<p><a href="https://www.noraxon.com/wp-content/uploads/2014/12/ABC-EMG-ISBN.pdf">Konrad, P., 2006. The ABC of EMG: a practical introduction to kinesiological electromyography. Noraxon USA, Inc.</a></p>
<p><a href="https://www.delucafoundation.org/download/bibliography/de-luca/078.pdf">Luca, C.J. de, 1997. The Use of Surface Electromyography in Biomechanics. Journal of Applied Biomechanics 13, 135–163.</a></p>
<p><a href="https://www.delsys.com/downloads/TUTORIAL/a-practicum-on-the-use-of-semg-signals-in-movement-sciences.pdf">Luca, C.J. de, 2008. A Practicum on the Use of sEMG Signals in Movement Sciences. Delsys Inc. </a></p>
<p><a href="https://pdfs.semanticscholar.org/c348/f06416aa03154c40bb82d5b26cef40e5840d.pdf">Wang, J., Tang, L., E Bronlund, J., 2013. Surface EMG Signal Amplification and Filtering. International Journal of Computer Applications 82, 15–22. </a></p>
]]></content>
      <categories>
        <category>biomechanics</category>
      </categories>
      <tags>
        <tag>生物力学</tag>
        <tag>肌电信号</tag>
      </tags>
  </entry>
  <entry>
    <title>伯克利下肢外骨骼系统-结构与控制</title>
    <url>/2021/11/01/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/BLEEX/</url>
    <content><![CDATA[<p>BLEEX (Berkeley Lower Extremity Exoskeleton) 是世界上首个具有负载搬运能力的自主下肢外骨骼。本文将总结BLEEX的结构设计与控制方法。</p>
<img src="/2021/11/01/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/BLEEX/37221533727400.5fb0a22b2d89e.jpg" class>
<span id="more"></span>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在平地上重物通常用轮式交通工具进行运输，而在复杂地形环境下常常会遇到阻碍，因此用腿式运动的方式进行物资运输具有很大的前景。BLEEX是第一个实现这种功能的机器人系统，它为穿戴者提供各种地形下搬运负载的能力。BLEEX由两条拟人化动力腿、一个电源供应器和一个累背包框架组成，其通过跟随穿戴者的运动或运动意图来实现负载的搬运与移动，好像为穿戴者佩戴上假肢一样。BLEEX通过借助机器人的驱动“力量”和人的导航“智慧”来实现非结构化、不确定地形上的重物搬运，作为一个多功能的运输平台，能够为士兵、救灾人员、消防员提供紧急物资的搬运能力。</p>
<p><img src="/2021/11/01/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/BLEEX/1580637468954.png" style="zoom:80%;"></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote>
<p>在20世纪60年代早期，美国国防部表示有兴趣开发一种“人体放大器” - 一种增强士兵起重和携带能力的动力装甲。1962年，美国空军让康奈尔航空实验室(Cornell Aeronautical Laboratory)研究使用机器人系统实现人体放大器的可行性。在后来的研究中，康奈尔实验室设计了一种拟人形结构的机器人，并可以完成大多数想要完成的任务(Mizen 1965)，并将其命名为外骨骼。1960年到1971年，通用电气开发并测试了一个人体放大器的原型，称为哈迪曼(Hardiman)。哈迪曼是一套由人类操作员穿戴的外骨骼，外骨骼能够跟随人类操作员的运动。但这些研究发现，使用主从系统<strong>复制</strong>和<strong>放大</strong>人类的全部动作和是不现实的，人类感知的困难和系统的复杂性使它无法行走。</p>
<p>上世纪六七十年代，贝尔格莱德大学(University of Belgrade)开发了几套外骨骼系统，用以帮助截瘫患者。虽然这些早期的设备仅限于预定义的动作，并且取得了有限的成功，但所开发的平衡算法仍在许多双足机器人中使用。<strong>RoboKnee</strong>是一种动力膝关节外骨骼，它与使用者的膝关节平行工作，并将载荷传递到使用者的脚踝(Pratt et al. 2004)。<strong>HAL</strong>是一种连接大腿和小腿的矫形器，它根据佩戴者发出的肌电信号移动病人的下肢(Kawamoto,Sankai 2002)。</p>
<p>在伯克利的研究工作中，我们将增强人类能力相关的技术分为下肢外骨骼和上肢外骨骼。原因有两方面;首先，我们可以预见在不久的将来，无论是单独的下肢外骨骼还是上肢外骨骼都会有大量的应用。其次，我们认为外骨骼还处于早期阶段，在尝试整合它们之前，还需要进一步的研究来确保上肢外骨骼和下肢外骨骼能够独立工作。考虑到这一点，我们分别进行了下肢和上肢外骨骼的设计，而暂时不考虑整体外骨骼的开发。下面我们将首先对伯克利分校的上肢外骨骼的工作进行总结，然后继续介绍BLEEX项目。</p>
<p>在20世纪80年代中期，我们启动了几个关于上肢外骨骼系统的研究项目，称之为人体扩展器(Kazerooni 1990)。上肢外骨骼的主要功能是增强人的力量来操作一些重的物体。施加在穿戴者绳上的力通常比操纵负载所需的力小得多。当一个工人使用上肢外骨骼来移动一个负载时，该设备自己承担大部分的重量，同时将负载的实际重量作为一个自然的反馈传递给用户。例如，一个物体每40磅的重量，工人自身可能只能支撑4磅，而设备支撑剩下的36磅。在这种情况下，工作人员仍然可以感觉到负载的重量，并据此判断自己的动作。又例如，假设一个工人使用这个设备来操作一个动力扭矩扳手(操作时会有强烈振动)，该装置可以减少从扳手传递到工人手臂上的力，并过滤那些高频的机械振动，这样工人就能更轻松更稳定的操纵扳手。</p>
<p>与上肢外骨骼不同，伯克利下肢外骨骼(BLEEX)不是矫形器或支架，它被设计成将负载重量传递到地面(而不是传递给佩戴者)，从而提高穿戴者承载重物的能力。BLEEX推出了四个新功能。(a) 开发了一种新的<strong>控制结构</strong>，通过测量外骨骼本身来控制外骨骼(Kazerooni et al. 2005)。这消除了由于直接测量交互力而导致的不稳定性(Kazerooni et al. 2005)。(b) 开发了一系列的<strong>高功率、高能量的电源</strong>，这些电源足够小，使BLEEX成为一个真正的现场操作系统(McGee, Raade, and Kazerooni 2004)。(c) 开发了具有特殊通信协议和硬件的<strong>主体局域网</strong>(Local Area Network)，以简化和减少外骨骼控制所需的所有传感器和执行器的布线任务(Kim, Anwar, and Kazerooni 2004)。(d) 设计了<strong>灵活和通用的机械结构</strong>来降低复杂性和功耗(Chu, Kazerooni, and Zoss 2005)。</p>
</blockquote>
<h2 id="结构设计"><a href="#结构设计" class="headerlink" title="结构设计"></a>结构设计</h2><h3 id="伪拟人化外骨骼整体结构"><a href="#伪拟人化外骨骼整体结构" class="headerlink" title="伪拟人化外骨骼整体结构"></a>伪拟人化外骨骼整体结构</h3><p>在外骨骼的结构设计中，通常会采用拟人化的设计思路，即将外骨骼与人体的<strong>自由度</strong>和肢<strong>体长度</strong>相匹配，使外骨骼的腿位置、关节轴线与人体完全一致。这种设计方案想法简单、自然，简化类似机械干涉的问题，但人体的关节运动(包含旋转和平移)无法通过简单技术来实现，且结构尺寸需和人体完全一致，可调节性差。而一些非拟人化的设计取得了很好的成功，例如自行车。非拟人化结构为外骨骼腿的设计带来更多的可能，但比较困难设计出与人腿功能类似的结构，同时安全性和机械干涉等问题也进一步增加了非拟人化结构的难度。</p>
<p>为了最大化安全性同时最小化环境干涉，BLEEX采用一种接近接近拟人化(Pseudo-anthropomorphic)的结构，BLEEX的腿在运动学上与人类的腿相似，但又不包括人类腿的所有自由度。BLEEX的所有关节均为纯旋转关节，同时由于外骨骼与人体的运动学不完全一致，因此人体与外骨骼只有两处刚性接触（足和躯干），其他任何地方的刚性接触都会产生很大的力。伪拟人化使得BLEEX能够轻松适应不同的穿戴者。</p>
<p><img src="/2021/11/01/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/BLEEX/1580638847708.png" style="zoom: 67%;"></p>
<h3 id="BLEEX外骨骼的自由度与关节设计"><a href="#BLEEX外骨骼的自由度与关节设计" class="headerlink" title="BLEEX外骨骼的自由度与关节设计"></a>BLEEX外骨骼的自由度与关节设计</h3><p>BLEEX的每条腿具有7个自由度：</p>
<ul>
<li>髋关节3自由度</li>
<li>膝关节1自由度（矢状面上的纯转动）</li>
<li>踝关节3自由度</li>
</ul>
<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img src="/2021/11/01/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/BLEEX/1580641561202.png" style="zoom: 67%;"></div><div class="group-picture-column" style="width: 50%;"><img src="/2021/11/01/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/BLEEX/1580642587844.png" style="zoom:67%;"></div></div></div></div>
<p>人的髋关节是一个球窝关节，具有三个自由度。因此一个很自然的想法是设计一个三轴轴线通过人体髋关节球窝的外骨骼。但通过一些前期的样机和实验发现，这种结构存在奇异性（欧拉角）和运动角度限制的问题，因此最终BLEEX的髋关节设计成上图所示形式：两条腿的旋转轴合并为后侧一个单轴，并在每条外骨骼的腿上增加一个不通过人体髋关节球窝的附加旋转轴；外骨骼的外展/内收轴（hip abduction/adduction）和伸展/弯曲轴（flexion/extension）的轴线都通过人体髋关节。</p>
<p>人体的膝关节是一个复合旋转和平移的复杂关节，BLEEX膝关节选择一个纯旋转关节使得设计简化并增加鲁棒性，同时方便动态建模。</p>
<p>对于踝关节，为了简化设计，BLEXX的踝关节只有伸展/弯曲轴通过人体的踝关节。同时BLEEX为前脚掌增加了一个自由度（柔性），使得外骨骼与人体的脚掌更加贴合。</p>
<h3 id="关节的运动范围"><a href="#关节的运动范围" class="headerlink" title="关节的运动范围"></a>关节的运动范围</h3><p>BLEEX的运动学接近于人体的运动学，因此BLEEX的关节活动范围由人体关节活动范围所决定。BLEEX的关节运动范围应当大略大于人体正常行走时的关节运动范围，同时安全性又要求BLEEX的关节运动范围应小于人体关节的最大活动角度，如表1所示。</p>
<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img src="/2021/11/01/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/BLEEX/1580643507721.png" style="zoom:100%;"></div><div class="group-picture-column" style="width: 50%;"><img src="/2021/11/01/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/BLEEX/1580644405911.png" style="zoom:40%;"></div></div></div></div>
<h3 id="辅助关节与驱动方式"><a href="#辅助关节与驱动方式" class="headerlink" title="辅助关节与驱动方式"></a>辅助关节与驱动方式</h3><p>出于控制和效率的考虑，只有部分关节是被驱动的，而其余的关节为顺从（被动）关节。驱动关节的选择是从功率角度进行考虑：踝关节和髋关节的弯曲/伸展运动在步态运动中做比较多的正功；膝关节虽然在步态运动中更多的起到能量吸收的作用，但在上下楼梯时是做最主要的做功关节；除此之外，髋关节的外展/内收运动提供主要的侧向平衡力，因此也作为驱动关节之一。最终BLEEX的每条腿具有四个驱动关节，如上右图所示。</p>
<p>BLEEX采用液压驱动，具有体积小、重量轻、驱动力大等优点，但设计非常复杂。BLEEX的液压系统能够支持在75Kg的负载（包含外骨骼）下以1.3m/s的速度前进，相应的驱动功率为2.27KW。</p>
<h3 id="模块化结构部件设计"><a href="#模块化结构部件设计" class="headerlink" title="模块化结构部件设计"></a>模块化结构部件设计</h3><p>整体模型如图9所示：</p>
<p><img src="/2021/11/01/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/BLEEX/1580644937819.png" style="zoom:67%;"></p>
<h4 id="关节设计"><a href="#关节设计" class="headerlink" title="关节设计"></a>关节设计</h4><p>BLEEX所有的关节具有统一的结构，但每个关节的驱动位置不同，类模块化的设计方便加工和装配。</p>
<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img src="/2021/11/01/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/BLEEX/1580644875143.png" style="zoom:45%;"></div><div class="group-picture-column" style="width: 50%;"><img src="/2021/11/01/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/BLEEX/1580645648736.png" style="zoom:100%;"></div></div></div></div>
<h4 id="足部设计"><a href="#足部设计" class="headerlink" title="足部设计"></a>足部设计</h4><p>BLEEX的足部是一个非常重要的部分（也是出液压驱动外设计最复杂的部分），因其所包含的诸多功能：</p>
<ul>
<li>它将外骨骼和负载的重量传递到地面上，因此要保证结构完整性和长寿命</li>
<li>它是人体和外骨骼的两处刚性接触之一，因此要保证足够的舒适性</li>
<li>它测量足底压力中心的位置，用来识别脚在地面上的状态</li>
<li>它测量人体负载的分布，从而进行控制</li>
</ul>
<p>如图11所示，BLEEX足部的主要结构由刚性的脚跟和柔性的前脚掌组成，具有三层结构。刚性脚跟用来传递力与载荷，柔性脚掌使穿戴者更舒适。顶层结构用来固定穿戴者的鞋子，底层结构含有足底开关用来检测脚与地面接触的状态，中层含有压力传感器用来测量人体与地面之间的压力（不包含外骨骼的作用力）。这些测量数据用于外骨骼的实时控制。</p>
<h4 id="大腿和小腿设计"><a href="#大腿和小腿设计" class="headerlink" title="大腿和小腿设计"></a>大腿和小腿设计</h4><p>BLEEX的大腿和小腿主要用来连接和结构支撑，这两者都被设计为可调节的结构，以方便适应不同的穿戴者。为了使液压回路最小化，设计了在阀门、执行机构、供应和回油管路之间的流体回路。</p>
<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/2021/11/01/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/BLEEX/1580647405832.png" style="zoom:67%;"></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/2021/11/01/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/BLEEX/1580647416350.png" style="zoom:67%;"></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/2021/11/01/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/BLEEX/1580647498568.png" style="zoom: 67%;"></div></div></div></div>
<h4 id="躯干设计"><a href="#躯干设计" class="headerlink" title="躯干设计"></a>躯干设计</h4><p>躯干的前侧装有操作员佩戴的安全带，这是与穿戴者的第二个刚性附着点。一般来说，绑带是由一个弯曲的，刚性的后板连接到躯干。它还包括舒适的背包状背带，可以抓住操作员，并将任何力量分配到操作员的躯干、胸部、肩膀和上背部。与大多数活动的背带不同，外骨骼背带必须在任何方向上分配力和力矩。理论上在完美的控制下在操作员和机器之间只需要转移平衡负载，但是在控制器开发期间绑带需要承受任何可能的负载。</p>
<h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><img src="/2021/11/01/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/BLEEX/37221533727400.5fb0a22b2d89e.jpg" class>
<hr>
<h2 id="控制策略"><a href="#控制策略" class="headerlink" title="控制策略"></a>控制策略</h2><p>BLEEX下肢外骨骼的有效性来自于穿戴者提供的人类智能和外骨骼提供的力量优势。换句话说，人类为外骨骼提供了一个智能控制系统，而外骨骼执行器提供了行走所需的大部分力量。控制算法确保外骨骼与穿戴者之间的协调运动，使两者之间的相互作用力最小。控制器不需要直接测量人机之间的交互力；相反，控制器只根据外骨骼自身的测量数据来估计如何移动才能让穿戴者感受到很小的力量。该控制方案之前从未应用于任何机器人系统，是在穿戴者与外骨骼的接触位置未知且不可预测的情况下产生运动的有效方法。该控制方法不同于应用于上肢外骨骼和触觉系统的柔顺控制方法，因为它不需要穿戴者与外骨骼之间的力传感器。</p>
<p>BLEEX控制的基本原理是：<strong>外骨骼需要快速且无延迟地跟踪穿戴者的自主和非自主运动</strong>。这需要对外骨骼上的力和力矩进行高灵敏性的响应，尤其是那些由穿戴者作用在外骨骼上的力。在闭环反馈系统的设计中，这一需求与控制科学中最小化系统灵敏度的目标发生冲突。如果外骨骼的灵敏度较低，它就无法与佩戴者协调运动；而提高系统对外部力和力矩的灵敏度，则会导致系统鲁棒性的损失。</p>
<p>考虑到这个新方法，我们的目标是开发一个高灵敏度的BLEEX控制系统，在这过程中面临两个现实的问题。第一问题是，外骨骼对外部力和扭矩的高灵敏度会对穿戴者以外的力做出反应。例如，如果有人推一个具有高灵敏度的外骨骼，外骨骼就会像它在穿戴者的控制下一样移动。尽管这种对于外力不稳定的行为听起来像一个严重的问题，当其发生时，穿戴者可以通过主动的控制来抵抗这些非期望的运动。稳定外骨骼并的关键在于穿戴者自身的快速移动，为自己和外骨骼创造一个稳定的环境。因此需要设计一个非常宽的控制带宽，这样外骨骼才能即使响应穿戴者的自愿和非自愿运动（对扰动的反应）。第二个问题是，对外力和扭矩的高灵敏度的系统对变化不具有鲁棒性，因此系统性能的精度将取决于外骨骼动态模型的精度。这是一个严重的缺点，但我们认为是不可避免的。尽管如此，我们实验室的各种实验已经证明了该控制方法在跟踪穿戴者运动方面的有效性。</p>
<h3 id="灵敏度放大控制"><a href="#灵敏度放大控制" class="headerlink" title="灵敏度放大控制"></a>灵敏度放大控制</h3><h4 id="单自由度情况"><a href="#单自由度情况" class="headerlink" title="单自由度情况"></a>单自由度情况</h4><p>接下将从单自由度情况对控制算法进行分析。</p>
<p><img src="/2021/11/01/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/BLEEX/1580829876938-8447654.png" style="zoom: 80%;"></p>
<p>图2所示为人腿与一自由度外骨骼的连接情况，其中外骨骼腿为一个围绕关节旋转的刚性连接，并由一个驱动器驱动，能够在A点产生一个力矩。穿戴者除了脚与外骨骼相连外，身体的其他地方也可以与外骨骼相连接，这些连接的位置和作用力的方向可以未知的。穿戴者作用在外骨骼上的等效力矩用 $d$ 表示。</p>
<p><img src="/2021/11/01/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/BLEEX/1580831833133-8447654.png" style="zoom:80%;"></p>
<p>图三表示在不考虑重力作用下，外骨骼的动力学特性：</p>
<script type="math/tex; mode=display">
v=Gr+Sd</script><p>$v$为外骨骼的角速度，$r$为驱动器输入（力矩），$G$为$r$到$v$的传递函数。$S$表示等效交互力矩$d$到外骨骼速度$v$之间的传递函数，也称为灵敏度函数。<strong>灵敏度函数表示等效交互力矩$d$与外骨骼速度$v$之间的映射关系，灵敏度函数的幅值越大则交互力越容易改变外骨骼的速度；当灵敏度函数非常大时，很小的交互力就可以产生很大的速度，换而言之人机之间的交互力会很小</strong>。如果执行机构已经有某种主要的稳定控制器，那么人机之间的交互力矩对稳定控制器而言是外界扰动，交互力矩对外骨骼的影响将会变小，新系统下灵敏度函数的幅值也会减小。</p>
<p>注意到等效交互力矩$d$并不是一个外部输入，它是关于外骨骼穿戴者生物力学和动力学的函数。控制器设计的目标是尽可能的减少等效交互力矩。一种直接的思路是对d进行测量，然后设计相应的控制器，但在我们的前期试验中发现，现有传感器技术无法做到力矩的准确测量，同时也会给系统的设计和成本带来很多问题。因此我们想通过非直接测量的方式来实现我们的控制目标。</p>
<p><img src="/2021/11/01/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/BLEEX/1580834475727-8447654.png" style="zoom:80%;"></p>
<p>考虑为外骨骼设计一个负反馈控制器$C$，如图4所示。则在反馈回路下，新的灵敏度函数为：</p>
<script type="math/tex; mode=display">
S_{N E W}=\frac{v}{d}=\frac{S}{1+G C}</script><p>可以看出在负反馈控制下，$1+G C&gt;1$，因而总是有$S_{N E W} \leq S$。</p>
<p>实际上，在经典控制和现代控制理论中，人们尽一切努力使系统对外部力和力矩的灵敏度函数最小化。但是对于外骨骼控制，我们需要一个完全相反的目标：最大化闭环系统对力和力矩的敏感性。为了实现这个目标，我们利用外骨骼的逆动力学模型，并通过正反馈进行控制：</p>
<script type="math/tex; mode=display">
S_{N E W}=\frac{v}{d}=\frac{S}{1-G C}</script><p>如果选择$C=0.9 G^{-1}$，则$S_{N F W}=10 S$，也就是在正反馈控制下外骨骼的灵敏度函数变为原来的10倍。因此我们设计的外骨骼控制器的一般形式为：</p>
<script type="math/tex; mode=display">
C=\left(1-\alpha^{-1}\right) G^{-1}</script><p>其中$\alpha$为大于1的方法系数。另外需要注意的是，在实际实现时控制器$C$中还需要加入对高频噪声的滤波器。</p>
<h4 id="参数变化的鲁棒性"><a href="#参数变化的鲁棒性" class="headerlink" title="参数变化的鲁棒性"></a>参数变化的鲁棒性</h4><p>看出这种控制器严重依赖模型，当模型不准确时，控制器的性能较差。当模型存在10%的不确定时，灵敏度函数的不确定性达到90%。因此要想要使这种方法有比较好的效果，就必须对外骨骼的动力学模型有深刻的理解。这种方法可以看做是传感与控制之间一种tradeoff：若想不依赖交互力的信息，则必须要有准确的模型。这种方法本身不具备稳定性，系统的稳定是由穿戴者自身的控制来实现，接下来我们将进一步说明。</p>
<h4 id="人体动力学"><a href="#人体动力学" class="headerlink" title="人体动力学"></a>人体动力学</h4><p>在所涉及的控制方案中，不需要考虑穿戴者肢体模型的内部组成：神经传导、肌肉收缩以及中枢神经系统的详细动态过程，这些在构建飞行员肢体的动态模型时被隐式地考虑。假设穿戴者与外骨的人机交互力是关于穿戴者人体的动力学$H$和运动学的函数，这里认为$H$是一个非线性函数并表示穿戴者的运动学与交互阻抗之间的关系：</p>
<script type="math/tex; mode=display">
d=-H(v)</script><p><img src="/2021/11/01/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/BLEEX/1580849529486-8447654.png" style="zoom:80%;"></p>
<p>考虑人体动力学之后，人机系统就可以看过是一个双闭环的系统，如上图所示。上层反馈环路展示穿戴者的交互力对外骨骼的影响，底层环路展示反馈控制器对外骨骼的作用。尽管下面环路中的控制器是一个不稳定的正反馈，但上面环路中穿戴者的操控可以使整个系统得以稳定。也就是说，系统的稳定性取决于人体的平衡能力，人的平衡能力越强，那就可以设计更加不稳定的控制器，使人承受更多的重量，为此，作者Kazerooni改用尼采的名言来描述这种方法：</p>
<blockquote>
<p><strong>That which does not stabilize, will only make us stronger.</strong></p>
</blockquote>
<p><img src="/2021/11/01/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/BLEEX/v2-8369d023b420645ae1a71d284f884ba4_1440w.jpeg" style="zoom:50%;"></p>
<h3 id="控制算法的实现"><a href="#控制算法的实现" class="headerlink" title="控制算法的实现"></a>控制算法的实现</h3><p>在一般的步态分析中，步态周期通常被划分为7个阶段。在本文的方法中，出于简单考虑我们将其分为具有不同动力学模型的3个阶段：单支撑阶段、双支撑阶段和有冗余的双支撑阶段，最后一个是指后侧脚后跟抬起的状态，如图8所示：</p>
<p><img src="/2021/11/01/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/BLEEX/1580850923188-8447654.png" style="zoom:90%;"></p>
<p>在控制器设计的初期，我们将髋关节外展/内收的控制与其他的控制进行了解耦。髋关节的外展/内收运动相对缓慢，与矢状面运动相比，外展-内收运动可视为准静态运动，对系统其余部分的动态影响较小；这也表明外骨骼矢状面上的动力学只受髋关节外展/内收角影响，而与其速度、加速度无关。</p>
<h4 id="单支撑阶段"><a href="#单支撑阶段" class="headerlink" title="单支撑阶段"></a>单支撑阶段</h4><p>在单支撑阶段，我们将BLEEX建模为矢状面上7自由度的连杆机构，如图10所示。动力学模型可以表示为：</p>
<script type="math/tex; mode=display">
M(\theta) \ddot{\theta}+C(\theta, \dot{\theta}) \dot{\theta}+P(\theta)=T+d</script><p>其中$\theta=\left[\begin{array}{lll}{\theta_{1}} &amp; {\theta_{2}} &amp; {\cdots} &amp; {\theta_{7}}\end{array}\right]^{T}$，$T=\left[\begin{array}{lll}{0} &amp; {T_{1}} &amp; {T_{2}} &amp; {\dots} &amp;  {T_{6}} \end{array}\right]^{T}$，$M$ 为质量矩阵，$C$ 为离心力与科氏力矩阵，$P$ 为重力向量，$T$ 为驱动器力矩向量，$d$ 为等效人机交互力矩向量。</p>
<p>则控制器的控制可表示为：</p>
<script type="math/tex; mode=display">
T=\hat{P}(\theta)+\left(1-\alpha^{-1}\right)[\hat{M}(\theta) \ddot{\theta}+\hat{C}(\theta, \dot{\theta}) \dot{\theta}]</script><p>其中第一项可以理解为对重力作用的补偿，后面一项为正反馈项。在理想情况下，放大系数较大时，交互力矩近似接近于零；每当人机之间存在交互力时，控制器控制电机迅速产生驱动作用补偿由模型估计的交互力，使得交互力维持在一个很小的水平。</p>
<p><img src="/2021/11/01/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/BLEEX/1580851493579-8447654.png" style="zoom:67%;"></p>
<h4 id="双支撑阶段"><a href="#双支撑阶段" class="headerlink" title="双支撑阶段"></a>双支撑阶段</h4><p><img src="/2021/11/01/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/BLEEX/1580853229872-8447654.png" style="zoom:67%;"></p>
<p>在双支撑阶段，BLEEX的两条腿与地面均有接触与力的作用。外骨骼被建模为两个三自由度平面连杆并在顶轴相连接，如图11所示。动力学模型表示为如下形式：</p>
<script type="math/tex; mode=display">
M_{L}\left(m_{T L}, \theta_{L}\right) \ddot{\theta}_{L}+C_{L}\left(m_{T L}, \dot{\theta}_{L}, \theta_{L}\right) \dot{\theta}_{L}+P_{L}\left(m_{T L}, \theta_{L}\right)=T_{L}+d_{L}</script><script type="math/tex; mode=display">
M_{R}\left(m_{T R}, \theta_{R}\right) \ddot{\theta}_{R}+C_{R}\left(m_{T R}, \dot{\theta}_{R}, \theta_{R}\right) \dot{\theta}_{R}+P_{R}\left(m_{T R}, \theta_{R}\right)=T_{R}+d_{R}</script><p>其中$ \theta_{L}=\left[\begin{array}{lll}{\theta_{L I}} &amp; {\theta_{L 2}} &amp; {\theta_{L 3}}\end{array}\right]^{T}$， $\theta_{R}=\left[\begin{array}{lll}{\theta_{R l}} &amp; {\theta_{R 2}} &amp; {\theta_{R 3}}\end{array}\right]^{T}$，$m_{T R}$和$m_{T L}$表示每条腿所支撑的躯干质量，并进一步用躯干质心相对踝关节的水平距离进行简化计算（只在准静态条件下适用）：</p>
<script type="math/tex; mode=display">
\frac{m_{T R}}{m_{T L}}=\frac{x_{T L}}{x_{T R}}</script><p>在双支撑阶段，控制器的控制率可表示为：</p>
<script type="math/tex; mode=display">
T_{L}=\hat{P}_{L}\left(m_{T L}, \theta_{L}\right)+\left(1-\alpha^{-1}\right)\left[\hat{M}_{L}\left(m_{T L}, \theta_{L}\right) \ddot{\theta}_{L}+\hat{C}_{L}\left(m_{T L}, \theta_{L}, \dot{\theta}_{L}\right) \dot{\theta}_{L}\right]</script><script type="math/tex; mode=display">
T_{R}=\hat{P}_{R}\left(m_{T R}, \theta_{R}\right)+\left(1-\alpha^{-1}\right)\left[\hat{M}_{R}\left(m_{T R}, \theta_{R}\right) \ddot{\theta}_{R}+\hat{C}_{R}\left(m_{T R}, \theta_{R}, \dot{\theta}_{R}\right) \dot{\theta}_{R}\right]</script><h4 id="冗余双支撑阶段"><a href="#冗余双支撑阶段" class="headerlink" title="冗余双支撑阶段"></a>冗余双支撑阶段</h4><p>在冗余双支撑阶段，外骨骼的站立腿建模为平面三连杆，而另一条腿建模为平面四连杆，如图11所示。动力学模型与双支撑阶段形式相同，其中</p>
<script type="math/tex; mode=display">
\theta_{L}=\left[\begin{array}{llll}{\theta_{L 1}} & {\theta_{L 2}} & {\theta_{L 3}} & {\theta_{L 4}}\end{array}\right]^{T}</script><script type="math/tex; mode=display">
\theta_{R}=\left[\begin{array}{lll}{\theta_{R I}} & {\theta_{R 2}} & {\theta_{R 3}}\end{array}\right]^{T}</script><script type="math/tex; mode=display">
T_{L}=\left[\begin{array}{llll}{0} & {T_{L 1}} & {T_{L 2}} & {T_{L 3}}\end{array}\right]^{T}</script><script type="math/tex; mode=display">
T_{R}=\left[\begin{array}{lll}{T_{R 1}} & {T_{R 2}} & {T_{R 3}}\end{array}\right]^{T}</script><h3 id="混合控制"><a href="#混合控制" class="headerlink" title="混合控制"></a>混合控制</h3><p>灵敏度放大控制能够快速跟随穿戴者的运动，但这种方法依赖系统的精确模型，当模型、负载变化时会严重影响控制性能。之后BLEEX的研究人员采用混合控制策略：支撑阶段采用位置控制，摆动阶段采用灵敏度放大控制。这种控制能够降低对精确模型的依赖程度，从而提高系统的鲁棒性和稳定性。</p>
<p>在步态运动的过程中，摆动腿运动范围大但只需要支撑自己的重量，支撑腿的运动范围小但却需要支撑整个躯干和负载的重力；反应到控制中，摆动腿需要相对小的力矩和相对高的带宽，而支撑腿需要相对大的力矩和相对低的带宽。基于这个观点，我们在BLEEX中采用混合控制：支撑阶段采用位置控制，而摆动阶段采用灵敏度放大控制。因此，鲁棒稳定性（支撑阶段的位置控制）和对穿戴者人机交互力的高灵敏性（摆动阶段的灵敏度放大控制）能够在BLEEX上同时得以实现。</p>
<h4 id="摆动阶段：灵敏度放大控制"><a href="#摆动阶段：灵敏度放大控制" class="headerlink" title="摆动阶段：灵敏度放大控制"></a>摆动阶段：灵敏度放大控制</h4><p>在摆动阶段采用灵敏度放大控制，正如如上所述，其中只采用摆动阶段的建模与控制。</p>
<h4 id="支撑阶段：位置控制"><a href="#支撑阶段：位置控制" class="headerlink" title="支撑阶段：位置控制"></a>支撑阶段：位置控制</h4><p>在支撑阶段，控制器使外骨骼的关节角度跟踪穿戴者的关节角度，控制结构图如下：</p>
<p><img src="/2021/11/01/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/BLEEX/1581258656321.png" style="zoom:80%;"></p>
<p>理想情况下，当角度误差为零时，人机之间的交互力矩也近似为零。控制器的实现采用比例控制：</p>
<script type="math/tex; mode=display">
T_{a c t}=K\left(\theta_{h}-\theta_{e x o}\right)</script><p>对于每一个关节，采用独立的控制器进行控制：</p>
<p><img src="/2021/11/01/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/BLEEX/1581259115805.png" style="zoom:80%;"></p>
<p>在单关节（膝关节）情况下的控制效果如下所示（采样周期25ms），在低频时有不错的跟踪效果：</p>
<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img src="/2021/11/01/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/BLEEX/1581258867007.png" class></div><div class="group-picture-column" style="width: 50%;"><img src="/2021/11/01/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/BLEEX/1581258884955.png" class></div></div></div></div>
<p>在进行位置控制时，有两点需要注意。第一个问题是外骨骼与人体之间必须为柔顺连接，如图6所示。当人体想要进行运动时，其必须要很容易就能移动，也就是人机之间的阻抗应当很小，这样才能够产生位置误差，进而使外骨骼跟随；当人机之间为图11所示刚性连接时，穿戴者需要同时移动自己和外骨骼，此时人机之间的关节角误差将始终为零，同时交互力矩也将会很大。</p>
<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img src="/2021/11/01/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/BLEEX/1581259199208.png" class></div><div class="group-picture-column" style="width: 50%;"><img src="/2021/11/01/%E5%A4%96%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/BLEEX/1581259345430.png" class></div></div></div></div>
<p>另外一个问题是外骨骼关节角与人体关节角之间的差异，由于BLEEX是拟人化设计，角度差异所导致的影响比较小，因此就没有专门进行处理。</p>
<blockquote>
<p>在研究的前期阶段，研究人员有尝试在步态的整个过程都使用位置控制，但很快发现这种方法在摆动阶段并不合适。穿戴者需要主动移动躯干才能使外骨骼前进，因此外骨骼的行走过程非常不自然，同时穿戴者感觉也非常不舒服。</p>
</blockquote>
<h4 id="控制器的过渡问题"><a href="#控制器的过渡问题" class="headerlink" title="控制器的过渡问题"></a>控制器的过渡问题</h4><p>由于在步态过程中采用两种不同的控制方案，为了避免控制器切换时的突变，需要设置控制器的过渡策略。研究采用渐变增益的方法，其中由灵敏度放大控制切换到位置控制的过渡时间为1s，由位置控制切换到灵敏度放大控制的过渡时间为0.4s。</p>
<hr>
<h2 id="小结与思考"><a href="#小结与思考" class="headerlink" title="小结与思考"></a>小结与思考</h2><p>从设计初衷来说，BLEEX的operator的思想使其更像是“机甲”，穿戴者是一个“装甲”的操作者而不是一个被强化的“Superman”。作为旧世代最出名的外骨骼，BLEEX的结构设计有诸多精妙之处。BLEEX将外骨骼结构设计向伪拟人化和非拟人化方向拓展，非拟人化架构只在躯干和足部进行刚性固定，而中间没有刚性固定；人和外骨骼具有各自的运动链，可看做并联结构，没有关节轴对齐问题；结构上的Actuator Mount、Foot Attachment、Length Adjustment、Pressure Sensor都值得借鉴，模块化设计也是很好的尝试。</p>
<p>本研究所提出的灵敏度放大方法本质上是一种正反馈控制，通过放大扰动来实现对穿戴者的运动跟随。控制器本身不具有稳定性，但可以由穿戴者稳定住整个系统。灵敏度放大不直接测量交互力，控制带宽高、响应快，但对模型参数不具有鲁棒性，无法对抗外界扰动，以至于作者自身都不得不考虑使用混合控制来减少不稳定的影响。虽算法本身在真实系统上实现时会遇到各种问题，但其所反映的思想却清晰直观：外骨骼控制的目的是放大，放大人体力量，并同时降低人体所承受的作用。这为外骨骼领域的研究拓展了思路，在很多系统中依然可以看到这个思想的影子。</p>
<hr>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="/download/2005_BLEEX_mechanical_design.pdf">On the Mechanical Design of the  Berkeley Lower Extremity Exoskeleton (BLEEX)</a></p>
<p><a href="/download/2005_BLEEX_Control.pdf">On the Control of the  Berkeley Lower Extremity Exoskeleton (BLEEX)</a></p>
<p><a href="/download/2006_BLEEX_Hybird_Control.pdf">Hybrid Control of the Berkeley Lower Extremity Exoskeleton (BLEEX)</a></p>
]]></content>
      <categories>
        <category>exoskeleton</category>
      </categories>
      <tags>
        <tag>外骨骼系统</tag>
      </tags>
  </entry>
</search>
